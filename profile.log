SCRIPT  /Users/Jack/.vim/plugged/nerdtree/syntax/nerdtree.vim
Sourced 15 times
Total time:   0.044544
 Self time:   0.044544

count  total (s)   self (s)
                            let s:tree_up_dir_line = '.. (up a dir)'
   15              0.001497 syn match NERDTreeIgnore #\~#
   15              0.000713 exec 'syn match NERDTreeIgnore #\['.g:NERDTreeGlyphReadOnly.'\]#'
                            
                            "highlighting for the .. (up dir) line at the top of the tree
   15              0.000584 execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line ."#"
                            
                            "quickhelp syntax elements
   15              0.000552 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#ms=s+2,me=e-1
   15              0.000481 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#ms=s+2,me=e-1
   15              0.000474 syn match NERDTreeHelpTitle #" .*\~#ms=s+2,me=e-1
   15              0.000410 syn match NERDTreeToggleOn #(on)#ms=s+1,he=e-1
   15              0.000398 syn match NERDTreeToggleOff #(off)#ms=e-3,me=e-1
   15              0.000411 syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
   15              0.003477 syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeIgnore,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand
                            
                            "highlighting for sym links
   15              0.001364 syn match NERDTreeLinkTarget #->.*# containedin=NERDTreeDir,NERDTreeFile
   15              0.000881 syn match NERDTreeLinkFile #.* ->#me=e-3 containedin=NERDTreeFile
   15              0.000838 syn match NERDTreeLinkDir #.*/ ->#me=e-3 containedin=NERDTreeDir
                            
                            "highlighing for directory nodes and file nodes
   15              0.000930 syn match NERDTreeDirSlash #/# containedin=NERDTreeDir
                            
   15              0.001653 exec 'syn match NERDTreeClosable #'.escape(g:NERDTreeDirArrowCollapsible, '~').'# containedin=NERDTreeDir,NERDTreeFile'
   15              0.001656 exec 'syn match NERDTreeOpenable #'.escape(g:NERDTreeDirArrowExpandable, '~').'# containedin=NERDTreeDir,NERDTreeFile'
                            
   15              0.000224 let s:dirArrows = escape(g:NERDTreeDirArrowCollapsible, '~]\-').escape(g:NERDTreeDirArrowExpandable, '~]\-')
   15              0.000522 exec 'syn match NERDTreeDir #[^'.s:dirArrows.' ].*/#'
   15              0.001381 syn match NERDTreeExecFile  #^ .*\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmark
   15              0.002560 exec 'syn match NERDTreeFile  #^[^"\.'.s:dirArrows.'] *[^'.s:dirArrows.']*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile'
                            
                            "highlighting for readonly files
   15              0.002142 exec 'syn match NERDTreeRO # *\zs.*\ze \['.g:NERDTreeGlyphReadOnly.'\]# contains=NERDTreeIgnore,NERDTreeBookmark,NERDTreeFile'
                            
   15              0.001416 syn match NERDTreeFlags #^ *\zs\[.\]# containedin=NERDTreeFile,NERDTreeExecFile
   15              0.000831 syn match NERDTreeFlags #\[.\]# containedin=NERDTreeDir
                            
   15              0.000352 syn match NERDTreeCWD #^[</].*$#
                            
                            "highlighting for bookmarks
   15              0.000345 syn match NERDTreeBookmark # {.*}#hs=s+1
                            
                            "highlighting for the bookmarks table
   15              0.000402 syn match NERDTreeBookmarksLeader #^>#
   15              0.000947 syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
   15              0.000797 syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
   15              0.001682 syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader
                            
   15              0.000556 hi def link NERDTreePart Special
   15              0.000588 hi def link NERDTreePartFile Type
   15              0.000561 hi def link NERDTreeExecFile Title
   15              0.000491 hi def link NERDTreeDirSlash Identifier
                            
   15              0.000518 hi def link NERDTreeBookmarksHeader statement
   15              0.000466 hi def link NERDTreeBookmarksLeader ignore
   15              0.000494 hi def link NERDTreeBookmarkName Identifier
   15              0.000529 hi def link NERDTreeBookmark normal
                            
   15              0.000566 hi def link NERDTreeHelp String
   15              0.000512 hi def link NERDTreeHelpKey Identifier
   15              0.000486 hi def link NERDTreeHelpCommand Identifier
   15              0.000484 hi def link NERDTreeHelpTitle Macro
   15              0.000540 hi def link NERDTreeToggleOn Question
   15              0.000445 hi def link NERDTreeToggleOff WarningMsg
                            
   15              0.000428 hi def link NERDTreeLinkTarget Type
   15              0.000423 hi def link NERDTreeLinkFile Macro
   15              0.000456 hi def link NERDTreeLinkDir Macro
                            
   15              0.000436 hi def link NERDTreeDir Directory
   15              0.000435 hi def link NERDTreeUp Directory
   15              0.000422 hi def link NERDTreeFile Normal
   15              0.000423 hi def link NERDTreeCWD Statement
   15              0.000432 hi def link NERDTreeOpenable Directory
   15              0.000431 hi def link NERDTreeClosable Directory
   15              0.000427 hi def link NERDTreeIgnore ignore
   15              0.000463 hi def link NERDTreeRO WarningMsg
   15              0.000486 hi def link NERDTreeBookmark Statement
   15              0.000445 hi def link NERDTreeFlags Number
                            
   15              0.000561 hi def link NERDTreeCurrentNode Search

SCRIPT  /Users/Jack/.vim/plugged/vim-rails/compiler/rails.vim
Sourced 137 times
Total time:   5.981283
 Self time:   5.951662

count  total (s)   self (s)
                            " Vim compiler file
                            
  137              0.002811 if exists("current_compiler")
                              finish
                            endif
                            
  137              0.007125 CompilerSet errorformat=%D(in\ %f),
                                  \%\\s%#from\ %f:%l:%m,
                                  \%\\s%#from\ %f:%l:,
                                  \%\\s%##\ %f:%l:%m,
                                  \%\\s%##\ %f:%l,
                                  \%\\s%#[%f:%l:\ %#%m,
                                  \%\\s%#%f:%l:\ %#%m,
                                  \%\\s%#%f:%l:,
                                  \%m\ [%f:%l]:,
                                  \%+Erake\ aborted!,
                                  \%+EDon't\ know\ how\ to\ build\ task\ %.%#,
                                  \%+Einvalid\ option:%.%#,
                                  \%+Irake\ %\\S%\\+%\\s%\\+#\ %.%#
                            
  137              3.766366 runtime! compiler/rake.vim
                            
  137              0.001057 let current_compiler = "rails"
                            
  137              0.002132 CompilerSet makeprg=rails
                            " CompilerSet makeprg=ruby\ bin/rails
                            " CompilerSet makeprg=ruby\ script/rails
                            
  137              0.007713 CompilerSet errorformat^=
                                  \%\\S%\\+\ \ %#%[cefi]%[rxod]%[eir]%[a-z]%#%\\x1b[0m\ %\\+%\\S%\\+%$
                                  \%\\&%\\x1b%\\S%\\+\ \ %#%m%\\>%\\x1b[0m\ \ %#%f,
                                  \%\\s\ %#%[cefi]%[rxod]%[eir]%[a-z]%#\ %\\+%\\S%\\+%$
                                  \%\\&%\\s\ %#%m%\\>\ \ %#%f,
                                  \\ %#Overwrite%.%#%\\S%\\+\ \ %#%m%\\x1b[0m\ \ %#%f,
                                  \%-G\ %#Overwrite%.%#\"h\"%.%#,
                                  \%+GStarted\ %\\u%\\u%.%#,
                                  \%+GCompleted\ %\\d%\\d%\\d%.%#,
                                  \%+G[ActiveJob]%.%#]\ Perform%.%#,
                                  \%.%#rails\ test\ %f:%l,
                                  \%+GCurrent\ version:%.%#,
                                  \%+G\ %#Status\ %#Migration\ ID%.%#,
                                  \%+G\ The\ fixture\ ID\ for\ %.%#,
                                  \%f:\ %s\ (%m)%$
                                  \%\\&%.%#/fixtures/%.%#(%\\d%\\+),
                                  \%+G\ %#Prefix\ %#Verb%.%#,
                                  \%+G\ %#Code\ LOC:\ %.%#,
                                  \%+GAbout\ your\ application's\ environment,
                                  \%+Grun\ %\\S%#::Application.routes,
                                  \%+Irails\ %\\S%\\+%\\s%\\+#\ %.%#,
                                  \%+Eruby:%.%#(LoadError),
                                  \%+EUsage:%.%#,
                                  \%+ECould\ not\ find\ generator%.%#,
                                  \%+EType\ 'rails'\ for\ help.
                            
                            " -complete=customlist,rails#complete_rails

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/compiler/rake.vim
Sourced 137 times
Total time:   0.025648
 Self time:   0.025648

count  total (s)   self (s)
                            " Vim compiler file
                            " Language:		Rake
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            
  137              0.004167 if exists("current_compiler")
                              finish
                            endif
  137              0.001455 let current_compiler = "rake"
                            
  137              0.002109 if exists(":CompilerSet") != 2		" older Vim always used :setlocal
                              command -nargs=* CompilerSet setlocal <args>
                            endif
                            
  137              0.001910 let s:cpo_save = &cpo
  137              0.002293 set cpo-=C
                            
  137              0.002001 CompilerSet makeprg=rake
                            
  137              0.002805 CompilerSet errorformat=
                                  \%D(in\ %f),
                                  \%\\s%#from\ %f:%l:%m,
                                  \%\\s%#from\ %f:%l:,
                                  \%\\s%##\ %f:%l:%m,
                                  \%\\s%##\ %f:%l,
                                  \%\\s%#[%f:%l:\ %#%m,
                                  \%\\s%#%f:%l:\ %#%m,
                                  \%\\s%#%f:%l:,
                                  \%m\ [%f:%l]:
                            
  137              0.002950 let &cpo = s:cpo_save
  137              0.000728 unlet s:cpo_save
                            
                            " vim: nowrap sw=2 sts=2 ts=8:

SCRIPT  /Users/Jack/.vim/plugged/scss-syntax.vim/syntax/scss.vim
Sourced 35 times
Total time: 137.677933
 Self time:  16.685438

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:    SCSS (Sassy CSS)
                            " Author:      Daniel Hofstetter (daniel.hofstetter@42dh.com)
                            " URL:         https://github.com/cakebaker/scss-syntax.vim
                            " Last Change: 2015-04-22
                            " Inspired by the syntax files for sass and css. Thanks to the authors of
                            " those files!
                            
   35              0.001419 if !exists("main_syntax")
   35              0.000400   if exists("b:current_syntax")
                                finish
                              endif
   35              0.000532   let main_syntax = 'scss'
   35              0.000093 endif
                            
   35              0.340450 runtime! syntax/css.vim
   35              2.051039 runtime! syntax/css/*.vim
                            
   35              0.000202 syn case ignore
                            
                            " XXX fix for #20, can be removed once the patch is in vim's css.vim
   35              0.000968 syn match cssSpecialCharQQ +\\\\\|\\"+ contained
   35              0.000573 syn match cssSpecialCharQ +\\\\\|\\'+ contained
                            
                            " XXX fix for #37
   35              0.000322 if v:version < 704
                              " replace the definition of cssBoxProp with the one from Vim 7.4 to prevent
                              " highlighting issues
                              syn clear cssBoxProp
                              syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
                              syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
                              syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
                              syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
                            endif
                            
                            " override @font-face blocks to allow scss elements inside
   35              0.061668 syn region cssFontDescriptorBlock contained transparent matchgroup=cssBraces start="{" end="}" contains=cssError,cssUnicodeEscape,cssFontProp,cssFontAttr,cssCommonAttr,cssStringQ,cssStringQQ,cssFontDescriptorProp,cssValue.*,cssFontDescriptorFunction,cssUnicodeRange,cssFontDescriptorAttr,@comment,scssDefinition,scssFunction,scssVariable,@scssControl,scssDebug,scssError,scssWarn
                            
   35              0.057172 syn region scssDefinition matchgroup=cssBraces start='{' end='}' contains=cssString.*,cssInclude,cssFontDescriptor,scssAtRootStatement,@comment,scssDefinition,scssProperty,scssSelector,scssVariable,scssImport,scssExtend,scssInclude,scssInterpolation,scssFunction,@scssControl,scssWarn,scssError,scssDebug,scssReturn containedin=cssMediaBlock fold
                            
   35              0.001045 syn match scssSelector _^\zs\([^:@]\|:[^ ]\|['"].*['"]\)\+{\@=_ contained contains=@scssSelectors
   35              0.000751 syn match scssSelector "^\s*\zs\([^:@{]\|:[^ ]\|['"].*['"]\)\+\_$" contained contains=@scssSelectors
                            " fix for #54 to recognize a multiline selector containing a string interpolation
   35              0.000694 syn match scssSelector "^\zs\([^:@]\|:[^ ]\)\+#{.*}[^;{]\+\_$" contained contains=@scssSelectors
   35              0.004221 syn cluster scssSelectors contains=@comment,cssSelectorOp,cssTagName,cssPseudoClass,cssAttributeSelector,scssSelectorChar,scssAmpersand,scssInterpolation
                            
   35              0.070549 syn match scssProperty "\([[:alnum:]-]\)\+\s*\(:\)\@=" contained contains=css.*Prop,cssVendor containedin=cssMediaBlock nextgroup=scssAttribute,scssAttributeWithNestedDefinition
   35              0.138690 syn match scssAttribute ":[^;]*\ze\(;\|}\)" contained contains=css.*Attr,cssValue.*,cssColor,cssFunction,cssString.*,cssURL,scssFunction,scssInterpolation,scssVariable
                            
   35              0.092713 syn match scssAttributeWithNestedDefinition ": [^#]*{\@=" nextgroup=scssNestedDefinition contained contains=css.*Attr,cssValue.*,scssVariable
   35              0.001759 syn region scssNestedDefinition matchgroup=cssBraces start="{" end="}" contained contains=@comment,scssProperty,scssNestedProperty
                            
                            " CSS properties from https://developer.mozilla.org/en-US/docs/Web/CSS/Reference
                            " align
   35              0.001995 syn keyword scssNestedProperty contained content items self nextgroup=scssAttribute
                            " animation
   35              0.003577 syn keyword scssNestedProperty contained delay direction duration fill-mode iteration-count name play-state timing-function nextgroup=scssAttribute
                            " background
   35              0.001937 syn keyword scssNestedProperty contained attachment clip color image origin position repeat size nextgroup=scssAttribute
                            " border
   35              0.002632 syn keyword scssNestedProperty contained bottom bottom-color bottom-left-radius bottom-right-radius bottom-style bottom-width nextgroup=scssAttribute
   35              0.000821 syn keyword scssNestedProperty contained collapse color nextgroup=scssAttribute
   35              0.002799 syn keyword scssNestedProperty contained image image-outset image-repeat image-slice image-source image-width nextgroup=scssAttribute
   35              0.002076 syn keyword scssNestedProperty contained left left-color left-style left-width nextgroup=scssAttribute
   35              0.549240 syn keyword scssNestedProperty contained radius nextgroup=scssAttribute
   35              0.004345 syn keyword scssNestedProperty contained right right-color right-style right-width nextgroup=scssAttribute
   35              0.002280 syn keyword scssNestedProperty contained spacing style nextgroup=scssAttribute
   35              0.005319 syn keyword scssNestedProperty contained top top-color top-left-radius top-right-radius top-style top-width nextgroup=scssAttribute
   35              0.001461 syn keyword scssNestedProperty contained width nextgroup=scssAttribute
                            " box
   35              0.002858 syn keyword scssNestedProperty contained decoration-break shadow sizing nextgroup=scssAttribute
                            " break
   35              0.001474 syn keyword scssNestedProperty contained after before inside nextgroup=scssAttribute
                            " column
   35              0.006134 syn keyword scssNestedProperty contained count fill gap rule rule-color rule-style rule-width span width nextgroup=scssAttribute
                            " counter
   35              0.002956 syn keyword scssNestedProperty contained increment reset nextgroup=scssAttribute
                            " flex
   35              0.004386 syn keyword scssNestedProperty contained basis direction flow grow shrink wrap nextgroup=scssAttribute
                            " font
   35              0.006313 syn keyword scssNestedProperty contained family feature-settings kerning language-override size size-adjust stretch style synthesis nextgroup=scssAttribute
   35              0.006640 syn keyword scssNestedProperty contained variant variant-alternates variant-caps variant-east-asian variant-ligatures variant-numeric variant-position nextgroup=scssAttribute
   35              0.001552 syn keyword scssNestedProperty contained weight nextgroup=scssAttribute
                            " image
   35              0.002579 syn keyword scssNestedProperty contained rendering resolution orientation nextgroup=scssAttribute
                            " list
   35              0.002059 syn keyword scssNestedProperty contained style style-image style-position style-type nextgroup=scssAttribute
                            " margin/padding
   35              0.001319 syn keyword scssNestedProperty contained bottom left right top nextgroup=scssAttribute
                            " max/min
   35              0.002062 syn keyword scssNestedProperty contained height width nextgroup=scssAttribute
                            " nav
   35              0.001191 syn keyword scssNestedProperty contained down index left right up nextgroup=scssAttribute
                            " object
   35              0.001127 syn keyword scssNestedProperty contained fit position nextgroup=scssAttribute
                            " outline
   35              0.001168 syn keyword scssNestedProperty contained color offset style width nextgroup=scssAttribute
                            " overflow
   35              0.001091 syn keyword scssNestedProperty contained wrap x y nextgroup=scssAttribute
                            " page
   35              0.001190 syn keyword scssNestedProperty contained break-after break-before break-inside nextgroup=scssAttribute
                            " text
   35              0.001148 syn keyword scssNestedProperty contained align align-last combine-horizontal nextgroup=scssAttribute
   35              0.001206 syn keyword scssNestedProperty contained decoration decoration-color decoration-line decoration-style nextgroup=scssAttribute
   35              0.001305 syn keyword scssNestedProperty contained indent orientation overflow rendering shadow transform underline-position nextgroup=scssAttribute
                            " transform
   35              0.001087 syn keyword scssNestedProperty contained origin style nextgroup=scssAttribute
                            " transition
   35              0.001157 syn keyword scssNestedProperty contained delay duration property timing-function nextgroup=scssAttribute
                            " unicode
   35              0.001056 syn keyword scssNestedProperty contained bidi range nextgroup=scssAttribute
                            " word
   35              0.001187 syn keyword scssNestedProperty contained break spacing wrap nextgroup=scssAttribute
                            
   35              0.151649 syn region scssInterpolation matchgroup=scssInterpolationDelimiter start="#{" end="}" contains=cssValue.*,cssColor,cssString.*,scssFunction,scssVariable containedin=cssComment,cssInclude,cssPseudoClassFn,cssPseudoClassLang,cssString.*,cssURL,scssFunction
                            
                            " ignores the url() function so it can be handled by css.vim
   35              0.002586 syn region scssFunction contained matchgroup=scssFunctionName start="\<\(url(\)\@!\([[:alnum:]-_]\)\+\s*(" skip=+([^)]*)+ end=")" keepend extend containedin=cssInclude,cssMediaType
   35              0.153987 syn match scssParameterList ".*" contained containedin=cssFunction,scssFunction contains=css.*Attr,cssColor,cssString.*,cssValue.*,scssBoolean,scssFunction,scssInterpolation,scssMap,scssNull,scssVariable
                            
   35              0.003309 syn match scssVariable "$[[:alnum:]_-]\+" containedin=cssFunction,scssFunction,cssInclude,cssMediaBlock,cssMediaType nextgroup=scssVariableAssignment skipwhite
   35              0.002522 syn match scssVariableAssignment ":" contained nextgroup=scssVariableValue skipwhite
   35              0.132661 syn region scssVariableValue start="" end="\ze[;)]" contained contains=css.*Attr,cssValue.*,cssColor,cssFunction,cssString.*,cssURL,scssBoolean,scssDefault,scssFunction,scssInterpolation,scssNull,scssVariable,scssMap,scssGlobal,scssAmpersand,@comment
   35              0.000534 syn match scssGlobal "!global" contained
                            
   35              0.000319 syn keyword scssNull null contained
   35              0.000289 syn keyword scssBoolean true false contained
   35              0.000307 syn keyword scssBooleanOp and or not contained
                            
   35              0.000735 syn match scssMixin "^@mixin" nextgroup=scssMixinName skipwhite
   35              0.001818 syn match scssMixinName "[[:alnum:]_-]\+" contained nextgroup=scssDefinition,scssMixinParams
   35              0.128889 syn region scssMixinParams contained contains=css.*Attr,cssColor,cssValue.*,cssString.*,cssUrl,cssBoxProp,cssDimensionProp,@comment,scssBoolean,scssNull,scssVariable,scssFunction start="(" end=")" extend
   35              0.001302 syn match scssInclude "@include" nextgroup=scssMixinName skipwhite containedin=cssMediaBlock
   35              0.000750 syn match scssContent "@content" contained containedin=scssDefinition
                            
   35              0.000757 syn match scssFunctionDefinition "^@function" nextgroup=scssFunctionNameWithWhitespace skipwhite
   35              0.001126 syn match scssFunctionNameWithWhitespace "[[:alnum:]_-]\+\s*" contained contains=scssFunctionName nextgroup=scssFunctionParams
   35              0.000332 syn match scssFunctionName "[[:alnum:]_-]\+" contained
   35              0.001136 syn region scssFunctionParams contained start="(" end=")" nextgroup=scssFunctionBody contains=scssVariable skipwhite
   35              0.068939 syn region scssFunctionBody contained matchgroup=cssBraces start="{" end="}" contains=cssString.*,cssValue.*,@scssControl,scssBooleanOp,scssComment,scssVariable,scssReturn,scssFunction,scssDebug,scssError,scssWarn,scssDefinition,scssInterpolation fold
   35              0.000454 syn match scssReturn "@return" contained
   35              0.001179 syn match scssExtend "@extend" nextgroup=scssExtendedSelector skipwhite containedin=cssMediaBlock
   35              0.001954 syn match scssExtendedSelector "[^;]\+" contained contains=cssTagName,cssPseudoClass,scssOptional,scssSelectorChar skipwhite
   35              0.000332 syn match scssOptional "!optional" contained
   35              0.000672 syn match scssImport "@import" nextgroup=scssImportList
   35              0.032746 syn match scssImportList "[^;]\+" contained contains=cssString.*,cssMediaType,cssURL
                            
   35              0.001875 syn match scssSelectorChar "\(#\|\.\|%\)\([[:alnum:]_-]\|#{.*}\)\@=" nextgroup=scssSelectorName containedin=cssMediaBlock,cssPseudoClassFn
   35              0.000912 syn match scssSelectorName "\([[:alnum:]_-]\|#{[^}]*}\)\+" contained contains=scssInterpolation
                            
   35              0.001828 syn match scssAmpersand "&" nextgroup=cssPseudoClass,scssSelectorName containedin=cssMediaBlock
                            
   35              0.000722 syn match scssDebug "@debug" nextgroup=scssOutput
   35              0.000682 syn match scssWarn "@warn" nextgroup=scssOutput
   35              0.000740 syn match scssError "@error" nextgroup=scssOutput
   35              0.071548 syn match scssOutput "[^;]\+" contained contains=cssValue.*,cssString.*,scssFunction,scssVariable
   35              0.000505 syn match scssDefault "!default" contained
                            
   35              0.000825 syn match scssIf "@\=if" nextgroup=scssCondition
   35              0.075393 syn match scssCondition "[^{]\+" contained contains=cssValue.*,cssString.*,scssBoolean,scssBooleanOp,scssFunction,scssNull,scssVariable,scssAmpersand
   35              0.001000 syn match scssElse "@else" nextgroup=scssIf
   35              0.000523 syn match scssElse "@else\(\s*\({\|$\)\)\@="
   35              0.000785 syn match scssWhile "@while" nextgroup=scssCondition
   35              0.002558 syn match scssFor "@for\s\+.*from\s\+.*\(to\|through\)\s\+[^{ ]\+" contains=cssValueNumber,scssFunction,scssVariable,scssForKeyword
   35              0.000467 syn match scssForKeyword "@for\|from\|to\|through" contained
   35              0.001489 syn region scssEach matchgroup=scssEachKeyword start="@each" end="in" contains=scssVariable nextgroup=scssCollection
   35              0.001666 syn region scssCollection start=" " end="\ze{" contained contains=scssFunction,scssMap,scssVariable
   35              0.002047 syn cluster scssControl contains=scssIf,scssElse,scssWhile,scssFor,scssEach
                            
   35              0.001299 syn region scssMap matchgroup=scssMapParens start="[^:alpha:]\=\zs(\ze\(\s*\n.*:\|.\+:\)" end=")" contains=@comment,scssMapKey extend
   35              0.101073 syn match scssMapKey "[^: ]\+\ze[:]" contained contains=css.*Attr,cssString.*,scssVariable nextgroup=scssMapValue
   35              0.096100 syn match scssMapValue "[^,)]\+\ze[,)]" contained contains=cssColor,css.*Prop,cssString.*,cssValueLength,scssBoolean,scssFunction,scssNull,scssVariable
                            
   35              0.001034 syn region scssAtRootStatement start="@at-root" end="\ze{" contains=@scssSelectors,scssAtRoot
   35              0.000368 syn match scssAtRoot "@at-root" contained
   35              0.000417 syn match scssAtRoot "(\zswith\(out\)\=\ze:" contained
                            
   35              0.000860 syn match scssComment "//.*$" contains=@Spell containedin=cssMediaBlock
   35              0.000958 syn cluster comment contains=cssComment,scssComment
   35              0.001155 syn match scssStickyCommentChar "^\/\*\zs!" contained containedin=cssComment
   35              0.000466 syn keyword scssTodo TODO FIXME NOTE OPTIMIZE XXX contained containedin=@comment
                            
   35              0.000532 hi def link scssNestedProperty cssProp
   35              0.000581 hi def link scssVariable  Identifier
   35              0.000565 hi def link scssGlobal    Special
   35              0.000549 hi def link scssNull      Constant
   35              0.000548 hi def link scssBoolean   Constant
   35              0.000546 hi def link scssBooleanOp Operator
   35              0.000555 hi def link scssMixin     PreProc
   35              0.000537 hi def link scssMixinName Function
   35              0.000564 hi def link scssContent   PreProc
   35              0.000578 hi def link scssFunctionDefinition  PreProc
   35              0.000554 hi def link scssFunctionName Function
   35              0.000563 hi def link scssReturn    Statement
   35              0.000554 hi def link scssInclude   PreProc
   35              0.000618 hi def link scssExtend    PreProc
   35              0.000559 hi def link scssOptional  Special
   35              0.000551 hi def link scssComment   Comment
   35              0.000539 hi def link scssStickyCommentChar Special
   35              0.000539 hi def link scssSelectorChar Special
   35              0.000548 hi def link scssSelectorName Identifier
   35              0.000530 hi def link scssAmpersand Character
   35              0.000524 hi def link scssDebug     Debug
   35              0.000524 hi def link scssWarn      Debug
   35              0.000606 hi def link scssError     Debug
   35              0.000544 hi def link scssDefault   Special
   35              0.000531 hi def link scssIf        Conditional
   35              0.000519 hi def link scssElse      Conditional
   35              0.000511 hi def link scssWhile     Repeat
   35              0.000521 hi def link scssForKeyword  Repeat
   35              0.000536 hi def link scssEachKeyword Repeat
   35              0.000540 hi def link scssInterpolationDelimiter Delimiter
   35              0.000530 hi def link scssImport    Include
   35              0.000518 hi def link scssTodo      Todo
   35              0.000527 hi def link scssAtRoot    Keyword
   35              0.000522 hi def link scssMapParens Delimiter
                            
   35              0.000269 let b:current_syntax = "scss"
   35              0.000188 if main_syntax == 'scss'
   35              0.000095   unlet main_syntax
   35              0.000122 endif

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/syntax/css.vim
Sourced 122 times
Total time:   3.927314
 Self time:   3.927314

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Cascading Style Sheets
                            " Previous Contributor List:
                            "               Claudio Fleiner <claudio@fleiner.com> (Maintainer)
                            "               Yeti            (Add full CSS2, HTML4 support)
                            "               Nikolai Weibull (Add CSS2 support)
                            " Maintainer:   Jules Wang      <w.jq0722@gmail.com>
                            " URL:          https://github.com/JulesWang/css.vim
                            " Last Change:  2015 Apr.17
                            
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
  122              0.003408 if !exists("main_syntax")
                              if version < 600
                                syntax clear
                              elseif exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'css'
                            elseif exists("b:current_syntax") && b:current_syntax == "css"
                              finish
                            endif
                            
  122              0.001747 let s:cpo_save = &cpo
  122              0.001677 set cpo&vim
                            
  122              0.000488 syn case ignore
                            
                            " HTML4 tags
  122              0.004993 syn keyword cssTagName abbr address area a b base
  122              0.002814 syn keyword cssTagName bdo blockquote body br button
  122              0.003815 syn keyword cssTagName caption cite code col colgroup dd del
  122              0.003068 syn keyword cssTagName dfn div dl dt em fieldset form
  122              0.003045 syn keyword cssTagName h1 h2 h3 h4 h5 h6 head hr html img i
  122              0.003389 syn keyword cssTagName iframe input ins isindex kbd label legend li
  122              0.003252 syn keyword cssTagName link map menu meta noscript ol optgroup
  122              0.003031 syn keyword cssTagName option p param pre q s samp script small
  122              0.002885 syn keyword cssTagName span strong sub sup tbody td
  122              0.003106 syn keyword cssTagName textarea tfoot th thead title tr ul u var
  122              0.002428 syn keyword cssTagName object svg
  122              0.004109 syn match   cssTagName /\<select\>\|\<style\>\|\<table\>/
                            
                            " 34 HTML5 tags
  122              0.003052 syn keyword cssTagName article aside audio bdi canvas command data
  122              0.003181 syn keyword cssTagName datalist details dialog embed figcaption figure footer
  122              0.003202 syn keyword cssTagName header hgroup keygen main mark menuitem meter nav
  122              0.002949 syn keyword cssTagName output progress rt rp ruby section
  122              0.002860 syn keyword cssTagName source summary time track video wbr
                            
                            " Tags not supported in HTML5
                            " acronym applet basefont big center dir
                            " font frame frameset noframes strike tt
                            
  122              0.002710 syn match cssTagName "\*"
                            
                            " selectors
  122              0.002852 syn match cssSelectorOp "[,>+~]"
  122              0.003118 syn match cssSelectorOp2 "[~|^$*]\?=" contained
  122              0.018891 syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
                            
                            " .class and #id
  122              0.006806 syn match cssClassName "\.[A-Za-z][A-Za-z0-9_-]\+" contains=cssClassNameDot
  122              0.002701 syn match cssClassNameDot contained '\.'
                            
  122              0.000411 try
  122              0.003370 syn match cssIdentifier "#[A-Za-zÀ-ÿ_@][A-Za-zÀ-ÿ0-9_@-]*"
  122              0.000500 catch /^.*/
                            syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
                            endtry
                            
                            " digits
  122              0.006206 syn match cssValueInteger contained "[-+]\=\d\+" contains=cssUnitDecorators
  122              0.006334 syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\=" contains=cssUnitDecorators
  122              0.007071 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\)\>" contains=cssUnitDecorators
  122              0.006215 syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)\>" contains=cssUnitDecorators
  122              0.006004 syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)\>" contains=cssUnitDecorators
  122              0.005848 syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)\>" contains=cssUnitDecorators
                            
                            
  122              0.003423 syn match cssIncludeKeyword /@\(-[a-z]\+-\)\=\(media\|keyframes\|import\|charset\|namespace\|page\)/ contained
                            " @media
  122              0.036789 syn region cssInclude start=/@media\>/ end=/\ze{/ skipwhite skipnl contains=cssMediaProp,cssValueLength,cssMediaKeyword,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType,cssIncludeKeyword,cssMediaComma,cssComment nextgroup=cssMediaBlock
  122              0.003291 syn keyword cssMediaType contained screen print aural braille embossed handheld projection tty tv speech all contained skipwhite skipnl
  122              0.002550 syn keyword cssMediaKeyword only not and contained
  122              0.764899 syn region cssMediaBlock transparent matchgroup=cssBraces start='{' end='}' contains=css.*Attr,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssTagName,cssClassName,cssIdentifier,cssPseudoClass,cssSelectorOp,cssSelectorOp2,cssAttributeSelector fold
  122              0.002768 syn match cssMediaComma "," skipwhite skipnl contained
                            
                            " Reference: http://www.w3.org/TR/css3-mediaqueries/
  122              0.003263 syn keyword cssMediaProp contained width height orientation scan grid
  122              0.003390 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(\(device\)-\)\=aspect-ratio/
  122              0.002591 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-pixel-ratio/
  122              0.002527 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-\(height\|width\)/
  122              0.002890 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(height\|width\|resolution\|monochrome\|color\(-index\)\=\)/
  122              0.001871 syn keyword cssMediaAttr contained portrait landscape progressive interlace
                            
                            " @page
                            " http://www.w3.org/TR/css3-page/
  122              0.008930 syn match cssPage "@page\>[^{]*{\@=" contains=cssPagePseudo,cssIncludeKeyword nextgroup=cssPageWrap transparent skipwhite skipnl
  122              0.002662 syn match cssPagePseudo /:\(left\|right\|first\|blank\)/ contained skipwhite skipnl
  122              0.412503 syn region cssPageWrap contained transparent matchgroup=cssBraces start="{" end="}" contains=cssPageMargin,cssPageProp,cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks
  122              0.005201 syn match cssPageMargin /@\(\(top\|left\|right\|bottom\)-\(left\|center\|right\|middle\|bottom\)\)\(-corner\)\=/ contained nextgroup=cssDefinition skipwhite skipnl
  122              0.001636 syn keyword cssPageProp contained content size
                            " http://www.w3.org/TR/CSS2/page.html#break-inside
  122              0.001332 syn keyword cssPageProp contained orphans widows
                            
                            " @keyframe
                            " http://www.w3.org/TR/css3-animations/#keyframes
  122              0.007632 syn match cssKeyFrame "@\(-[a-z]\+-\)\=keyframes\>[^{]*{\@=" nextgroup=cssKeyFrameWrap contains=cssVendor,cssIncludeKeyword skipwhite skipnl transparent
  122              0.004749 syn region cssKeyFrameWrap contained transparent matchgroup=cssBraces start="{" end="}" contains=cssKeyFrameSelector
  122              0.003509 syn match cssKeyFrameSelector /\(\d*%\|from\|to\)\=/  contained skipwhite skipnl nextgroup=cssDefinition
                            
                            " @import
  122              0.025319 syn region cssInclude start=/@import\>/    end=/\ze;/ transparent contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssIncludeKeyword,cssURL,cssMediaProp,cssValueLength,cssMediaKeyword,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType
  122              0.011321 syn region cssInclude start=/@charset\>/   end=/\ze;/ transparent contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssIncludeKeyword
  122              0.010502 syn region cssInclude start=/@namespace\>/ end=/\ze;/ transparent contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssIncludeKeyword
                            
                            " @font-face
                            " http://www.w3.org/TR/css3-fonts/#at-font-face-rule
  122              0.003382 syn match cssFontDescriptor "@font-face\>" nextgroup=cssFontDescriptorBlock skipwhite skipnl
  122              0.140994 syn region cssFontDescriptorBlock contained transparent matchgroup=cssBraces start="{" end="}" contains=cssComment,cssError,cssUnicodeEscape,cssCommonAttr,cssFontDescriptorProp,cssValue.*,cssFontDescriptorFunction,cssFontDescriptorAttr,cssNoise
                            
  122              0.001703 syn match cssFontDescriptorProp contained "\<font-family\>"
  122              0.001275 syn keyword cssFontDescriptorProp contained src
  122              0.001704 syn match cssFontDescriptorProp contained "\<font-\(style\|weight\|stretch\)\>"
  122              0.001473 syn match cssFontDescriptorProp contained "\<unicode-range\>"
  122              0.001568 syn match cssFontDescriptorProp contained "\<font-\(variant\|feature-settings\)\>"
                            
                            " src functions
  122              0.006260 syn region cssFontDescriptorFunction contained matchgroup=cssFunctionName start="\<\(uri\|url\|local\|format\)\s*(" end=")" contains=cssStringQ,cssStringQQ oneline keepend
                            " font-sytle and font-weight attributes
  122              0.001359 syn keyword cssFontDescriptorAttr contained normal italic oblique bold
                            " font-stretch attributes
  122              0.002167 syn match cssFontDescriptorAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " unicode-range attributes
  122              0.001754 syn match cssFontDescriptorAttr contained "U+[0-9A-Fa-f?]\+"
  122              0.001433 syn match cssFontDescriptorAttr contained "U+\x\+-\x\+"
                            " font-feature-settings attributes
  122              0.001182 syn keyword cssFontDescriptorAttr contained on off
                            
                            
                            
                            " The 16 basic color names
  122              0.001928 syn keyword cssColor contained aqua black blue fuchsia gray green lime maroon navy olive purple red silver teal yellow
                            
                            " 130 more color names
  122              0.001358 syn keyword cssColor contained aliceblue antiquewhite aquamarine azure
  122              0.004562 syn keyword cssColor contained beige bisque blanchedalmond blueviolet brown burlywood
  122              0.002752 syn keyword cssColor contained cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan
  122              0.002118 syn match cssColor contained /\<dark\(blue\|cyan\|goldenrod\|gray\|green\|grey\|khaki\)\>/
  122              0.002573 syn match cssColor contained /\<dark\(magenta\|olivegreen\|orange\|orchid\|red\|salmon\|seagreen\)\>/
  122              0.001895 syn match cssColor contained /\<darkslate\(blue\|gray\|grey\)\>/
  122              0.001949 syn match cssColor contained /\<dark\(turquoise\|violet\)\>/
  122              0.002420 syn keyword cssColor contained deeppink deepskyblue dimgray dimgrey dodgerblue firebrick
  122              0.001952 syn keyword cssColor contained floralwhite forestgreen gainsboro ghostwhite gold
  122              0.001787 syn keyword cssColor contained goldenrod greenyellow grey honeydew hotpink
  122              0.001970 syn keyword cssColor contained indianred indigo ivory khaki lavender lavenderblush lawngreen
  122              0.001522 syn keyword cssColor contained lemonchiffon limegreen linen magenta
  122              0.001910 syn match cssColor contained /\<light\(blue\|coral\|cyan\|goldenrodyellow\|gray\|green\)\>/
  122              0.001802 syn match cssColor contained /\<light\(grey\|pink\|salmon\|seagreen\|skyblue\|yellow\)\>/
  122              0.001739 syn match cssColor contained /\<light\(slategray\|slategrey\|steelblue\)\>/
  122              0.001674 syn match cssColor contained /\<medium\(aquamarine\|blue\|orchid\|purple\|seagreen\)\>/
  122              0.001928 syn match cssColor contained /\<medium\(slateblue\|springgreen\|turquoise\|violetred\)\>/
  122              0.001440 syn keyword cssColor contained midnightblue mintcream mistyrose moccasin navajowhite
  122              0.001362 syn keyword cssColor contained oldlace olivedrab orange orangered orchid
  122              0.001663 syn match cssColor contained /\<pale\(goldenrod\|green\|turquoise\|violetred\)\>/
  122              0.001379 syn keyword cssColor contained papayawhip peachpuff peru pink plum powderblue
  122              0.001392 syn keyword cssColor contained rosybrown royalblue saddlebrown salmon sandybrown
  122              0.001352 syn keyword cssColor contained seagreen seashell sienna skyblue slateblue
  122              0.001468 syn keyword cssColor contained slategray slategrey snow springgreen steelblue tan
  122              0.001333 syn keyword cssColor contained thistle tomato turquoise violet wheat
  122              0.001137 syn keyword cssColor contained whitesmoke yellowgreen
                            
                            " FIXME: These are actually case-insensitive too, but (a) specs recommend using
                            " mixed-case (b) it's hard to highlight the word `Background' correctly in
                            " all situations
  122              0.000299 syn case match
  122              0.002282 syn keyword cssColor contained ActiveBorder ActiveCaption AppWorkspace ButtonFace ButtonHighlight ButtonShadow ButtonText CaptionText GrayText Highlight HighlightText InactiveBorder InactiveCaption InactiveCaptionText InfoBackground InfoText Menu MenuText Scrollbar ThreeDDarkShadow ThreeDFace ThreeDHighlight ThreeDLightShadow ThreeDShadow Window WindowFrame WindowText Background
  122              0.000233 syn case ignore
                            
  122              0.001495 syn match cssImportant contained "!\s*important\>"
                            
  122              0.001971 syn match cssColor contained "\<transparent\>"
  122              0.001480 syn match cssColor contained "\<currentColor\>"
  122              0.001254 syn match cssColor contained "\<white\>"
  122              0.003537 syn match cssColor contained "#[0-9A-Fa-f]\{3\}\>" contains=cssUnitDecorators
  122              0.003136 syn match cssColor contained "#[0-9A-Fa-f]\{6\}\>" contains=cssUnitDecorators
                            
  122              0.005914 syn region cssURL contained matchgroup=cssFunctionName start="\<url\s*(" end=")" contains=cssStringQ,cssStringQQ oneline
  122              0.009771 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\|steps\)\s*(" end=")" oneline  contains=cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma
  122              0.013322 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\|color-stop\|from\|to\)\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma,cssFunction
  122              0.015035 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear-\|radial-\)\=\gradient\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunction,cssGradientAttr,cssFunctionComma
  122              0.012140 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y\|Z\)\=\|translate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|perspective\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
  122              0.001745 syn keyword cssGradientAttr contained top bottom left right cover center middle ellipse at
  122              0.001210 syn match cssFunctionComma contained ","
                            
                            " Common Prop and Attr
  122              0.001767 syn keyword cssCommonAttr contained auto none inherit all default normal
  122              0.001536 syn keyword cssCommonAttr contained top bottom center stretch hidden visible
                            "------------------------------------------------
                            " CSS Animations
                            " http://www.w3.org/TR/css3-animations/
  122              0.002535 syn match cssAnimationProp contained "\<animation\(-\(delay\|direction\|duration\|fill-mode\|name\|play-state\|timing-function\|iteration-count\)\)\=\>"
                            
                            " animation-direction attributes
  122              0.001385 syn keyword cssAnimationAttr contained alternate reverse
  122              0.001583 syn match cssAnimationAttr contained "\<alternate-reverse\>"
                            
                            " animation-fill-mode attributes
  122              0.001433 syn keyword cssAnimationAttr contained forwards backwards both
                            
                            " animation-play-state attributes
  122              0.001221 syn keyword cssAnimationAttr contained running paused
                            
                            " animation-iteration-count attributes
  122              0.001264 syn keyword cssAnimationAttr contained infinite
                            "------------------------------------------------
                            "  CSS Backgrounds and Borders Module Level 3
                            "  http://www.w3.org/TR/css3-background/
  122              0.002541 syn match cssBackgroundProp contained "\<background\(-\(attachment\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\=\>"
                            " background-attachment attributes
  122              0.001510 syn keyword cssBackgroundAttr contained scroll fixed local
                            
                            " background-position attributes
  122              0.001408 syn keyword cssBackgroundAttr contained left center right top bottom
                            
                            " background-repeat attributes
  122              0.001570 syn match cssBackgroundAttr contained "\<no-repeat\>"
  122              0.001572 syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
  122              0.001250 syn keyword cssBackgroundAttr contained space round
                            
                            " background-size attributes
  122              0.001255 syn keyword cssBackgroundAttr contained cover contain
                            
  122              0.002015 syn match cssBorderProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
  122              0.002007 syn match cssBorderProp contained "\<border\(-\(top\|bottom\)-\(left\|right\)\)\=-radius\>"
  122              0.001915 syn match cssBorderProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
  122              0.001485 syn match cssBorderProp contained "\<box-decoration-break\>"
  122              0.001443 syn match cssBorderProp contained "\<box-shadow\>"
                            
                            " border-image attributes
  122              0.001363 syn keyword cssBorderAttr contained stretch round space fill
                            
                            " border-style attributes
  122              0.001518 syn keyword cssBorderAttr contained dotted dashed solid double groove ridge inset outset
                            
                            " border-width attributes
  122              0.001197 syn keyword cssBorderAttr contained thin thick medium
                            
                            " box-decoration-break attributes
  122              0.001328 syn keyword cssBorderAttr contained clone slice
                            "------------------------------------------------
                            
  122              0.001611 syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
  122              0.001698 syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
  122              0.001577 syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
  122              0.001409 syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
  122              0.001288 syn keyword cssBoxAttr contained visible hidden scroll auto
  122              0.001418 syn match cssBoxAttr contained "\<no-\(display\|content\)\>"
                            
  122              0.001096 syn keyword cssColorProp contained opacity
  122              0.001298 syn match cssColorProp contained "\<color-profile\>"
  122              0.001415 syn match cssColorProp contained "\<rendering-intent\>"
                            
                            
  122              0.001656 syn match cssDimensionProp contained "\<\(min\|max\)-\(width\|height\)\>"
  122              0.001126 syn keyword cssDimensionProp contained height
  122              0.001115 syn keyword cssDimensionProp contained width
                            
                            " shadow and sizing are in other property groups
  122              0.002099 syn match cssFlexibleBoxProp contained "\<box-\(align\|direction\|flex\|ordinal-group\|orient\|pack\|shadow\|sizing\)\>"
  122              0.001312 syn keyword cssFlexibleBoxAttr contained start end baseline
  122              0.001127 syn keyword cssFlexibleBoxAttr contained reverse
  122              0.001185 syn keyword cssFlexibleBoxAttr contained single multiple
  122              0.001130 syn keyword cssFlexibleBoxAttr contained horizontal
  122              0.001567 syn match cssFlexibleBoxAttr contained "\<vertical\(-align\)\@!\>" "escape vertical-align
  122              0.001457 syn match cssFlexibleBoxAttr contained "\<\(inline\|block\)-axis\>"
                            
                            " CSS Fonts Module Level 3
                            " http://www.w3.org/TR/css-fonts-3/
  122              0.038954 syn match cssFontProp contained "\<font\(-\(family\|\|feature-settings\|kerning\|language-override\|size\(-adjust\)\=\|stretch\|style\|synthesis\|variant\(-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\)\=\|weight\)\)\=\>"
                            
                            " font attributes
  122              0.002018 syn keyword cssFontAttr contained icon menu caption
  122              0.001546 syn match cssFontAttr contained "\<small-\(caps\|caption\)\>"
  122              0.001465 syn match cssFontAttr contained "\<message-box\>"
  122              0.001357 syn match cssFontAttr contained "\<status-bar\>"
  122              0.001224 syn keyword cssFontAttr contained larger smaller
  122              0.001921 syn match cssFontAttr contained "\<\(x\{1,2\}-\)\=\(large\|small\)\>"
                            " font-family attributes
  122              0.001554 syn match cssFontAttr contained "\<\(sans-\)\=serif\>"
  122              0.002992 syn keyword cssFontAttr contained Antiqua Arial Black Book Charcoal Comic Courier Dingbats Gadget Geneva Georgia Grande Helvetica Impact Linotype Lucida MS Monaco Neue New Palatino Roboto Roman Symbol Tahoma Times Trebuchet Verdana Webdings Wingdings York Zapf
  122              0.001386 syn keyword cssFontAttr contained cursive fantasy monospace
                            " font-feature-settings attributes
  122              0.001207 syn keyword cssFontAttr contained on off
                            " font-stretch attributes
  122              0.001854 syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " font-style attributes
  122              0.001195 syn keyword cssFontAttr contained italic oblique
                            " font-synthesis attributes
  122              0.001114 syn keyword cssFontAttr contained weight style
                            " font-weight attributes
  122              0.001139 syn keyword cssFontAttr contained bold bolder lighter
                            " TODO: font-variant-* attributes
                            "------------------------------------------------
                            
                            " Webkit specific property/attributes
  122              0.001410 syn match cssFontProp contained "\<font-smooth\>"
  122              0.001509 syn match cssFontAttr contained "\<\(subpixel-\)\=\antialiased\>"
                            
                            
                            " CSS Multi-column Layout Module
                            " http://www.w3.org/TR/css3-multicol/
  122              0.001713 syn match cssMultiColumnProp contained "\<break-\(after\|before\|inside\)\>"
  122              0.001984 syn match cssMultiColumnProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
  122              0.001159 syn keyword cssMultiColumnProp contained columns
  122              0.001192 syn keyword cssMultiColumnAttr contained balance medium
  122              0.001320 syn keyword cssMultiColumnAttr contained always avoid left right page column
  122              0.001405 syn match cssMultiColumnAttr contained "\<avoid-\(page\|column\)\>"
                            
                            " http://www.w3.org/TR/css3-break/#page-break
  122              0.001736 syn match cssMultiColumnProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
                            
                            " TODO find following items in w3c docs.
  122              0.001160 syn keyword cssGeneratedContentProp contained quotes crop
  122              0.001496 syn match cssGeneratedContentProp contained "\<counter-\(reset\|increment\)\>"
  122              0.001406 syn match cssGeneratedContentProp contained "\<move-to\>"
  122              0.001329 syn match cssGeneratedContentProp contained "\<page-policy\>"
  122              0.001532 syn match cssGeneratedContentAttr contained "\<\(no-\)\=\(open\|close\)-quote\>"
                            
  122              0.001411 syn match cssGridProp contained "\<grid-\(columns\|rows\)\>"
                            
  122              0.001615 syn match cssHyerlinkProp contained "\<target\(-\(name\|new\|position\)\)\=\>"
                            
  122              0.001634 syn match cssListProp contained "\<list-style\(-\(type\|position\|image\)\)\=\>"
  122              0.002013 syn match cssListAttr contained "\<\(lower\|upper\)-\(roman\|alpha\|greek\|latin\)\>"
  122              0.001632 syn match cssListAttr contained "\<\(hiragana\|katakana\)\(-iroha\)\=\>"
  122              0.001867 syn match cssListAttr contained "\<\(decimal\(-leading-zero\)\=\|cjk-ideographic\)\>"
  122              0.001451 syn keyword cssListAttr contained disc circle square hebrew armenian georgian
  122              0.001128 syn keyword cssListAttr contained inside outside
                            
  122              0.001333 syn keyword cssPositioningProp contained bottom clear clip display float left
  122              0.001229 syn keyword cssPositioningProp contained position right top visibility
  122              0.001305 syn match cssPositioningProp contained "\<z-index\>"
  122              0.001195 syn keyword cssPositioningAttr contained block compact
  122              0.002435 syn match cssPositioningAttr contained "\<table\(-\(row-group\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
  122              0.001241 syn keyword cssPositioningAttr contained left right both
  122              0.001287 syn match cssPositioningAttr contained "\<list-item\>"
  122              0.001467 syn match cssPositioningAttr contained "\<inline\(-\(block\|box\|table\)\)\=\>"
  122              0.001253 syn keyword cssPositioningAttr contained static relative absolute fixed
                            
  122              0.001323 syn keyword cssPrintAttr contained landscape portrait crop cross always avoid
                            
  122              0.001936 syn match cssTableProp contained "\<\(caption-side\|table-layout\|border-collapse\|border-spacing\|empty-cells\)\>"
  122              0.001404 syn keyword cssTableAttr contained fixed collapse separate show hide once always
                            
                            
  122              0.001104 syn keyword cssTextProp contained color direction
  122              0.003513 syn match cssTextProp "\<\(\(word\|letter\)-spacing\|text\(-\(decoration\|transform\|align\|index\|shadow\)\)\=\|vertical-align\|unicode-bidi\|line-height\)\>"
  122              0.002082 syn match cssTextProp contained "\<text-\(justify\|outline\|warp\|align-last\|size-adjust\|rendering\|stroke\|indent\)\>"
  122              0.001592 syn match cssTextProp contained "\<word-\(break\|\wrap\)\>"
  122              0.001334 syn match cssTextProp contained "\<white-space\>"
  122              0.001418 syn match cssTextProp contained "\<hanging-punctuation\>"
  122              0.001388 syn match cssTextProp contained "\<punctuation-trim\>"
  122              0.001313 syn match cssTextAttr contained "\<line-through\>"
  122              0.001457 syn match cssTextAttr contained "\<\(text-\)\=\(top\|bottom\)\>"
  122              0.001251 syn keyword cssTextAttr contained ltr rtl embed nowrap
  122              0.001353 syn keyword cssTextAttr contained underline overline blink sub super middle
  122              0.001187 syn keyword cssTextAttr contained capitalize uppercase lowercase
  122              0.001246 syn keyword cssTextAttr contained justify baseline sub super
  122              0.001210 syn keyword cssTextAttr contained optimizeLegibility optimizeSpeed
  122              0.001514 syn match cssTextAttr contained "\<pre\(-\(line\|wrap\)\)\=\>"
  122              0.001454 syn match cssTextAttr contained "\<\(allow\|force\)-end\>"
  122              0.001228 syn keyword cssTextAttr contained start end adjacent
  122              0.001633 syn match cssTextAttr contained "\<inter-\(word\|ideographic\|cluster\)\>"
  122              0.001257 syn keyword cssTextAttr contained distribute kashida first last
  122              0.001249 syn keyword cssTextAttr contained clip ellipsis unrestricted suppress
  122              0.001479 syn match cssTextAttr contained "\<break-all\>"
  122              0.001378 syn match cssTextAttr contained "\<break-word\>"
  122              0.001097 syn keyword cssTextAttr contained hyphenate
  122              0.001336 syn match cssTextAttr contained "\<bidi-override\>"
                            
  122              0.001687 syn match cssTransformProp contained "\<transform\(-\(origin\|style\)\)\=\>"
  122              0.001582 syn match cssTransformProp contained "\<perspective\(-origin\)\=\>"
  122              0.001535 syn match cssTransformProp contained "\<backface-visibility\>"
                            
                            " CSS Transitions
                            " http://www.w3.org/TR/css3-transitions/
  122              0.001869 syn match cssTransitionProp contained "\<transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>"
                            
                            " transition-time-function attributes
  122              0.001888 syn match cssTransitionAttr contained "\<linear\(-gradient\)\@!\>"
  122              0.001526 syn match cssTransitionAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
  122              0.001334 syn match cssTransitionAttr contained "\<step\(-start\|-end\)\=\>"
                            "------------------------------------------------
                            " CSS Basic User Interface Module Level 3 (CSS3 UI)
                            " http://www.w3.org/TR/css3-ui/
  122              0.001287 syn match cssUIProp contained "\<box-sizing\>"
  122              0.001839 syn match cssUIAttr contained "\<\(content\|padding\|border\)\(-box\)\=\>"
                            
  122              0.001130 syn keyword cssUIProp contained cursor
  122              0.001743 syn match cssUIAttr contained "\<\(\([ns]\=[ew]\=\)\|col\|row\|nesw\|nwse\)-resize\>"
  122              0.001355 syn keyword cssUIAttr contained crosshair help move pointer alias copy
  122              0.001253 syn keyword cssUIAttr contained progress wait text cell move
  122              0.001504 syn match cssUIAttr contained "\<context-menu\>"
  122              0.001256 syn match cssUIAttr contained "\<no-drop\>"
  122              0.001298 syn match cssUIAttr contained "\<not-allowed\>"
  122              0.001257 syn match cssUIAttr contained "\<all-scroll\>"
  122              0.001463 syn match cssUIAttr contained "\<\(vertical-\)\=text\>"
  122              0.001666 syn match cssUIAttr contained "\<zoom\(-in\|-out\)\=\>"
                            
  122              0.001315 syn match cssUIProp contained "\<ime-mode\>"
  122              0.001256 syn keyword cssUIAttr contained active inactive disabled
                            
  122              0.001540 syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
  122              0.001724 syn match cssUIProp contained "\<outline\(-\(width\|style\|color\|offset\)\)\=\>"
  122              0.001115 syn keyword cssUIAttr contained invert
                            
  122              0.001069 syn keyword cssUIProp contained icon resize
  122              0.001182 syn keyword cssUIAttr contained both horizontal vertical
                            
  122              0.001322 syn match cssUIProp contained "\<text-overflow\>"
  122              0.001188 syn keyword cssUIAttr contained clip ellipsis
                            
                            " Already highlighted Props: font content
                            "------------------------------------------------
                            " Webkit/iOS specific attributes
  122              0.001362 syn match cssUIAttr contained '\(preserve-3d\)'
                            " IE specific attributes
  122              0.001219 syn match cssIEUIAttr contained '\(bicubic\)'
                            
                            " Webkit/iOS specific properties
  122              0.001731 syn match cssUIProp contained '\(tap-highlight-color\|user-select\|touch-callout\)'
                            " IE specific properties
  122              0.001514 syn match cssIEUIProp contained '\(interpolation-mode\|zoom\|filter\)'
                            
                            " Webkit/Firebox specific properties/attributes
  122              0.001089 syn keyword cssUIProp contained appearance
  122              0.001304 syn keyword cssUIAttr contained window button field icon document menu
                            
                            
  122              0.002424 syn match cssAuralProp contained "\<\(pause\|cue\)\(-\(before\|after\)\)\=\>"
  122              0.002618 syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numeral\|header\)\)\=\)\>"
  122              0.001464 syn keyword cssAuralProp contained volume during azimuth elevation stress richness
  122              0.001556 syn match cssAuralAttr contained "\<\(x-\)\=\(soft\|loud\)\>"
  122              0.001156 syn keyword cssAuralAttr contained silent
  122              0.001296 syn match cssAuralAttr contained "\<spell-out\>"
  122              0.001166 syn keyword cssAuralAttr contained non mix
  122              0.001685 syn match cssAuralAttr contained "\<\(left\|right\)-side\>"
  122              0.001660 syn match cssAuralAttr contained "\<\(far\|center\)-\(left\|center\|right\)\>"
  122              0.001276 syn keyword cssAuralAttr contained leftwards rightwards behind
  122              0.001269 syn keyword cssAuralAttr contained below level above lower higher
  122              0.002467 syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\|low\|high\)\>"
  122              0.001198 syn keyword cssAuralAttr contained faster slower
  122              0.001328 syn keyword cssAuralAttr contained male female child code digits continuous
                            
                            " mobile text
  122              0.001478 syn match cssMobileTextProp contained "\<text-size-adjust\>"
                            
                            
                            
  122              0.001497 syn match cssBraces contained "[{}]"
  122              0.001377 syn match cssError contained "{@<>"
  122              0.334513 syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks,cssNoise fold
  122              0.001913 syn match cssBraceError "}"
  122              0.001289 syn match cssAttrComma ","
                            
                            " Pseudo class
                            " http://www.w3.org/TR/css3-selectors/
  122              0.009190 syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssNoise,cssPseudoClassId,cssUnicodeEscape,cssVendor,cssPseudoClassFn
  122              0.001579 syn keyword cssPseudoClassId contained link visited active hover before after left right
  122              0.001497 syn keyword cssPseudoClassId contained root empty target enable disabled checked invalid
  122              0.001653 syn match cssPseudoClassId contained "\<first-\(line\|letter\)\>"
  122              0.002201 syn match cssPseudoClassId contained "\<\(first\|last\|only\)-\(of-type\|child\)\>"
  122              0.003031 syn region cssPseudoClassFn contained matchgroup=cssFunctionName start="\<\(not\|lang\|\(nth\|nth-last\)-\(of-type\|child\)\)(" end=")"
                            " ------------------------------------
                            " Vendor specific properties
  122              0.001223 syn match cssPseudoClassId contained  "\<selection\>"
  122              0.001383 syn match cssPseudoClassId contained  "\<focus\(-inner\)\=\>"
  122              0.001478 syn match cssPseudoClassId contained  "\<\(input-\)\=placeholder\>"
                            
                            " Misc highlight groups
  122              0.002684 syntax match cssUnitDecorators /\(#\|-\|%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|ch\|rem\|vh\|vw\|vmin\|vmax\|dpi\|dppx\|dpcm\|Hz\|kHz\|s\|ms\|deg\|grad\|rad\)/ contained
  122              0.001361 syntax match cssNoise contained /\(:\|;\|\/\)/
                            
                            " Comment
  122              0.001828 syn region cssComment start="/\*" end="\*/" contains=@Spell fold
                            
  122              0.001751 syn match cssUnicodeEscape "\\\x\{1,6}\s\?"
  122              0.001333 syn match cssSpecialCharQQ +\\\\\|\\"+ contained
  122              0.001219 syn match cssSpecialCharQ +\\\\\|\\'+ contained
  122              0.005154 syn region cssStringQQ start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cssUnicodeEscape,cssSpecialCharQQ
  122              0.005090 syn region cssStringQ start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=cssUnicodeEscape,cssSpecialCharQ
                            
                            " Vendor Prefix
  122              0.001503 syn match cssVendor contained "\(-\(webkit\|moz\|o\|ms\)-\)"
                            
                            " Various CSS Hack characters
                            " In earlier versions of IE (6 and 7), one can prefix property names
                            " with a _ or * to isolate those definitions to particular versions of IE
                            " This is purely decorative and therefore we assign to the same highlight
                            " group to cssVendor, for more information:
                            " http://www.paulirish.com/2009/browser-specific-css-hacks/
  122              0.001344 syn match cssHacks contained /\(_\|*\)/
                            
                            " Attr Enhance
                            " Some keywords are both Prop and Attr, so we have to handle them
  122              0.453715 syn region cssAttrRegion start=/:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            " Hack for transition
                            " 'transition' has Props after ':'.
  122              0.684534 syn region cssAttrRegion start=/transition\s*:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            
  122              0.001139 if main_syntax == "css"
                              syn sync minlines=10
                            endif
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
  122              0.000533 if version >= 508 || !exists("did_css_syn_inits")
  122              0.000216   if version < 508
                                let did_css_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
  122              0.001231     command -nargs=+ HiLink hi def link <args>
  122              0.000130   endif
                            
  122              0.003369   HiLink cssComment Comment
  122              0.002652   HiLink cssVendor Comment
  122              0.002445   HiLink cssHacks Comment
  122              0.002564   HiLink cssTagName Statement
  122              0.002422   HiLink cssDeprecated Error
  122              0.002502   HiLink cssSelectorOp Special
  122              0.002450   HiLink cssSelectorOp2 Special
  122              0.002372   HiLink cssAttrComma Special
                            
  122              0.002142   HiLink cssAnimationProp cssProp
  122              0.002064   HiLink cssBackgroundProp cssProp
  122              0.002033   HiLink cssBorderProp cssProp
  122              0.002046   HiLink cssBoxProp cssProp
  122              0.002079   HiLink cssColorProp cssProp
  122              0.002148   HiLink cssContentForPagedMediaProp cssProp
  122              0.002418   HiLink cssDimensionProp cssProp
  122              0.002132   HiLink cssFlexibleBoxProp cssProp
  122              0.002026   HiLink cssFontProp cssProp
  122              0.002042   HiLink cssGeneratedContentProp cssProp
  122              0.001983   HiLink cssGridProp cssProp
  122              0.002007   HiLink cssHyerlinkProp cssProp
  122              0.001994   HiLink cssLineboxProp cssProp
  122              0.002018   HiLink cssListProp cssProp
  122              0.002007   HiLink cssMarqueeProp cssProp
  122              0.002080   HiLink cssMultiColumnProp cssProp
  122              0.002074   HiLink cssPagedMediaProp cssProp
  122              0.002010   HiLink cssPositioningProp cssProp
  122              0.001983   HiLink cssPrintProp cssProp
  122              0.001983   HiLink cssRubyProp cssProp
  122              0.001994   HiLink cssSpeechProp cssProp
  122              0.002058   HiLink cssTableProp cssProp
  122              0.002528   HiLink cssTextProp cssProp
  122              0.002198   HiLink cssTransformProp cssProp
  122              0.002123   HiLink cssTransitionProp cssProp
  122              0.002162   HiLink cssUIProp cssProp
  122              0.002120   HiLink cssIEUIProp cssProp
  122              0.002148   HiLink cssAuralProp cssProp
  122              0.002058   HiLink cssRenderProp cssProp
  122              0.002099   HiLink cssMobileTextProp cssProp
                            
  122              0.002245   HiLink cssAnimationAttr cssAttr
  122              0.002181   HiLink cssBackgroundAttr cssAttr
  122              0.002136   HiLink cssBorderAttr cssAttr
  122              0.002129   HiLink cssBoxAttr cssAttr
  122              0.002012   HiLink cssContentForPagedMediaAttr cssAttr
  122              0.002039   HiLink cssDimensionAttr cssAttr
  122              0.002025   HiLink cssFlexibleBoxAttr cssAttr
  122              0.002434   HiLink cssFontAttr cssAttr
  122              0.002131   HiLink cssGeneratedContentAttr cssAttr
  122              0.002126   HiLink cssGridAttr cssAttr
  122              0.002119   HiLink cssHyerlinkAttr cssAttr
  122              0.002063   HiLink cssLineboxAttr cssAttr
  122              0.002075   HiLink cssListAttr cssAttr
  122              0.002058   HiLink cssMarginAttr cssAttr
  122              0.002062   HiLink cssMarqueeAttr cssAttr
  122              0.002028   HiLink cssMultiColumnAttr cssAttr
  122              0.001989   HiLink cssPaddingAttr cssAttr
  122              0.002128   HiLink cssPagedMediaAttr cssAttr
  122              0.002044   HiLink cssPositioningAttr cssAttr
  122              0.002082   HiLink cssGradientAttr cssAttr
  122              0.002038   HiLink cssPrintAttr cssAttr
  122              0.002018   HiLink cssRubyAttr cssAttr
  122              0.002036   HiLink cssSpeechAttr cssAttr
  122              0.002035   HiLink cssTableAttr cssAttr
  122              0.002063   HiLink cssTextAttr cssAttr
  122              0.002037   HiLink cssTransformAttr cssAttr
  122              0.002060   HiLink cssTransitionAttr cssAttr
  122              0.002189   HiLink cssUIAttr cssAttr
  122              0.002036   HiLink cssIEUIAttr cssAttr
  122              0.002045   HiLink cssAuralAttr cssAttr
  122              0.002060   HiLink cssRenderAttr cssAttr
  122              0.002039   HiLink cssCommonAttr cssAttr
                            
  122              0.002368   HiLink cssPseudoClassId PreProc
  122              0.002395   HiLink cssPseudoClassLang Constant
  122              0.002469   HiLink cssValueLength Number
  122              0.002469   HiLink cssValueInteger Number
  122              0.002482   HiLink cssValueNumber Number
  122              0.002593   HiLink cssValueAngle Number
  122              0.002782   HiLink cssValueTime Number
  122              0.002541   HiLink cssValueFrequency Number
  122              0.002474   HiLink cssFunction Constant
  122              0.002519   HiLink cssURL String
  122              0.002458   HiLink cssFunctionName Function
  122              0.002459   HiLink cssFunctionComma Function
  122              0.002533   HiLink cssColor Constant
  122              0.002614   HiLink cssIdentifier Function
  122              0.002498   HiLink cssInclude Include
  122              0.002182   HiLink cssIncludeKeyword atKeyword
  122              0.002424   HiLink cssImportant Special
  122              0.002492   HiLink cssBraces Function
  122              0.002445   HiLink cssBraceError Error
  122              0.002476   HiLink cssError Error
  122              0.002567   HiLink cssUnicodeEscape Special
  122              0.002557   HiLink cssStringQQ String
  122              0.002511   HiLink cssStringQ String
  122              0.002550   HiLink cssAttributeSelector String
  122              0.002126   HiLink cssMedia atKeyword
  122              0.002443   HiLink cssMediaType Special
  122              0.002567   HiLink cssMediaComma Normal
  122              0.002500   HiLink cssMediaKeyword Statement
  122              0.002164   HiLink cssMediaProp cssProp
  122              0.002190   HiLink cssMediaAttr cssAttr
  122              0.002209   HiLink cssPage atKeyword
  122              0.002657   HiLink cssPagePseudo PreProc
  122              0.002176   HiLink cssPageMargin atKeyword
  122              0.002105   HiLink cssPageProp cssProp
  122              0.002168   HiLink cssKeyFrame atKeyword
  122              0.002460   HiLink cssKeyFrameSelector Constant
  122              0.002592   HiLink cssFontDescriptor Special
  122              0.002537   HiLink cssFontDescriptorFunction Constant
  122              0.002439   HiLink cssFontDescriptorProp cssProp
  122              0.002164   HiLink cssFontDescriptorAttr cssAttr
  122              0.002316   HiLink cssUnicodeRange Constant
  122              0.002412   HiLink cssClassName Function
  122              0.002579   HiLink cssClassNameDot Function
  122              0.002430   HiLink cssProp StorageClass
  122              0.002474   HiLink cssAttr Constant
  122              0.002489   HiLink cssUnitDecorators Number
  122              0.002119   HiLink cssNoise Noise
  122              0.002374   HiLink atKeyword PreProc
  122              0.000345   delcommand HiLink
  122              0.000126 endif
                            
  122              0.000641 let b:current_syntax = "css"
                            
  122              0.000402 if main_syntax == 'css'
                              unlet main_syntax
                            endif
                            
  122              0.001570 let &cpo = s:cpo_save
  122              0.000317 unlet s:cpo_save
                            " vim: ts=8
                            

SCRIPT  /Users/Jack/.vim/plugged/vim-css-color/after/syntax/css.vim
Sourced 122 times
Total time: 411.858008
 Self time:   0.709605

count  total (s)   self (s)
                            " Language:     Colored CSS Color Preview
                            " Author:       Max Vasiliev <vim@skammer.name>
                            " Last Change:  2010 Jul 3
                            " Licence:      No Warranties. WTFPL. But please tell me!
                            " Version:      0.7.1
                            
  122              0.002869 function! s:StrLen(str)
                              return strlen(substitute(a:str, '.', 'x', 'g'))
                            endfunction
                            
  122              0.000756 function! s:FGforBG(bg)
                              " takes a 6hex color code and returns a matching color that is visible
                              let pure = substitute(a:bg,'^#','','')
                              let r = eval('0x'.pure[0].pure[1])
                              let g = eval('0x'.pure[2].pure[3])
                              let b = eval('0x'.pure[4].pure[5])
                              if r*30 + g*59 + b*11 > 12000
                                return '#000000'
                              else
                                return '#ffffff'
                              end
                            endfunction
                            
  122              0.000727 function! s:SetMatcher(clr,pat)
                              let group = 'cssColor'.substitute(a:clr,'^#','','')
                              redir => s:currentmatch
                              silent! exe 'syn list '.group
                              redir END
                              if s:currentmatch !~ a:pat.'\/'
                                exe 'syn match '.group.' /'.a:pat.'/ contained'
                                exe 'syn cluster cssColors add='.group
                                if has('gui_running')
                                  exe 'hi '.group.' guifg='.s:FGforBG(a:clr)
                                  exe 'hi '.group.' guibg='.a:clr
                                elseif &t_Co == 256
                                  exe 'hi '.group.' ctermfg='.s:Rgb2xterm(s:FGforBG(a:clr))
                                  exe 'hi '.group.' ctermbg='.s:Rgb2xterm(a:clr)
                                endif
                                return 1
                              else
                                return 0
                              endif
                            endfunction
                            
                            "" the 6 value iterations in the xterm color cube
  122              0.001563 let s:valuerange = [ 0x00, 0x5F, 0x87, 0xAF, 0xD7, 0xFF ]
                            "
                            "" 16 basic colors
  122              0.004074 let s:basic16 = [ [ 0x00, 0x00, 0x00 ], [ 0xCD, 0x00, 0x00 ], [ 0x00, 0xCD, 0x00 ], [ 0xCD, 0xCD, 0x00 ], [ 0x00, 0x00, 0xEE ], [ 0xCD, 0x00, 0xCD ], [ 0x00, 0xCD, 0xCD ], [ 0xE5, 0xE5, 0xE5 ], [ 0x7F, 0x7F, 0x7F ], [ 0xFF, 0x00, 0x00 ], [ 0x00, 0xFF, 0x00 ], [ 0xFF, 0xFF, 0x00 ], [ 0x5C, 0x5C, 0xFF ], [ 0xFF, 0x00, 0xFF ], [ 0x00, 0xFF, 0xFF ], [ 0xFF, 0xFF, 0xFF ] ]
                            :
  122              0.000549 function! s:Xterm2rgb(color)
                              " 16 basic colors
                              let r=0
                              let g=0
                              let b=0
                              if a:color<16
                                let r = s:basic16[a:color][0]
                                let g = s:basic16[a:color][1]
                                let b = s:basic16[a:color][2]
                              endif
                            
                              " color cube color
                              if a:color>=16 && a:color<=232
                                let color=a:color-16
                                let r = s:valuerange[(color/36)%6]
                                let g = s:valuerange[(color/6)%6]
                                let b = s:valuerange[color%6]
                              endif
                            
                              " gray tone
                              if a:color>=233 && a:color<=253
                                let r=8+(a:color-232)*0x0a
                                let g=r
                                let b=r
                              endif
                              let rgb=[r,g,b]
                              return rgb
                            endfunction
                            
  122              0.000540 function! s:pow(x, n)
                              let x = a:x
                              for i in range(a:n-1)
                                let x = x*a:x
                              return x
                            endfunction
                            
  122              0.018644 let s:colortable=[]
31232              0.034580 for c in range(0, 254)
31110   1.255531   0.125511   let color = s:Xterm2rgb(c)
31110              0.080179   call add(s:colortable, color)
31110              0.031974 endfor
                            
                            " selects the nearest xterm color for a rgb value like #FF0000
  122              0.000438 function! s:Rgb2xterm(color)
                              let best_match=0
                              let smallest_distance = 10000000000
                              let r = eval('0x'.a:color[1].a:color[2])
                              let g = eval('0x'.a:color[3].a:color[4])
                              let b = eval('0x'.a:color[5].a:color[6])
                              for c in range(0,254)
                                let d = s:pow(s:colortable[c][0]-r,2) + s:pow(s:colortable[c][1]-g,2) + s:pow(s:colortable[c][2]-b,2)
                                if d<smallest_distance
                                  let smallest_distance = d
                                  let best_match = c
                                endif
                              endfor
                              return best_match
                            endfunction
                            
  122              0.000443 function! s:SetNamedColor(clr,name)
                              let group = 'cssColor'.substitute(a:clr,'^#','','')
                              exe 'syn keyword '.group.' '.a:name.' contained'
                              exe 'syn cluster cssColors add='.group
                              if has('gui_running')
                                exe 'hi '.group.' guifg='.s:FGforBG(a:clr)
                                exe 'hi '.group.' guibg='.a:clr
                              elseif &t_Co == 256
                                exe 'hi '.group.' ctermfg='.s:Rgb2xterm(s:FGforBG(a:clr))
                                exe 'hi '.group.' ctermbg='.s:Rgb2xterm(a:clr)
                              endif
                              return 23
                            endfunction
                            
                            " shamelessly stolen from ConvertBase.vim
                            " http://www.vim.org/scripts/script.php?script_id=54
  122              0.000355 function! s:ConvertToBase(int, base)
                              if (a:base < 2 || a:base > 36)
                                echohl ErrorMsg
                                echo "Bad base - must be between 2 and 36."
                                echohl None
                                return ''
                              endif
                            
                              if (a:int == 0)
                                return 0
                              endif
                            
                              let out=''
                            
                              let isnegative = 0
                              let int=a:int
                              if (int < 0)
                                let isnegative = 1
                                let int = - int
                              endif
                            
                              while (int != 0)
                                let out = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[(int % a:base)] . out
                                let int = int / a:base
                              endwhile
                            
                              if isnegative
                                let out = '-' . out
                              endif
                            
                              return out
                            endfunction
                            
                            " Convert 80% -> 204, 100% -> 255, etc.
                            " This piece of code was ported from lisp.
                            " http://julien.danjou.info/rainbow-mode.html
  122              0.000728 fun! s:RGBRelativeToAbsolute(value)
                              let string_length = s:StrLen(a:value)-1
                              if strpart(a:value, string_length, 1) == '%'
                                let hex_value = s:ConvertToBase(  255*strpart(a:value, 0, string_length)/100, 16 )
                                if len(hex_value) == 1
                                  return "0".hex_value
                                endif
                                return hex_value
                              else
                                let hex_value = s:ConvertToBase( a:value, 16 )
                                if len( hex_value ) == 1
                                  return "0".hex_value
                                else
                                  return hex_value
                                endif
                              endif
                            endf
                            
  122              0.001063 function! s:PreviewCSSColorInLine(where)
                              " TODO use cssColor matchdata
                              let n = 1
                              let foundcolor = matchstr( getline(a:where), '#[0-9A-Fa-f]\{3,6\}\>' )
                              while foundcolor != ''
                                if foundcolor =~ '#\x\{6}$'
                                  let color = foundcolor
                                elseif foundcolor =~ '#\x\{3}$'
                                  let color = substitute(foundcolor, '\(\x\)\(\x\)\(\x\)', '\1\1\2\2\3\3', '')
                                else
                                  let color = ''
                                endif
                            
                                if color != ''
                                  call s:SetMatcher(color,foundcolor)
                                endif
                            
                                let n+=1
                                let foundcolor = matchstr( getline(a:where), '#[0-9A-Fa-f]\{3,6}', 0, n )
                              endwhile
                            
                            
                              let n = 1
                              let foundcolorlist = matchlist( getline(a:where), 'rgb[a]\=(\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\).\{-})', 0, n )
                              while len(foundcolorlist) != 0
                                  let foundcolorlist[1] = s:RGBRelativeToAbsolute( foundcolorlist[1] )
                                  let foundcolorlist[2] = s:RGBRelativeToAbsolute( foundcolorlist[2] )
                                  let foundcolorlist[3] = s:RGBRelativeToAbsolute( foundcolorlist[3] )
                            
                                  let color = "#".join( foundcolorlist[1:3], "" )
                            
                                  call s:SetMatcher( color, foundcolorlist[0] )
                            
                                  let n+=1
                                  let foundcolorlist = matchlist( getline(a:where), 'rgb[a]\=(\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\).\{-})', 0, n )
                              endw
                              return 0
                            endfunction
                            
  122              0.001169 if has("gui_running") || &t_Co==256
                              " HACK modify cssDefinition to add @cssColors to its contains
  122              0.000784   redir => s:olddef
  122              0.017558   silent!  syn list cssDefinition
  122              0.000764   redir END
  122              0.000494   if s:olddef != ''
  122              0.000972     let s:b = strridx(s:olddef,'matchgroup')
  122              0.000257     if s:b != -1
  122              0.104046       exe 'syn region cssDefinition '.strpart(s:olddef,s:b).',@cssColors'
  122              0.000350     endif
  122              0.000108   endif
                            
                              " w3c Colors
  122   2.646774   0.002591   let i = s:SetNamedColor('#800000', 'maroon')
  122   2.744762   0.001087   let i = s:SetNamedColor('#ff0000', 'red')
  122   2.801637   0.001028   let i = s:SetNamedColor('#ffA500', 'orange')
  122   2.705119   0.001014   let i = s:SetNamedColor('#ffff00', 'yellow')
  122   2.691312   0.001176   let i = s:SetNamedColor('#808000', 'olive')
  122   2.713004   0.001026   let i = s:SetNamedColor('#800080', 'purple')
  122   2.736703   0.001027   let i = s:SetNamedColor('#ff00ff', 'fuchsia')
  122   2.696911   0.001026   let i = s:SetNamedColor('#ffffff', 'white')
  122   2.737987   0.001119   let i = s:SetNamedColor('#00ff00', 'lime')
  122   2.789728   0.001083   let i = s:SetNamedColor('#008000', 'green')
  122   2.810821   0.001100   let i = s:SetNamedColor('#000080', 'navy')
  122   2.763612   0.001080   let i = s:SetNamedColor('#0000ff', 'blue')
  122   2.777374   0.001071   let i = s:SetNamedColor('#00ffff', 'aqua')
  122   2.829622   0.001054   let i = s:SetNamedColor('#008080', 'teal')
  122   2.711353   0.001022   let i = s:SetNamedColor('#000000', 'black')
  122   2.776870   0.001023   let i = s:SetNamedColor('#c0c0c0', 'silver')
  122   2.669669   0.001052   let i = s:SetNamedColor('#808080', 'gray')
                            
                              " extra colors
  122   2.751568   0.000914   let i = s:SetNamedColor('#F0F8FF','AliceBlue')
  122   2.799196   0.001101   let i = s:SetNamedColor('#FAEBD7','AntiqueWhite')
  122   2.750652   0.001100   let i = s:SetNamedColor('#7FFFD4','Aquamarine')
  122   2.737093   0.001072   let i = s:SetNamedColor('#F0FFFF','Azure')
  122   2.725839   0.001179   let i = s:SetNamedColor('#F5F5DC','Beige')
  122   2.730261   0.001097   let i = s:SetNamedColor('#FFE4C4','Bisque')
  122   2.755455   0.001048   let i = s:SetNamedColor('#FFEBCD','BlanchedAlmond')
  122   2.780420   0.001081   let i = s:SetNamedColor('#8A2BE2','BlueViolet')
  122   2.779420   0.001075   let i = s:SetNamedColor('#A52A2A','Brown')
  122   2.701190   0.001145   let i = s:SetNamedColor('#DEB887','BurlyWood')
  122   2.810195   0.001103   let i = s:SetNamedColor('#5F9EA0','CadetBlue')
  122   2.759975   0.001119   let i = s:SetNamedColor('#7FFF00','Chartreuse')
  122   2.693294   0.001095   let i = s:SetNamedColor('#D2691E','Chocolate')
  122   2.763927   0.001058   let i = s:SetNamedColor('#FF7F50','Coral')
  122   2.823541   0.001109   let i = s:SetNamedColor('#6495ED','CornflowerBlue')
  122   2.753392   0.001024   let i = s:SetNamedColor('#FFF8DC','Cornsilk')
  122   2.773303   0.001062   let i = s:SetNamedColor('#DC143C','Crimson')
  122   2.756964   0.001073   let i = s:SetNamedColor('#00FFFF','Cyan')
  122   2.794305   0.001049   let i = s:SetNamedColor('#00008B','DarkBlue')
  122   2.798772   0.005690   let i = s:SetNamedColor('#008B8B','DarkCyan')
  122   2.730766   0.001047   let i = s:SetNamedColor('#B8860B','DarkGoldenRod')
  122   2.748789   0.001047   let i = s:SetNamedColor('#A9A9A9','DarkGray')
  122   2.744606   0.001037   let i = s:SetNamedColor('#A9A9A9','DarkGrey')
  122   2.822536   0.001041   let i = s:SetNamedColor('#006400','DarkGreen')
  122   2.775684   0.001046   let i = s:SetNamedColor('#BDB76B','DarkKhaki')
  122   2.768972   0.001127   let i = s:SetNamedColor('#8B008B','DarkMagenta')
  122   2.794232   0.001129   let i = s:SetNamedColor('#556B2F','DarkOliveGreen')
  122   2.798596   0.001044   let i = s:SetNamedColor('#FF8C00','Darkorange')
  122   2.744924   0.001060   let i = s:SetNamedColor('#9932CC','DarkOrchid')
  122   2.813017   0.001110   let i = s:SetNamedColor('#8B0000','DarkRed')
  122   2.823753   0.001125   let i = s:SetNamedColor('#E9967A','DarkSalmon')
  122   2.818569   0.001089   let i = s:SetNamedColor('#8FBC8F','DarkSeaGreen')
  122   2.807827   0.001032   let i = s:SetNamedColor('#483D8B','DarkSlateBlue')
  122   2.828216   0.001148   let i = s:SetNamedColor('#2F4F4F','DarkSlateGray')
  122   2.827292   0.001152   let i = s:SetNamedColor('#2F4F4F','DarkSlateGrey')
  122   2.853370   0.001120   let i = s:SetNamedColor('#00CED1','DarkTurquoise')
  122   2.790136   0.001101   let i = s:SetNamedColor('#9400D3','DarkViolet')
  122   2.826608   0.001147   let i = s:SetNamedColor('#FF1493','DeepPink')
  122   2.866453   0.001183   let i = s:SetNamedColor('#00BFFF','DeepSkyBlue')
  122   2.867279   0.001096   let i = s:SetNamedColor('#696969','DimGray')
  122   2.768815   0.001076   let i = s:SetNamedColor('#696969','DimGrey')
  122   2.815197   0.001131   let i = s:SetNamedColor('#1E90FF','DodgerBlue')
  122   2.823234   0.001085   let i = s:SetNamedColor('#B22222','FireBrick')
  122   2.794232   0.001258   let i = s:SetNamedColor('#FFFAF0','FloralWhite')
  122   2.794142   0.001057   let i = s:SetNamedColor('#228B22','ForestGreen')
  122   2.794120   0.001067   let i = s:SetNamedColor('#DCDCDC','Gainsboro')
  122   2.782885   0.001027   let i = s:SetNamedColor('#F8F8FF','GhostWhite')
  122   2.815977   0.001031   let i = s:SetNamedColor('#FFD700','Gold')
  122   2.797713   0.001087   let i = s:SetNamedColor('#DAA520','GoldenRod')
  122   2.782242   0.001092   let i = s:SetNamedColor('#808080','Grey')
  122   2.830407   0.001115   let i = s:SetNamedColor('#ADFF2F','GreenYellow')
  122   2.750262   0.001071   let i = s:SetNamedColor('#F0FFF0','HoneyDew')
  122   2.806371   0.001038   let i = s:SetNamedColor('#FF69B4','HotPink')
  122   2.761888   0.001078   let i = s:SetNamedColor('#CD5C5C','IndianRed')
  122   2.761632   0.001085   let i = s:SetNamedColor('#4B0082','Indigo')
  122   2.711861   0.001125   let i = s:SetNamedColor('#FFFFF0','Ivory')
  122   2.759269   0.001061   let i = s:SetNamedColor('#F0E68C','Khaki')
  122   2.810533   0.001067   let i = s:SetNamedColor('#E6E6FA','Lavender')
  122   2.786685   0.001104   let i = s:SetNamedColor('#FFF0F5','LavenderBlush')
  122   2.819185   0.001050   let i = s:SetNamedColor('#7CFC00','LawnGreen')
  122   2.763841   0.001079   let i = s:SetNamedColor('#FFFACD','LemonChiffon')
  122   2.717590   0.001085   let i = s:SetNamedColor('#ADD8E6','LightBlue')
  122   2.775222   0.001117   let i = s:SetNamedColor('#F08080','LightCoral')
  122   2.714263   0.001120   let i = s:SetNamedColor('#E0FFFF','LightCyan')
  122   2.800105   0.001066   let i = s:SetNamedColor('#FAFAD2','LightGoldenRodYellow')
  122   2.816570   0.001163   let i = s:SetNamedColor('#D3D3D3','LightGray')
  122   2.831251   0.001119   let i = s:SetNamedColor('#D3D3D3','LightGrey')
  122   2.787061   0.001117   let i = s:SetNamedColor('#90EE90','LightGreen')
  122   2.806347   0.001063   let i = s:SetNamedColor('#FFB6C1','LightPink')
  122   2.734979   0.001160   let i = s:SetNamedColor('#FFA07A','LightSalmon')
  122   2.806438   0.001128   let i = s:SetNamedColor('#20B2AA','LightSeaGreen')
  122   2.829815   0.001218   let i = s:SetNamedColor('#87CEFA','LightSkyBlue')
  122   2.774781   0.001071   let i = s:SetNamedColor('#778899','LightSlateGray')
  122   2.773955   0.001106   let i = s:SetNamedColor('#778899','LightSlateGrey')
  122   2.786040   0.001104   let i = s:SetNamedColor('#B0C4DE','LightSteelBlue')
  122   2.771233   0.001089   let i = s:SetNamedColor('#FFFFE0','LightYellow')
  122   2.792917   0.001056   let i = s:SetNamedColor('#32CD32','LimeGreen')
  122   2.771834   0.001126   let i = s:SetNamedColor('#FAF0E6','Linen')
  122   2.756839   0.001064   let i = s:SetNamedColor('#FF00FF','Magenta')
  122   2.795254   0.001172   let i = s:SetNamedColor('#66CDAA','MediumAquaMarine')
  122   2.845759   0.001101   let i = s:SetNamedColor('#0000CD','MediumBlue')
  122   2.802336   0.001076   let i = s:SetNamedColor('#BA55D3','MediumOrchid')
  122   2.742765   0.001093   let i = s:SetNamedColor('#9370D8','MediumPurple')
  122   2.818558   0.001055   let i = s:SetNamedColor('#3CB371','MediumSeaGreen')
  122   2.777470   0.001078   let i = s:SetNamedColor('#7B68EE','MediumSlateBlue')
  122   2.858907   0.001065   let i = s:SetNamedColor('#00FA9A','MediumSpringGreen')
  122   2.802124   0.001076   let i = s:SetNamedColor('#48D1CC','MediumTurquoise')
  122   2.763077   0.001072   let i = s:SetNamedColor('#C71585','MediumVioletRed')
  122   2.811416   0.001097   let i = s:SetNamedColor('#191970','MidnightBlue')
  122   2.817428   0.001109   let i = s:SetNamedColor('#F5FFFA','MintCream')
  122   2.743269   0.001069   let i = s:SetNamedColor('#FFE4E1','MistyRose')
  122   2.740486   0.001086   let i = s:SetNamedColor('#FFE4B5','Moccasin')
  122   2.781206   0.001101   let i = s:SetNamedColor('#FFDEAD','NavajoWhite')
  122   2.808922   0.001014   let i = s:SetNamedColor('#FDF5E6','OldLace')
  122   2.806889   0.001055   let i = s:SetNamedColor('#6B8E23','OliveDrab')
  122   2.776446   0.001097   let i = s:SetNamedColor('#FF4500','OrangeRed')
  122   2.768348   0.001067   let i = s:SetNamedColor('#DA70D6','Orchid')
  122   2.845205   0.001151   let i = s:SetNamedColor('#EEE8AA','PaleGoldenRod')
  122   2.826967   0.001086   let i = s:SetNamedColor('#98FB98','PaleGreen')
  122   2.827344   0.001026   let i = s:SetNamedColor('#AFEEEE','PaleTurquoise')
  122   2.805203   0.001139   let i = s:SetNamedColor('#D87093','PaleVioletRed')
  122   2.787235   0.002635   let i = s:SetNamedColor('#FFEFD5','PapayaWhip')
  122   2.738157   0.001093   let i = s:SetNamedColor('#FFDAB9','PeachPuff')
  122   2.745179   0.001061   let i = s:SetNamedColor('#CD853F','Peru')
  122   2.804852   0.001034   let i = s:SetNamedColor('#FFC0CB','Pink')
  122   2.799593   0.001057   let i = s:SetNamedColor('#DDA0DD','Plum')
  122   2.777141   0.003537   let i = s:SetNamedColor('#B0E0E6','PowderBlue')
  122   2.799456   0.001125   let i = s:SetNamedColor('#BC8F8F','RosyBrown')
  122   2.808923   0.002471   let i = s:SetNamedColor('#4169E1','RoyalBlue')
  122   2.856266   0.001218   let i = s:SetNamedColor('#8B4513','SaddleBrown')
  122   2.777713   0.001092   let i = s:SetNamedColor('#FA8072','Salmon')
  122   2.814780   0.001125   let i = s:SetNamedColor('#F4A460','SandyBrown')
  122   2.798521   0.001058   let i = s:SetNamedColor('#2E8B57','SeaGreen')
  122   2.766101   0.001073   let i = s:SetNamedColor('#FFF5EE','SeaShell')
  122   2.796405   0.001117   let i = s:SetNamedColor('#A0522D','Sienna')
  122   2.811729   0.001160   let i = s:SetNamedColor('#87CEEB','SkyBlue')
  122   2.802622   0.001071   let i = s:SetNamedColor('#6A5ACD','SlateBlue')
  122   2.845815   0.001053   let i = s:SetNamedColor('#708090','SlateGray')
  122   2.804576   0.001070   let i = s:SetNamedColor('#708090','SlateGrey')
  122   2.819440   0.001022   let i = s:SetNamedColor('#FFFAFA','Snow')
  122   2.731055   0.001062   let i = s:SetNamedColor('#00FF7F','SpringGreen')
  122   2.806870   0.001109   let i = s:SetNamedColor('#4682B4','SteelBlue')
  122   2.794594   0.001039   let i = s:SetNamedColor('#D2B48C','Tan')
  122   2.758842   0.001045   let i = s:SetNamedColor('#D8BFD8','Thistle')
  122   2.714370   0.000992   let i = s:SetNamedColor('#FF6347','Tomato')
  122   2.789330   0.001043   let i = s:SetNamedColor('#40E0D0','Turquoise')
  122   2.768515   0.001101   let i = s:SetNamedColor('#EE82EE','Violet')
  122   2.791653   0.001102   let i = s:SetNamedColor('#F5DEB3','Wheat')
  122   2.775660   0.001128   let i = s:SetNamedColor('#F5F5F5','WhiteSmoke')
  122   2.759992   0.001085   let i = s:SetNamedColor('#9ACD32','YellowGreen')
                            
                            
                            
  122              0.000228   let i = 1
 3285              0.006738   while i <= line("$")
 3163   1.323323   0.015995     call s:PreviewCSSColorInLine(i)
 3163              0.007145     let i = i+1
 3163              0.003470   endwhile
  122              0.000317   unlet i
                            
  122              0.001108   autocmd CursorMoved * silent call s:PreviewCSSColorInLine('.')
  122              0.001220   autocmd CursorMovedI * silent call s:PreviewCSSColorInLine('.')
  122              0.000590   if !exists('g:cssColorVimDoNotMessMyUpdatetime')
  122              0.001395     set ut=100
  122              0.000173   endif
                            
  122              0.000878 endif

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/compositing-1.vim
Sourced 114 times
Total time:   0.019950
 Self time:   0.019950

count  total (s)   self (s)
                            " TODO: create cssCompositingProp and cssCompositingAttr
  114              0.008235 syn keyword cssFontProp contained isolation
  114              0.005553 syn match cssFontProp contained "\<\(mix\|background\)-blend-mode\>"
  114              0.005120 syn keyword cssFontAttr contained multiply screen overlay darken lighten color-dodge color-burn hard-light soft-light difference exclusion hue saturation color luminosity

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-align-3.vim
Sourced 114 times
Total time:   0.018771
 Self time:   0.018771

count  total (s)   self (s)
                            syn match cssFontProp contained "\<\(justify\|align\|place\)-\(self\|content\|items\)\>"
  114              0.003712 syn keyword cssFontAttr contained safe unsafe legacy
  114              0.003255 syn match cssFontAttr contained "\<\(self\|flex\)-\(start\|end\)\>"
  114              0.003622 syn match cssFontAttr contained "\<space-\(between\|around\|evenly\)\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-backgrounds-4.vim
Sourced 114 times
Total time:   0.020969
 Self time:   0.020969

count  total (s)   self (s)
                            syn keyword cssFontProp contained corners
  114              0.003466 syn match cssFontProp contained "\<background-position-\(x\|y\|inline\|block\)\>"
  114              0.002554 syn match cssFontProp contained "\<corner-shape\>"
  114              0.002368 syn match cssFontProp contained "\<border-limit\>"
  114              0.003438 syn match cssFontProp contained "\<border-clip\(-\(top\|right\|bottom\|left\)\)\=\>"
  114              0.002363 syn keyword cssFontAttr contained bevel scoop notch
  114              0.003470 syn match cssFontAttr contained "\<\(x\|y\)-\(start\|end\)\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-break-3.vim
Sourced 114 times
Total time:   0.008350
 Self time:   0.008350

count  total (s)   self (s)
                            syn match cssFontProp contained "\<break-\(after\|before\|inside\)\>"
  114              0.004148 syn match cssFontProp contained "\<box-decoration-break\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-cascade-3.vim
Sourced 114 times
Total time:   0.010978
 Self time:   0.010978

count  total (s)   self (s)
                            syn keyword cssFontProp all
  114              0.004906 syn keyword cssCommonAttr contained initial unset

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-cascade-4.vim
Sourced 114 times
Total time:   0.011204
 Self time:   0.011204

count  total (s)   self (s)
                            syn keyword cssCommonAttr contained revert
  114              0.006200 syn region cssURL contained matchgroup=cssFunctionName start="\<supports\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-color-4.vim
Sourced 114 times
Total time:   0.029034
 Self time:   0.029034

count  total (s)   self (s)
                            syn match cssColorProp contained "\<color-adjust\>"
  114              0.003764 syn keyword cssColor contained rebeccapurple
  114              0.006395 syn match cssColor contained "#[0-9A-Fa-f]\{8\}\>" contains=cssUnitDecorators
  114              0.005779 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(hwb\|lab\|lch\|gray\|color\|device-cmyk\|color-mod\=\)\s*(" end=")" oneline keepend
  114              0.006240 syn match cssFontDescriptor "@color-profile\>" nextgroup=cssFontDescriptorBlock skipwhite skipnl

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-contain-1.vim
Sourced 114 times
Total time:   0.006315
 Self time:   0.006315

count  total (s)   self (s)
                            syn keyword cssFontProp contained contain
  114              0.003192 syn keyword cssFontAttr contained layout paint size

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-content-3.vim
Sourced 114 times
Total time:   0.015808
 Self time:   0.015808

count  total (s)   self (s)
                            syn match cssGeneratedContentProp contained "\<string-set\>"
  114              0.003505 syn match cssGeneratedContentProp contained "\<bookmark-\(label\|level\|state\)\>"
  114              0.002421 syn keyword cssGeneratedContentAttr contained open closed
  114              0.005751 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(leader\|string\|target-\(counter\|counters\|text\)\)\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-counter-styles-3.vim
Sourced 114 times
Total time:   0.571148
 Self time:   0.571148

count  total (s)   self (s)
                            " TODO: create cssCounterStyleDescriptor for `@counter-style` descriptors
  114              0.541837 syn region cssInclude start=/@counter-style\>/ end=/\ze{/ skipwhite skipnl contains=css.*Prop,css.*Attr,cssValueInteger,cssValueLength,cssMediaKeyword,cssVendor,cssIncludeKeyword,cssComment nextgroup=cssMediaBlock
  114              0.002772 syn keyword cssGeneratedContentProp contained system negative prefix suffix range pad fallback
  114              0.002484 syn match cssGeneratedContentProp contained "\<\(additive-\)\=symbols\>"
  114              0.001642 syn match cssGeneratedContentProp contained "\<speak-as\>"
  114              0.003092 syn keyword cssGeneratedContentAttr contained cyclic symbolic additive extends bullets numbers words bengali cambodian khmer devanagari gujarati gurmukhi kannada lao malayalam mongolian myanmar oriya persian tamil telugu thai tibetan
  114              0.001895 syn match cssGeneratedContentAttr contained "\<\(ethiopic-\)\=numeric\>"
  114              0.001764 syn match cssGeneratedContentAttr contained "\<arabic-indic\>"
  114              0.001901 syn match cssGeneratedContentAttr contained "\<\(upper\|lower\)-armenian\>"
  114              0.002410 syn match cssGeneratedContentAttr contained "\<cjk-\(decimal\|earthly-branch\|heavenly-stem\)\>"
  114              0.002595 syn match cssGeneratedContentAttr contained "\<disclosure-\(open\|closed\)\>"
  114              0.002498 syn match cssGeneratedContentAttr contained "\<\(japanese\|korean-hanja\|\(simp\|trad\)-chinese\)-\(in\)\=formal\>"
  114              0.001842 syn match cssGeneratedContentAttr contained "\<korean-hangul-formal\>"
  114              0.003851 syn region cssFunction contained matchgroup=cssFunctionName start="\<symbols\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-device-adapt-1.vim
Sourced 114 times
Total time:   0.472418
 Self time:   0.472418

count  total (s)   self (s)
                            syn match cssFontProp contained "\<\(min\|max\|user\)-zoom\>"
  114              0.468682 syn region cssInclude start=/@viewport\>/ end=/\ze{/ skipwhite skipnl contains=css.*Prop,css.*Attr,cssValueInteger,cssValueLength,cssMediaKeyword,cssVendor,cssIncludeKeyword,cssComment nextgroup=cssMediaBlock

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-display-3.vim
Sourced 114 times
Total time:   0.007688
 Self time:   0.007688

count  total (s)   self (s)
                            " TODO: create cssDisplayProp group and cssDisplayAttr group
  114              0.002920 syn keyword cssFontAttr contained contents discard
  114              0.002430 syn match cssFontAttr contained "\<flow\(-root\)\=\>"
  114              0.001934 syn match cssFontAttr contained "\<inline-list-item\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-flexbox-1.vim
Sourced 114 times
Total time:   0.010317
 Self time:   0.010317

count  total (s)   self (s)
                            syn keyword cssFontProp order
  114              0.002795 syn match cssFontProp contained "\<flex\(-\(basis\|direction\|flow\|grow\|shrink\|wrap\)\)\=\>"
  114              0.001478 syn keyword cssFontAttr contained flex row wrap
  114              0.001502 syn match cssFontAttr contained "\<inline-flex\>"
  114              0.002303 syn match cssFontAttr contained "\<\(row\|column\|wrap\)-reverse\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-font-loading-3.vim
Sourced 114 times
Total time:   0.000717
 Self time:   0.000717

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-fonts-3.vim
Sourced 114 times
Total time:   0.048089
 Self time:   0.048089

count  total (s)   self (s)
                            syn match cssFontProp contained "\<font-feature-settings\>"
  114              0.002758 syn match cssFontProp contained "\<font-kerning\>"
  114              0.002374 syn match cssFontProp contained "\<font-language-override\>"
  114              0.002145 syn match cssFontProp contained "\<font-synthesis\>"
  114              0.003489 syn match cssFontProp contained "\<font-variant-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\>"
  114              0.002748 syn keyword cssFontAttr contained unicase ordinal jis78 jis83 jis90 jis04 simplified traditional
  114              0.003012 syn match cssFontAttr contained "\<\(no-\)\=\(common\|discretionary\|historical\)-ligatures\>"
  114              0.002135 syn match cssFontAttr contained "\<\(no-\)\=contextual\>"
  114              0.002193 syn match cssFontAttr contained "\<historical-forms\>"
  114              0.002117 syn match cssFontAttr contained "\<all-small-caps\>"
  114              0.002181 syn match cssFontAttr contained "\<\(all-\)\=petite-caps\>"
  114              0.001977 syn match cssFontAttr contained "\<titling-caps\>"
  114              0.002796 syn match cssFontAttr contained "\<\(lining\|oldstyle\|proportional\|tabular\)-nums\>"
  114              0.002455 syn match cssFontAttr contained "\<\(diagonal\|stacked\)-fractions\>"
  114              0.001984 syn match cssFontAttr contained "\<slashed-zero\>"
  114              0.002091 syn match cssFontAttr contained "\<proportional-width\>"
  114              0.005619 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(stylistic\|styleset\|character-variant\|swash\|ornaments\|annotation\)\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-fonts-4.vim
Sourced 114 times
Total time:   0.010841
 Self time:   0.010841

count  total (s)   self (s)
                            syn match cssFontProp contained "\<font-optical-sizing\>"
  114              0.002890 syn match cssFontProp contained "\<font-variation-settings\>"
  114              0.002002 syn keyword cssFontAttr contained emoji math fangsong
  114              0.002278 syn match cssFontAttr contained "\<system-ui\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-gcpm-3.vim
Sourced 114 times
Total time:   0.016988
 Self time:   0.016988

count  total (s)   self (s)
                            syn keyword cssGeneratedContentProp contained running
  114              0.003429 syn match cssGeneratedContentProp contained "\<footnote-\(display\|policy\)\>"
  114              0.003327 syn keyword cssGeneratedContentAttr contained footnote line
  114              0.004322 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(element\|running\)\s*(" end=")" oneline keepend
  114              0.002627 syn match cssPseudoClassId contained "\<footnote-\(call\|marker\)\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-grid-1.vim
Sourced 114 times
Total time:   0.024921
 Self time:   0.024921

count  total (s)   self (s)
                            syn match cssFontProp contained "\<grid-template\(-\(columns\|rows\|areas\)\)\=\>"
  114              0.002670 syn match cssFontProp contained "\<grid-auto-\(columns\|rows\|flow\)\>"
  114              0.002362 syn match cssFontProp contained "\<grid-\(row\|column\)\(-\(start\|end\)\)\=\>"
  114              0.002062 syn match cssFontProp contained "\<grid-area\>"
  114              0.002098 syn match cssFontProp contained "\<grid\(-\(column\|row\)\)\=-gap\>"
  114              0.001813 syn keyword cssFontAttr contained grid dense span
  114              0.001784 syn match cssFontAttr contained "\<inline-grid\>"
  114              0.001711 syn match cssFontAttr contained "\<auto-flow\>"
  114              0.002272 syn match cssValueNumber contained "[01]\(.\d\+\)\=fr"
  114              0.004293 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(minmax\|fit-content\|repeat\)\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-images-4.vim
Sourced 114 times
Total time:   0.007856
 Self time:   0.007856

count  total (s)   self (s)
                            syn match cssFontProp contained "\<image-resolution\>"
  114              0.004899 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(image\|element\|conic-gradient\)\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-inline-3.vim
Sourced 114 times
Total time:   0.009808
 Self time:   0.009808

count  total (s)   self (s)
                            syn match cssFontProp contained "\<\(dominant\|alignment\)-baseline\>"
  114              0.002501 syn match cssFontProp contained "\<baseline-shift\>"
  114              0.002214 syn match cssFontProp contained "\<initial-letter\(-\(align\|wrap\)\)\="
  114              0.002006 syn keyword cssFontAttr contained mathematical ideographic

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-line-grid-1.vim
Sourced 114 times
Total time:   0.009890
 Self time:   0.009890

count  total (s)   self (s)
                            " TODO: create cssLineGridProp and cssLineGridAttr
  114              0.002604 syn match cssFontProp contained "\<line-\(grid\|snap\)"
  114              0.001763 syn match cssFontProp contained "\<box-snap\>"
  114              0.001456 syn keyword cssFontAttr contained create
  114              0.001608 syn match cssFontAttr contained "\<block-\(start\|end\)\>"
  114              0.002093 syn match cssFontAttr contained "\<\(first\|last\)-baseline\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-lists-3.vim
Sourced 114 times
Total time:   0.013097
 Self time:   0.013097

count  total (s)   self (s)
                            syn match cssGeneratedContentProp contained "\<marker-side\>"
  114              0.002258 syn match cssGeneratedContentProp contained "\<counter-set\>"
  114              0.001510 syn keyword cssGeneratedContentAttr contained marker
  114              0.001754 syn match cssGeneratedContentAttr contained "\<list-container\>"
  114              0.001301 syn keyword cssPseudoClassId contained marker
  114              0.003582 syn region cssFunction contained matchgroup=cssFunctionName start="\<counters\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-logical-1.vim
Sourced 114 times
Total time:   0.012598
 Self time:   0.012598

count  total (s)   self (s)
                            syn match cssFontProp contained "\<\(\(min\|max\)-\)\=\(block\|inline\)-size\>"
  114              0.002634 syn match cssFontProp contained "\<\(margin\|inset\|padding\)\(-\(block\|inline\)\(-\(start\|end\)\)\=\)\=\>"
  114              0.002721 syn match cssFontProp contained "\<border-\(block\|inline\)\(\(-\(start\|end\)\)\=\(-\(width\|style\|color\)\)\=\)\=\>"
  114              0.002110 syn match cssFontProp contained "\<\(background\|border\)-image-transform\>"
  114              0.001950 syn keyword cssFontAttr contained logical physical rotate

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-masking-1.vim
Sourced 114 times
Total time:   0.015729
 Self time:   0.015729

count  total (s)   self (s)
                            " TODO: create cssMaskingProp group and cssMaskingValue group
  114              0.002591 syn match cssFontProp contained "\<clip-\(path\|rule\)\>"
  114              0.002525 syn match cssFontProp contained "\<mask\(-\(image\|mode\|repeat\|position\|clip\|origin\|size\|composite\|type\)\)\=\>"
  114              0.002548 syn match cssFontProp contained "\<mask-border\(-\(source\|mode\|slice\|width\|outset\|repeat\)\)\=\>"
  114              0.002038 syn keyword cssFontAttr contained nonzero evenodd alpha luminance add subtract intersect exclude
  114              0.001830 syn match cssFontAttr contained "\<\(fill\|stroke\|view\)-box\>"
  114              0.001624 syn match cssFontAttr contained "\<no-clip\>"
                            
                            " http://www.w3.org/TR/css-masking/#MaskElement
  114              0.001748 syn keyword cssTagName mask

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-overflow-3.vim
Sourced 114 times
Total time:   0.004946
 Self time:   0.004946

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-overflow-4.vim
Sourced 114 times
Total time:   0.016966
 Self time:   0.016966

count  total (s)   self (s)
                            syn keyword cssFontProp contained continue
  114              0.004004 syn match cssFontProp contained "\<scrollbar-gutter\>"
  114              0.002685 syn keyword cssFontAttr contained stable force overflow paginate fragments
  114              0.005001 syn region cssPseudoClassLang matchgroup=cssPseudoClassId start=":\(nth-fragment\)(" end=")" oneline

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-page-floats-3.vim
Sourced 114 times
Total time:   0.019289
 Self time:   0.019289

count  total (s)   self (s)
                            syn match cssPositioningProp contained "\<float-\(reference\|defer\|offset\)\>"
  114              0.004125 syn match cssPositioningAttr contained "\<inline-\(start\|end\)\>"
  114              0.002765 syn match cssPositioningAttr contained "\<snap-\(block\|inline\)\>"
  114              0.005314 syn region cssURL contained matchgroup=cssFunctionName start="\<snap-\(block\|inline\)\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-paint-api-1.vim
Sourced 114 times
Total time:   0.008649
 Self time:   0.008649

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-position-3.vim
Sourced 114 times
Total time:   0.007896
 Self time:   0.007896

count  total (s)   self (s)
                            syn match cssFontProp contained "\<offset-\(before\|end\|after\|start\)\>"
  114              0.002689 syn keyword cssFontAttr contained sticky

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-properties-values-api-1.vim
Sourced 114 times
Total time:   0.000486
 Self time:   0.000486

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-pseudo-4.vim
Sourced 114 times
Total time:   0.007875
 Self time:   0.007875

count  total (s)   self (s)
                            syn match cssPseudoClassId contained "\<inactive-selection\>"
  114              0.003763 syn match cssPseudoClassId contained "\<\(spelling\|grammer\)-error\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-regions-1.vim
Sourced 114 times
Total time:   0.016735
 Self time:   0.016735

count  total (s)   self (s)
                            " TODO: create cssRegionsProp group and cssRegionsAttr group
  114              0.005803 syn match cssFontProp contained "\<flow-\(into\|from\)\>"
  114              0.002753 syn match cssFontProp contained "\<region-fragment\>"
  114              0.002396 syn keyword cssFontAttr contained element content break
  114              0.002458 syn match cssFontAttr contained "\<\(avoid-\)\=region\>"
  114              0.002495 syn keyword cssPseudoClassId contained region

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-rhythm-1.vim
Sourced 114 times
Total time:   0.014068
 Self time:   0.014068

count  total (s)   self (s)
                            syn match cssFontProp contained "\<line-height-step\>"
  114              0.004492 syn match cssFontProp contained "\<block-step\(-\(size\|insert\|align\|round\)\)\=\>"
  114              0.003150 syn keyword cssFontAttr contained margin up down nearest

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-round-display-1.vim
Sourced 114 times
Total time:   0.018710
 Self time:   0.018710

count  total (s)   self (s)
                            syn match cssFontProp contained "\<shape-inside\>"
  114              0.003155 syn match cssFontProp contained "\<border-boundary\>"
  114              0.002583 syn match cssFontProp contained "\<polar-\(angle\|distance\)\>"
  114              0.001967 syn keyword cssFontAttr contained parent polar
  114              0.002190 syn match cssFontAttr contained "\<outside-shape\>"
  114              0.002245 syn match cssFontAttr contained "\<shape-box\>"
  114              0.002683 syn match cssMediaProp contained /device-radius/

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-ruby-1.vim
Sourced 114 times
Total time:   0.008821
 Self time:   0.008821

count  total (s)   self (s)
                            " TODO: create cssRubyProp group and cssRubyAttr group
  114              0.003244 syn match cssFontProp contained "\<ruby-\(position\|merge\|align\)"
  114              0.002514 syn match cssFontAttr contained "\<ruby-\(base\|text\)-container\>"
  114              0.002602 syn match cssFontAttr contained "\<inter-character\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-scoping-1.vim
Sourced 114 times
Total time:   0.018357
 Self time:   0.018357

count  total (s)   self (s)
                            syn region cssInclude start=/@scope\>/ end=/\ze{/ skipwhite skipnl nextgroup=cssMediaBlock
  114              0.002647 syn keyword cssPseudoClassId contained host shadow content
  114              0.002315 syn match cssPseudoClassId contained "\<\(scope\|host\)-context\>"
  114              0.003455 syn region cssPseudoClassLang matchgroup=cssPseudoClassId start=":\(host\)(" end=")" oneline
  114              0.002384 syn match cssSelectorOp2 "/deep/"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-scroll-snap-1.vim
Sourced 114 times
Total time:   0.010296
 Self time:   0.010296

count  total (s)   self (s)
                            syn match cssFontProp contained "\<scroll-snap-\(type\|align\|stop\)\>"
  114              0.004546 syn match cssFontProp contained "\<scroll-\(padding\|snap-margin\)\(-\(top\|bottom\|right\|left\|\(block\|inline\)\(-\(end\|start\)\)\=\)\)\=\>"
  114              0.002266 syn keyword cssFontAttr contained x y mandatory proximity

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-shapes-1.vim
Sourced 114 times
Total time:   0.009869
 Self time:   0.009869

count  total (s)   self (s)
                            " TODO: create cssShapesProp group and cssShapesAttr group
  114              0.003308 syn match cssFontProp contained "\<shape-\(outside\|image-threshold\|margin\)\>"
  114              0.001972 syn match cssFontAttr contained "\<margin-box\>"
  114              0.004194 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(inset\|circle\|ellipse\|polygon\)\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-sizing-3.vim
Sourced 114 times
Total time:   0.007134
 Self time:   0.007134

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-style-attr.vim
Sourced 114 times
Total time:   0.000499
 Self time:   0.000499

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-syntax-3.vim
Sourced 114 times
Total time:   0.000427
 Self time:   0.000427

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-tables-3.vim
Sourced 70 times
Total time:   0.000190
 Self time:   0.000190

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-text-3.vim
Sourced 114 times
Total time:   0.020474
 Self time:   0.020474

count  total (s)   self (s)
                            syn keyword cssTextProp contained hyphens
  114              0.003735 syn match cssTextProp contained "\<line-break\>"
  114              0.002296 syn match cssTextProp contained "\<overflow-wrap\>"
  114              0.001985 syn match cssTextProp contained "\<tab-size\>"
  114              0.001972 syn keyword cssTextAttr contained manual loose strict hanging
  114              0.002073 syn match cssTextAttr contained "\<match-parent\>"
  114              0.001953 syn match cssTextAttr contained "\<each-line\>"
  114              0.002388 syn match cssTextAttr contained "\<full-width\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-text-4.vim
Sourced 114 times
Total time:   0.032016
 Self time:   0.032016

count  total (s)   self (s)
                            syn match cssTextProp contained "\<text-space-\(collapse\|trim\)\>"
  114              0.002456 syn match cssTextProp contained "\<text-\(wrap\|spacing\)\>"
  114              0.002349 syn match cssTextProp contained "\<wrap-\(before\|after\|inside\)\>"
  114              0.002625 syn match cssTextProp contained "\<hyphenate-\(character\|limit-\(zone\|chars\|lines\|last\)\)\>"
  114              0.001789 syn keyword cssTextAttr contained spread punctuation
  114              0.002624 syn match cssTextAttr contained "\<preserve-\(auto\|trim\|breaks\|spaces\)\>"
  114              0.001900 syn match cssTextAttr contained "\<trim-inner\>"
  114              0.001962 syn match cssTextAttr contained "\<discard-\(before\|after\)\>"
  114              0.001783 syn match cssTextAttr contained "\<avoid-\(line\|flex\)\>"
  114              0.001809 syn match cssTextAttr contained "\<pre-wrap-auto\>"
  114              0.001733 syn match cssTextAttr contained "\<no-limit\>"
  114              0.002696 syn match cssTextAttr contained "\<\(trim\|space\)-\(start\|end\|adjacent\)\>"
  114              0.001910 syn match cssTextAttr contained "\<no-compress\>"
  114              0.002558 syn match cssTextAttr contained "\<ideograph-\(alpha\|numeric\)\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-text-decor-3.vim
Sourced 114 times
Total time:   0.010435
 Self time:   0.010435

count  total (s)   self (s)
                            syn match cssTextProp contained "\<text-\(decoration\(-\(color\|line\|skip\|style\)\)\=\|underline-position\|emphasis\(-\(color\|position\|style\)\)\=\)\>"
  114              0.003171 syn keyword cssTextAttr contained wavy objects alphabetic spaces edges ink under filled dot triangle sesame over
  114              0.002508 syn match cssTextAttr contained "\<box-decoration\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-timing-1.vim
Sourced 114 times
Total time:   0.005256
 Self time:   0.005256

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-transforms-1.vim
Sourced 114 times
Total time:   0.016203
 Self time:   0.016203

count  total (s)   self (s)
                            " TODO: create cssTransformsProp group and cssTransformsAttr group
  114              0.003071 syn match cssFontProp contained "\<backface-visibility\>"
  114              0.002122 syn match cssFontProp contained "\<perspective\(-origin\)\=\>"
  114              0.002141 syn match cssFontProp contained "\<transform\(-\(origin\|style\)\)\=\>"
  114              0.001520 syn keyword cssFontAttr contained flat
  114              0.001820 syn match cssFontAttr contained "\<preserve-3d\>"
  114              0.005097 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|translate\(3d\|X\|Y\|Z\)\=\|scale\(3d\|X\|Y\|Z\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|perspective\)\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-typed-om-1.vim
Sourced 114 times
Total time:   0.000363
 Self time:   0.000363

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-ui-3.vim
Sourced 114 times
Total time:   0.009049
 Self time:   0.009049

count  total (s)   self (s)
                            syn match cssUIProp contained "\<caret-color\>"
  114              0.003770 syn keyword cssUIAttr contained grab grabbing

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-ui-4.vim
Sourced 114 times
Total time:   0.012138
 Self time:   0.012138

count  total (s)   self (s)
                            syn match cssUIProp contained "\<caret\(-\(shape\|animation\)\)\=\>"
  114              0.002946 syn keyword cssUIAttr contained fade underscore
  114              0.004415 syn region cssFunction contained matchgroup=cssFunctionName start="\<fade\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-values-3.vim
Sourced 114 times
Total time:   0.011943
 Self time:   0.011943

count  total (s)   self (s)
                            syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(ch\|vw\|vh\|vmin\|vmax\|q\)"
  114              0.002501 syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=turn"
  114              0.004167 syn region cssFunction contained matchgroup=cssFunctionName start="\<calc\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-variables-1.vim
Sourced 114 times
Total time:   0.008629
 Self time:   0.008629

count  total (s)   self (s)
                            " TODO: create cssVariableProp group
  114              0.004184 syn match cssFontProp contained "\<var-[A-Za-z_][A-Za-z0-9_-]\+\>"
  114              0.004025 syn region cssFunction contained matchgroup=cssFunctionName start="\<var\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-will-change-1.vim
Sourced 114 times
Total time:   0.005728
 Self time:   0.005728

count  total (s)   self (s)
                            " TODO: create cssWillChangeProp group and cssWillChangeAttr group
  114              0.002937 syn match cssFontProp contained "\<will-change\>"
  114              0.002410 syn match cssFontAttr contained "\<scroll-position\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css-writing-modes-3.vim
Sourced 114 times
Total time:   0.017721
 Self time:   0.017721

count  total (s)   self (s)
                            syn match cssFontProp contained "\<writing-mode\>"
  114              0.002758 syn match cssFontProp contained "\<text-\(orientation\|combine-upright\)\>"
  114              0.002378 syn match cssFontProp contained "\<glyph-orientation-vertical\>"
  114              0.002064 syn keyword cssFontAttr contained before after mixed upright plaintext
  114              0.001924 syn match cssFontAttr contained "\<sideways\(-rl\|-lr\)\=\>"
  114              0.001831 syn match cssFontAttr contained "\<isolate\(-override\)\=\>"
  114              0.001821 syn match cssFontAttr contained "\<horizontal-tb\>"
  114              0.002073 syn match cssFontAttr contained "\<vertical-\(rl\|lr\)\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css3-animations.vim
Sourced 114 times
Total time:   0.009177
 Self time:   0.009177

count  total (s)   self (s)
                            " TODO: create cssAnimationsProp group and cssAnimationsAttr group
  114              0.004374 syn match cssFontProp contained "\<animation\(-\(name\|duration\|timing-function\|iteration-count\|direction\|play-state\|delay\|fill-mode\)\)\=\>"
  114              0.001955 syn keyword cssFontAttr contained forwards backwards running paused
  114              0.002505 syn match cssFontAttr contained "\<alternate-reverse\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css3-background.vim
Sourced 114 times
Total time:   0.015955
 Self time:   0.015955

count  total (s)   self (s)
                            " TODO: create cssBackgroundProp group and cssBackgroundAttr group
  114              0.003194 syn match cssFontProp contained "\<background-\(clip\|origin\|size\)\>"
  114              0.002610 syn match cssFontProp contained "\<border-image\(-\(source\|slice\|width\|outset\|repeat\)\)\=\>"
  114              0.002879 syn match cssFontProp contained "\<border-\(\(top-right\|bottom-right\|bottom-left\|top-left\)-\)\=radius\>"
  114              0.001843 syn match cssFontProp contained "\<box-shadow\>"
  114              0.002008 syn keyword cssFontAttr contained space round local fill stretch clone slice
  114              0.002967 syn match cssFontAttr contained "\<\(padding\|border\|content\)-box\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css3-box.vim
Sourced 114 times
Total time:   0.011951
 Self time:   0.011951

count  total (s)   self (s)
                            syn match cssBoxProp contained "\<overflow-\(style\|x\|y\)\>"
  114              0.002447 syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
  114              0.001920 syn keyword cssBoxAttr contained scrollbar panner marquee
  114              0.002207 syn match cssBoxAttr contained "\<ruby\(-\(base\(-group\)\=\|text\(-group\)\=\)\)\=\>"
  114              0.002334 syn match cssBoxAttr contained "\<no-\(display\|content\)\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css3-color.vim
Sourced 114 times
Total time:   0.008452
 Self time:   0.008452

count  total (s)   self (s)
                            syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsla\=\)\s*(" end=")" oneline keepend
  114              0.001640 syn keyword cssColorProp contained opacity
  114              0.002109 syn match cssColor contained "\<currentcolor\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css3-conditional.vim
Sourced 114 times
Total time:   0.455211
 Self time:   0.455211

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css3-exclusions.vim
Sourced 114 times
Total time:   0.006130
 Self time:   0.006130

count  total (s)   self (s)
                            " TODO: create cssExclusionsProp group and cssExclusionsAttr group
  114              0.003710 syn match cssFontProp contained "\<wrap-\(flow\|through\)\>"
  114              0.002053 syn keyword cssFontAttr contained minimum maximum

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css3-images.vim
Sourced 114 times
Total time:   0.015908
 Self time:   0.015908

count  total (s)   self (s)
                            syn match cssFontProp contained "\<object-\(fit\|position\)\>"
  114              0.002158 syn match cssFontProp contained "\<image-orientation\>"
  114              0.001792 syn keyword cssFontAttr contained contain cover snap
  114              0.001769 syn match cssFontAttr contained "\<from-image\>"
  114              0.001775 syn match cssFontAttr contained "\<scale-down\>"
  114              0.004616 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(\(repeating-\)\=\(linear\|radial\)-gradient\)\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css3-multicol.vim
Sourced 114 times
Total time:   0.011122
 Self time:   0.011122

count  total (s)   self (s)
                            " TODO: create cssMulticolProp group and cssMulticolAttr group
  114              0.003281 syn keyword cssFontProp contained columns
  114              0.003396 syn match cssFontProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
  114              0.001588 syn keyword cssFontAttr contained balance
  114              0.002413 syn match cssFontAttr contained "\<\(avoid-\)\=column\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css3-namespace.vim
Sourced 114 times
Total time:   0.000484
 Self time:   0.000484

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css3-page.vim
Sourced 114 times
Total time:   0.007270
 Self time:   0.007270

count  total (s)   self (s)
                            " TODO: Create cssPageAttr group
  114              0.003750 syn keyword cssFontAttr contained recto verso
  114              0.003052 syn match cssFontAttr contained "\<\(avoid-\)\=page\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css3-speech.vim
Sourced 114 times
Total time:   0.016173
 Self time:   0.016173

count  total (s)   self (s)
                            syn match cssAuralProp contained "\<voice-\(volume\|balance\|rate\|pitch\|range\|stress\|duration\)\>"
  114              0.003048 syn match cssAuralProp contained "\<rest\(-\(before\|after\)\)\=\>"
  114              0.002216 syn keyword cssAuralAttr contained young old neutral preserve moderate reduced
  114              0.002171 syn match cssAuralAttr contained "\<\(literal\|no\)-punctuation\>"
  114              0.001794 syn match cssAuralAttr contained "\<\(x-\)\=\(weak\|strong\)\>"
  114              0.002593 syn match cssValueNumber contained "[-+]\=\d\+\(dB\|st\)"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/css3-transitions.vim
Sourced 114 times
Total time:   0.012739
 Self time:   0.012739

count  total (s)   self (s)
                            " TODO: create cssTransitionsProp group and cssTransitionsAttr group
  114              0.003351 syn match cssFontProp contained "\<transition\(-\(property\|duration\|timing-function\|delay\)\)\=\>"
  114              0.001563 syn keyword cssFontAttr contained linear
  114              0.001869 syn match cssFontAttr contained "\<ease\(-\(in\|out\|in-out\)\)\=\>"
  114              0.001673 syn match cssFontAttr contained "\<step-\(start\|end\)\>"
  114              0.003861 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(steps\|cubic-bezier\)\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/cssom-1.vim
Sourced 114 times
Total time:   0.000438
 Self time:   0.000438

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/cssom-view-1.vim
Sourced 114 times
Total time:   0.011071
 Self time:   0.011071

count  total (s)   self (s)
                            syn match cssFontProp contained "\<scroll-behavior\>"
  114              0.003400 syn keyword cssFontAttr contained smooth

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/fill-stroke-3.vim
Sourced 114 times
Total time:   0.018703
 Self time:   0.018703

count  total (s)   self (s)
                            syn match cssFontProp contained "\<\(fill\|stroke\)\(-\(break\|color\|image\|origin\|position\|size\|repeat\|opacity\)\)\=\>"
  114              0.002633 syn match cssFontProp contained "\<fill-rule\>"
  114              0.004296 syn match cssFontProp contained "\<stroke-\(width\|align\|line\(cap\|join\)\|miterlimit\|dash\(array\|offset\)\|dash-\(corner\|justify\)\)\>"
  114              0.002544 syn keyword cssFontAttr contained butt arcs stupid compress dashes gaps
  114              0.003038 syn match cssFontAttr contained "\<bounding-box\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/filter-effects-1.vim
Sourced 114 times
Total time:   0.019617
 Self time:   0.019617

count  total (s)   self (s)
                            syn match cssFontProp contained "\<flood-\(color\|opacity\)\>"
  114              0.003860 syn match cssFontProp contained "\<color-interpolation-filters\>"
  114              0.002409 syn match cssFontProp contained "\<lighting-color\>"
  114              0.002080 syn keyword cssFontAttr sRGB linearRGB
  114              0.006094 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(blur\|brightness\|contrast\|drop-shadow\|grayscale\|hue-rotate\|invert\|opacity\|saturate\|sepia\)\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/geometry-1.vim
Sourced 114 times
Total time:   0.000403
 Self time:   0.000403

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/html5.vim
Sourced 114 times
Total time:   0.004251
 Self time:   0.004251

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/motion-1.vim
Sourced 114 times
Total time:   0.011232
 Self time:   0.011232

count  total (s)   self (s)
                            syn match cssFontProp contained "\<motion\(-\(path\|offset\|rotation\)\)\=\>"
  114              0.006700 syn region cssFunction contained matchgroup=cssFunctionName start="\<path\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/pointerevents.vim
Sourced 114 times
Total time:   0.008103
 Self time:   0.008103

count  total (s)   self (s)
                            syn match cssFontProp contained "\<touch-action\>"
  114              0.002059 syn keyword cssFontAttr contained manipulation
  114              0.002456 syn match cssFontAttr contained "\<pan-\(x\|y\)\>"

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/selectors-nonelement-1.vim
Sourced 114 times
Total time:   0.005496
 Self time:   0.005496

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/selectors.vim
Sourced 114 times
Total time:   0.015561
 Self time:   0.015561

count  total (s)   self (s)
                            syn keyword cssPseudoClassId contained target enabled disabled checked indeterminate root empty
  114              0.003216 syn match cssPseudoClassId contained "\<last-\(child\|of-type\)\>"
  114              0.002226 syn match cssPseudoClassId contained "\<first-of-type\>"
  114              0.002186 syn match cssPseudoClassId contained "\<only-\(child\|of-type\)\>"
  114              0.004576 syn region cssPseudoClassLang matchgroup=cssPseudoClassId start=":\(nth\(-last\)\=-\(child\|of-type\)\|not\)(" end=")" oneline

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/selectors4.vim
Sourced 114 times
Total time:   0.023750
 Self time:   0.023750

count  total (s)   self (s)
                            syn match cssSelectorOp "[|]"
  114              0.003360 syn keyword cssPseudoClassId contained scope current past future default valid invalid required optional blank
  114              0.002183 syn match cssPseudoClassId contained "\<\(any\|local\)-link\>"
  114              0.001810 syn match cssPseudoClassId contained "\<read-\(only\|write\)\>"
  114              0.001954 syn match cssPseudoClassId contained "\<placeholder-shown\>"
  114              0.001946 syn match cssPseudoClassId contained "\<\(in\|out-of\)-range\>"
  114              0.001751 syn match cssPseudoClassId contained "\<user-error\>"
  114              0.002235 syn match cssPseudoClassId contained "\<\(active\|valid\|invalid\)-drop-target\>"
  114              0.005025 syn region cssPseudoClassLang matchgroup=cssPseudoClassId start=":\(matches\|dir\|local-link\|current\|nth\(-last\)\=-\(match\|column\)\|column\)(" end=")" oneline

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/svg2.vim
Sourced 114 times
Total time:   0.087369
 Self time:   0.087369

count  total (s)   self (s)
                            syn keyword cssTagName animate animateMotion animateTransform circle clipPath cursor defs desc discard ellipse feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feDropShadow feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence filter foreignObject g hatch hatchpath image line linearGradient marker mesh meshgradient meshpatch meshrow metadata mpath path pattern polygon polyline radialGradient rect set solidcolor stop switch symbol text textPath tspan unknown use view
                            
  114              0.005499 syn keyword cssFontProp contained cx cy d r rx ry x y
  114              0.002700 syn match cssFontProp contained "\<color-\(interpolation\|rendering\)\>"
  114              0.001924 syn match cssFontProp contained "\<image-rendering\>"
  114              0.001924 syn match cssFontProp contained "\<marker-\(end\|mid\|start\)\>"
  114              0.001963 syn match cssFontProp contained "\<pointer-events\>"
  114              0.002023 syn match cssFontProp contained "\<shape-rendering\>"
  114              0.002064 syn match cssFontProp contained "\<solid-\(color\|opacity\)\>"
  114              0.002062 syn match cssFontProp contained "\<stop-\(color\|opacity\)\>"
  114              0.001893 syn match cssFontProp contained "\<text-anchor\>"
  114              0.002156 syn match cssFontProp contained "\<vector-effect\>"
                            
  114              0.006872 syn keyword cssFontAttr contained crispEdges geometricPrecision optimizeQuality painted stroke viewport visibleFill visiblePainted visibleStroke
  114              0.002059 syn match cssFontAttr contained "\<context-\(fill\|stroke\)\>"
  114              0.001857 syn match cssFontAttr contained "\<fixed-position\>"
  114              0.001914 syn match cssFontAttr contained "\<miter\(-clip\)\=\>"
  114              0.002308 syn match cssFontAttr contained "\<non-\(scaling-stroke\|scaling-size\|rotation\)\>"
                            
  114              0.004144 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(child\|icc-color\)\s*(" end=")" oneline keepend

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/web-animations-1.vim
Sourced 114 times
Total time:   0.000387
 Self time:   0.000387

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/css/worklets-1.vim
Sourced 114 times
Total time:   0.000318
 Self time:   0.000318

count  total (s)   self (s)

SCRIPT  /Users/Jack/.vim/plugged/vim-haml/syntax/scss.vim
Sourced 35 times
Total time:   0.002098
 Self time:   0.002098

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	SCSS
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:	*.scss
                            " Last Change:	2010 Jul 26
                            
   35              0.001369 if exists("b:current_syntax")
   35              0.000202   finish

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/syntax/scss.vim
Sourced 35 times
Total time:   0.002170
 Self time:   0.002170

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	SCSS
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:	*.scss
                            " Last Change:	2010 Jul 26
                            
   35              0.001367 if exists("b:current_syntax")
   35              0.000280   finish

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/scss.vim
Sourced 35 times
Total time:   0.902296
 Self time:   0.300554

count  total (s)   self (s)
                            runtime! syntax/css/*.vim

SCRIPT  /Users/Jack/.vim/plugged/vim-haml/indent/scss.vim
Sourced 35 times
Total time:   3.252036
 Self time:   3.245180

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	SCSS
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:	2010 Jul 26
                            
   35              0.001221 if exists("b:did_indent")
                              finish
                            endif
                            
   35              2.323935 runtime! indent/css.vim
                            
                            " vim:set sw=2:

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/indent/css.vim
Sourced 35 times
Total time:   0.005623
 Self time:   0.005623

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	    CSS
                            " Maintainer:	    Nikolai Weibull <now@bitwi.se>
                            " Latest Revision:  2012-05-30
                            
   35              0.000974 if exists("b:did_indent")
                              finish
                            endif
   35              0.000415 let b:did_indent = 1
                            
   35              0.000840 setlocal indentexpr=GetCSSIndent()
   35              0.000347 setlocal indentkeys=0{,0},!^F,o,O
   35              0.000591 setlocal nosmartindent
                            
   35              0.000311 let b:undo_indent = "setl smartindent< indentkeys< indentexpr<"
                            
   35              0.000680 if exists("*GetCSSIndent")
   35              0.000135   finish

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/indent/scss.vim
Sourced 35 times
Total time:   0.001796
 Self time:   0.001796

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	SCSS
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:	2010 Jul 26
                            
   35              0.001159 if exists("b:did_indent")
   35              0.000186   finish

SCRIPT  /Users/Jack/.vim/plugged/scss-syntax.vim/ftplugin/scss.vim
Sourced 35 times
Total time:   0.001664
 Self time:   0.001664

count  total (s)   self (s)
                            if exists('b:did_indent') && b:did_indent
                              " be kind. allow users to override this. Does it work?
   35              0.000204   finish

SCRIPT  /Users/Jack/.vim/plugged/vim-haml/ftplugin/scss.vim
Sourced 35 times
Total time:   0.737664
 Self time:   0.729778

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	SCSS
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:	2016 Aug 29
                            
   35              0.001284 if exists("b:did_ftplugin")
                              finish
                            endif
                            
   35              0.031708 runtime! ftplugin/sass.vim
   35              0.000622 setlocal comments=s1:/*,mb:*,ex:*/,://
                            
                            " vim:set sw=2:

SCRIPT  /Users/Jack/.vim/plugged/vim-haml/ftplugin/sass.vim
Sourced 35 times
Total time:   0.004670
 Self time:   0.004670

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Sass
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:	2016 Aug 29
                            
                            " Only do this when not done yet for this buffer
   35              0.000796 if exists("b:did_ftplugin")
                              finish
                            endif
   35              0.000307 let b:did_ftplugin = 1
                            
   35              0.000236 let b:undo_ftplugin = "setl com< cms< def< inc< inex< ofu< sua<"
                            
   35              0.000514 setlocal comments=://
   35              0.000293 setlocal commentstring=//\ %s
   35              0.000287 setlocal define=^\\s*\\%(@mixin\\\|=\\)
   35              0.000344 setlocal includeexpr=substitute(v:fname,'\\%(.*/\\\|^\\)\\zs','_','')
   35              0.000291 setlocal omnifunc=csscomplete#CompleteCSS
   35              0.000231 setlocal suffixesadd=.sass,.scss,.css
                            
   35              0.000346 let &l:include = '^\s*@import\s\+\%(url(\)\=["'']\='
                            
                            " vim:set sw=2:

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/ftplugin/sass.vim
Sourced 35 times
Total time:   0.001526
 Self time:   0.001526

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Sass
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:	2010 Jul 26
                            
                            " Only do this when not done yet for this buffer
   35              0.000805 if exists("b:did_ftplugin")
   35              0.000176   finish

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/ftplugin/scss.vim
Sourced 35 times
Total time:   0.001381
 Self time:   0.001381

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	SCSS
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:	2010 Jul 26
                            
   35              0.000883 if exists("b:did_ftplugin")
   35              0.000149   finish

SCRIPT  /Users/Jack/.vim/plugged/vim-haml/syntax/haml.vim
Sourced 43 times
Total time: 319.097725
 Self time:   3.917870

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Haml
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:	*.haml
                            " Last Change:	2016 Aug 29
                            
   43              0.001520 if exists("b:current_syntax")
                              finish
                            endif
                            
   43              0.000338 if !exists("main_syntax")
   43              0.000671   let main_syntax = 'haml'
   43              0.000164 endif
   43              0.000293 let b:ruby_no_expensive = 1
                            
   43              0.155168 runtime! syntax/html.vim
   43              0.000394 unlet! b:current_syntax
   43              0.010799 silent! syn include @hamlSassTop syntax/sass.vim
   43              0.000365 unlet! b:current_syntax
   43              0.021278 syn include @hamlRubyTop syntax/ruby.vim
                            
   43              0.000194 syn case match
                            
   43              0.001039 syn region  rubyCurlyBlock   start="{" end="}" contains=@hamlRubyTop contained
   43              0.000681 syn cluster hamlRubyTop add=rubyCurlyBlock
                            
   43              0.004178 syn cluster hamlComponent    contains=hamlAttributes,hamlAttributesHash,hamlClassChar,hamlIdChar,hamlObject,hamlDespacer,hamlSelfCloser,hamlRuby,hamlPlainChar,hamlInterpolatable
   43              0.001603 syn cluster hamlEmbeddedRuby contains=hamlAttributesHash,hamlObject,hamlRuby,hamlRubyFilter
   43              0.002329 syn cluster hamlTop          contains=hamlBegin,hamlPlainFilter,hamlRubyFilter,hamlSassFilter,hamlComment,hamlHtmlComment
                            
   43              0.002701 syn match   hamlBegin "^\s*\%([<>]\|&[^=~ ]\)\@!" nextgroup=hamlTag,hamlClassChar,hamlIdChar,hamlRuby,hamlPlainChar,hamlInterpolatable
                            
   43              0.002492 syn match   hamlTag        "%\w\+\%(:\w\+\)\=" contained contains=htmlTagName,htmlSpecialTagName nextgroup=@hamlComponent
   43              0.003592 syn region  hamlAttributes     matchgroup=hamlAttributesDelimiter start="(" end=")" contained contains=htmlArg,hamlAttributeString,hamlAttributeVariable,htmlEvent,htmlCssDefinition nextgroup=@hamlComponent
   43              0.000771 syn region  hamlAttributesHash matchgroup=hamlAttributesDelimiter start="{" end="}" contained contains=@hamlRubyTop nextgroup=@hamlComponent
   43              0.000744 syn region  hamlObject         matchgroup=hamlObjectDelimiter     start="\[" end="\]" contained contains=@hamlRubyTop nextgroup=@hamlComponent
   43              0.002369 syn match   hamlDespacer "[<>]" contained nextgroup=hamlDespacer,hamlSelfCloser,hamlRuby,hamlPlainChar,hamlInterpolatable
   43              0.000429 syn match   hamlSelfCloser "/" contained
   43              0.000779 syn match   hamlClassChar "\." contained nextgroup=hamlClass
   43              0.000774 syn match   hamlIdChar "#{\@!" contained nextgroup=hamlId
   43              0.000504 syn match   hamlClass "\%(\w\|-\)\+" contained nextgroup=@hamlComponent
   43              0.000454 syn match   hamlId    "\%(\w\|-\)\+" contained nextgroup=@hamlComponent
   43              0.000467 syn region  hamlDocType start="^\s*!!!" end="$"
                            
   43              0.000882 syn region  hamlRuby   matchgroup=hamlRubyOutputChar start="[!&]\==\|\~" skip=",\s*$" end="$" contained contains=@hamlRubyTop keepend
   43              0.000744 syn region  hamlRuby   matchgroup=hamlRubyChar       start="-"           skip=",\s*$" end="$" contained contains=@hamlRubyTop keepend
   43              0.000356 syn match   hamlPlainChar "\\" contained
   43              0.001602 syn region hamlInterpolatable matchgroup=hamlInterpolatableChar start="!\===\|!=\@!" end="$" keepend contained contains=hamlInterpolation,hamlInterpolationEscape,@hamlHtmlTop
   43              0.001537 syn region hamlInterpolatable matchgroup=hamlInterpolatableChar start="&==\|&=\@!"   end="$" keepend contained contains=hamlInterpolation,hamlInterpolationEscape
   43              0.001679 syn region hamlInterpolation matchgroup=hamlInterpolationDelimiter start="#{" end="}" contains=@hamlRubyTop containedin=javascriptStringS,javascriptStringD
   43              0.000543 syn match  hamlInterpolationEscape "\\\@<!\%(\\\\\)*\\\%(\\\ze#{\|#\ze{\)"
   43              0.000699 syn region hamlErbInterpolation matchgroup=hamlInterpolationDelimiter start="<%[=-]\=" end="-\=%>" contained contains=@hamlRubyTop
                            
   43              0.001329 syn region  hamlAttributeString start=+\%(=\s*\)\@<='+ skip=+\%(\\\\\)*\\'+ end=+'+ contains=hamlInterpolation,hamlInterpolationEscape
   43              0.001385 syn region  hamlAttributeString start=+\%(=\s*\)\@<="+ skip=+\%(\\\\\)*\\"+ end=+"+ contains=hamlInterpolation,hamlInterpolationEscape
   43              0.000572 syn match   hamlAttributeVariable "\%(=\s*\)\@<=\%(@@\=\|\$\)\=\w\+" contained
                            
   43              0.000775 syn match   hamlHelper  "\<action_view?\|\<block_is_haml?\|\<is_haml?\|\.\@<!\<flatten" contained containedin=@hamlEmbeddedRuby,@hamlRubyTop
   43              0.001252 syn keyword hamlHelper   capture_haml escape_once find_and_preserve haml_concat haml_indent haml_tag html_attrs html_esape init_haml_helpers list_of non_haml precede preserve succeed surround tab_down tab_up page_class contained containedin=@hamlEmbeddedRuby,@hamlRubyTop
                            
   43              0.099315 syn cluster hamlHtmlTop contains=@htmlTop,htmlBold,htmlItalic,htmlUnderline
   43              0.002393 syn region  hamlPlainFilter      matchgroup=hamlFilter start="^\z(\s*\):\%(plain\|preserve\|redcloth\|textile\|markdown\|maruku\)\s*$" end="^\%(\z1 \| *$\)\@!" contains=@hamlHtmlTop,hamlInterpolation
   43              0.001413 syn region  hamlEscapedFilter    matchgroup=hamlFilter start="^\z(\s*\):\%(escaped\|cdata\)\s*$"    end="^\%(\z1 \| *$\)\@!" contains=hamlInterpolation
   43              0.001414 syn region  hamlErbFilter        matchgroup=hamlFilter start="^\z(\s*\):erb\s*$"        end="^\%(\z1 \| *$\)\@!" contains=@hamlHtmlTop,hamlErbInterpolation
   43              0.000975 syn region  hamlRubyFilter       matchgroup=hamlFilter start="^\z(\s*\):ruby\s*$"       end="^\%(\z1 \| *$\)\@!" contains=@hamlRubyTop
   43              0.001528 syn region  hamlJavascriptFilter matchgroup=hamlFilter start="^\z(\s*\):javascript\s*$" end="^\%(\z1 \| *$\)\@!" contains=@htmlJavaScript,hamlInterpolation keepend
   43              0.001350 syn region  hamlCSSFilter        matchgroup=hamlFilter start="^\z(\s*\):css\s*$"        end="^\%(\z1 \| *$\)\@!" contains=@htmlCss,hamlInterpolation keepend
   43              0.000959 syn region  hamlSassFilter       matchgroup=hamlFilter start="^\z(\s*\):sass\s*$"       end="^\%(\z1 \| *$\)\@!" contains=@hamlSassTop
                            
   43              0.001535 syn region  hamlJavascriptBlock start="^\z(\s*\)%script\%((type=[\"']text/javascript[\"'])\)\=\s*$" nextgroup=@hamlComponent,hamlError end="^\%(\z1 \| *$\)\@!" contains=@hamlTop,@htmlJavaScript keepend
   43              0.001148 syn region  hamlCssBlock        start="^\z(\s*\)%style" nextgroup=@hamlComponent,hamlError  end="^\%(\z1 \| *$\)\@!" contains=@hamlTop,@htmlCss keepend
   43              0.000410 syn match   hamlError "\$" contained
                            
   43              0.001105 syn region  hamlComment     start="^\z(\s*\)-#" end="^\%(\z1 \| *$\)\@!" contains=rubyTodo
   43              0.001211 syn region  hamlHtmlComment start="^\z(\s*\)/"  end="^\%(\z1 \| *$\)\@!" contains=@hamlTop,rubyTodo
   43              0.001018 syn match   hamlIEConditional "\%(^\s*/\)\@<=\[if\>[^]]*]" contained containedin=hamlHtmlComment
                            
   43              0.001086 hi def link hamlSelfCloser             Special
   43              0.000933 hi def link hamlDespacer               Special
   43              0.000853 hi def link hamlClassChar              Special
   43              0.000834 hi def link hamlIdChar                 Special
   43              0.000864 hi def link hamlTag                    Special
   43              0.000840 hi def link hamlClass                  Type
   43              0.000923 hi def link hamlId                     Identifier
   43              0.001015 hi def link hamlPlainChar              Special
   43              0.000523 hi def link hamlInterpolatableChar     hamlRubyChar
   43              0.000485 hi def link hamlRubyOutputChar         hamlRubyChar
   43              0.000792 hi def link hamlRubyChar               Special
   43              0.000801 hi def link hamlInterpolationDelimiter Delimiter
   43              0.000837 hi def link hamlInterpolationEscape    Special
   43              0.000839 hi def link hamlAttributeString        String
   43              0.000817 hi def link hamlAttributeVariable      Identifier
   43              0.000827 hi def link hamlDocType                PreProc
   43              0.000805 hi def link hamlFilter                 PreProc
   43              0.000795 hi def link hamlAttributesDelimiter    Delimiter
   43              0.000787 hi def link hamlObjectDelimiter        Delimiter
   43              0.000798 hi def link hamlHelper                 Function
   43              0.000661 hi def link hamlHtmlComment            hamlComment
   43              0.000798 hi def link hamlComment                Comment
   43              0.000814 hi def link hamlIEConditional          SpecialComment
   43              0.000803 hi def link hamlError                  Error
                            
   43              0.000307 let b:current_syntax = "haml"
                            
   43              0.000225 if main_syntax == "haml"
   43              0.000141   unlet main_syntax
   43              0.000065 endif
                            
                            " vim:set sw=2:

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/syntax/html.vim
Sourced 44 times
Total time: 152.217416
 Self time:   2.471056

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	HTML
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " URL:		http://www.fleiner.com/vim/syntax/html.vim
                            " Last Change:	2015 Jan 07
                            "		included patch from David Felix
                            
                            " Please check :help html.vim for some comments and a description of the options
                            
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
   44              0.001918 if !exists("main_syntax")
    1              0.000007   if version < 600
                                syntax clear
                              elseif exists("b:current_syntax")
                                finish
                              endif
    1              0.000014   let main_syntax = 'html'
    1              0.000003 endif
                            
   44              0.000767 let s:cpo_save = &cpo
   44              0.000730 set cpo&vim
                            
                            " don't use standard HiLink, it will not work with included syntax files
   44              0.000223 if version < 508
                              command! -nargs=+ HtmlHiLink hi link <args>
                            else
   44              0.000898   command! -nargs=+ HtmlHiLink hi def link <args>
   44              0.000095 endif
                            
   44              0.000170 syntax spell toplevel
                            
   44              0.000180 syn case ignore
                            
                            " mark illegal characters
   44              0.001896 syn match htmlError "[<>&]"
                            
                            
                            " tags
   44              0.003040 syn region  htmlString   contained start=+"+ end=+"+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
   44              0.002653 syn region  htmlString   contained start=+'+ end=+'+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
   44              0.001928 syn match   htmlValue    contained "=[\t ]*[^'" \t>][^ \t>]*"hs=s+1   contains=javaScriptExpression,@htmlPreproc
   44              0.004074 syn region  htmlEndTag             start=+</+      end=+>+ contains=htmlTagN,htmlTagError
   44              0.008908 syn region  htmlTag                start=+<[^/]+   end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent,htmlCssDefinition,@htmlPreproc,@htmlArgCluster
   44              0.004849 syn match   htmlTagN     contained +<\s*[-a-zA-Z0-9]\++hs=s+1 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
   44              0.004340 syn match   htmlTagN     contained +</\s*[-a-zA-Z0-9]\++hs=s+2 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
   44              0.000790 syn match   htmlTagError contained "[^>]<"ms=s+1
                            
                            
                            " tag names
   44              0.001102 syn keyword htmlTagName contained address applet area a base basefont
   44              0.001076 syn keyword htmlTagName contained big blockquote br caption center
   44              0.001167 syn keyword htmlTagName contained cite code dd dfn dir div dl dt font
   44              0.000987 syn keyword htmlTagName contained form hr html img
   44              0.001089 syn keyword htmlTagName contained input isindex kbd li link map menu
   44              0.001074 syn keyword htmlTagName contained meta ol option param pre p samp span
   44              0.001353 syn keyword htmlTagName contained select small strike sub sup
   44              0.001477 syn keyword htmlTagName contained table td textarea th tr tt ul var xmp
   44              0.001476 syn match htmlTagName contained "\<\(b\|i\|u\|h[1-6]\|em\|strong\|head\|body\|title\)\>"
                            
                            " new html 4.0 tags
   44              0.001069 syn keyword htmlTagName contained abbr acronym bdo button col label
   44              0.001046 syn keyword htmlTagName contained colgroup del fieldset iframe ins legend
   44              0.001311 syn keyword htmlTagName contained object optgroup q s tbody tfoot thead
                            
                            " legal arg names
   44              0.000905 syn keyword htmlArg contained action
   44              0.000999 syn keyword htmlArg contained align alink alt archive background bgcolor
   44              0.000951 syn keyword htmlArg contained border bordercolor cellpadding
   44              0.001064 syn keyword htmlArg contained cellspacing checked class clear code codebase color
   44              0.001037 syn keyword htmlArg contained cols colspan content coords enctype face
   44              0.000981 syn keyword htmlArg contained gutter height hspace id
   44              0.000923 syn keyword htmlArg contained link lowsrc marginheight
   44              0.000999 syn keyword htmlArg contained marginwidth maxlength method name prompt
   44              0.001045 syn keyword htmlArg contained rel rev rows rowspan scrolling selected shape
   44              0.001042 syn keyword htmlArg contained size src start target text type url
   44              0.001062 syn keyword htmlArg contained usemap ismap valign value vlink vspace width wrap
   44              0.001279 syn match   htmlArg contained "\<\(http-equiv\|href\|title\)="me=e-1
                            
                            " Netscape extensions
   44              0.001068 syn keyword htmlTagName contained frame noframes frameset nobr blink
   44              0.000961 syn keyword htmlTagName contained layer ilayer nolayer spacer
   44              0.000994 syn keyword htmlArg     contained frameborder noresize pagex pagey above below
   44              0.001053 syn keyword htmlArg     contained left top visibility clip id noshade
   44              0.001002 syn match   htmlArg     contained "\<z-index\>"
                            
                            " Microsoft extensions
   44              0.000854 syn keyword htmlTagName contained marquee
                            
                            " html 4.0 arg names
   44              0.001117 syn match   htmlArg contained "\<\(accept-charset\|label\)\>"
   44              0.038110 syn keyword htmlArg contained abbr accept accesskey axis char charoff charset
   44              0.001287 syn keyword htmlArg contained cite classid codetype compact data datetime
   44              0.001075 syn keyword htmlArg contained declare defer dir disabled for frame
   44              0.001033 syn keyword htmlArg contained headers hreflang lang language longdesc
   44              0.002183 syn keyword htmlArg contained multiple nohref nowrap object profile readonly
   44              0.001823 syn keyword htmlArg contained rules scheme scope span standby style
   44              0.001597 syn keyword htmlArg contained summary tabindex valuetype version
                            
                            " special characters
   44              0.001486 syn match htmlSpecialChar "&#\=[0-9A-Za-z]\{1,8};"
                            
                            " Comments (the real ones or the old netscape ones)
   44              0.000419 if exists("html_wrong_comments")
                              syn region htmlComment                start=+<!--+    end=+--\s*>+ contains=@Spell
                            else
   44              0.002269   syn region htmlComment                start=+<!+      end=+>+   contains=htmlCommentPart,htmlCommentError,@Spell
   44              0.000929   syn match  htmlCommentError contained "[^><!]"
   44              0.000993   syn region htmlCommentPart  contained start=+--+      end=+--\s*+  contains=@htmlPreProc,@Spell
   44              0.000112 endif
   44              0.000767 syn region htmlComment                  start=+<!DOCTYPE+ keepend end=+>+
                            
                            " server-parsed commands
   44              0.002774 syn region htmlPreProc start=+<!--#+ end=+-->+ contains=htmlPreStmt,htmlPreError,htmlPreAttr
   44              0.001096 syn match htmlPreStmt contained "<!--#\(config\|echo\|exec\|fsize\|flastmod\|include\|printenv\|set\|if\|elif\|else\|endif\|geoguide\)\>"
   44              0.000642 syn match htmlPreError contained "<!--#\S*"ms=s+4
   44              0.002142 syn match htmlPreAttr contained "\w\+=[^"]\S\+" contains=htmlPreProcAttrError,htmlPreProcAttrName
   44              0.001766 syn region htmlPreAttr contained start=+\w\+="+ skip=+\\\\\|\\"+ end=+"+ contains=htmlPreProcAttrName keepend
   44              0.000634 syn match htmlPreProcAttrError contained "\w\+="he=e-1
   44              0.000903 syn match htmlPreProcAttrName contained "\(expr\|errmsg\|sizefmt\|timefmt\|var\|cgi\|cmd\|file\|virtual\|value\)="he=e-1
                            
   44              0.000303 if !exists("html_no_rendering")
                              " rendering
   44              0.007130   syn cluster htmlTop contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,javaScript,@htmlPreproc
                            
   44              0.002467   syn region htmlBold start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
   44              0.002268   syn region htmlBold start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
   44              0.002164   syn region htmlBoldUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlBoldUnderlineItalic
   44              0.001538   syn region htmlBoldItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlBoldItalicUnderline
   44              0.001482   syn region htmlBoldItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop,htmlBoldItalicUnderline
   44              0.000849   syn region htmlBoldUnderlineItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop
   44              0.000817   syn region htmlBoldUnderlineItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop
   44              0.001735   syn region htmlBoldItalicUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlBoldUnderlineItalic
                            
   44              0.002181   syn region htmlUnderline start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlUnderlineBold,htmlUnderlineItalic
   44              0.001584   syn region htmlUnderlineBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlUnderlineBoldItalic
   44              0.001546   syn region htmlUnderlineBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlUnderlineBoldItalic
   44              0.001532   syn region htmlUnderlineItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlUnderlineItalicBold
   44              0.002296   syn region htmlUnderlineItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop,htmlUnderlineItalicBold
   44              0.000905   syn region htmlUnderlineItalicBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop
   44              0.000964   syn region htmlUnderlineItalicBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop
   44              0.000850   syn region htmlUnderlineBoldItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop
   44              0.000808   syn region htmlUnderlineBoldItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop
                            
   44              0.002175   syn region htmlItalic start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlItalicBold,htmlItalicUnderline
   44              0.000784   syn region htmlItalic start="<em\>" end="</em>"me=e-5 contains=@htmlTop
   44              0.001500   syn region htmlItalicBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlItalicBoldUnderline
   44              0.003706   syn region htmlItalicBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlItalicBoldUnderline
   44              0.000901   syn region htmlItalicBoldUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop
   44              0.001586   syn region htmlItalicUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlItalicUnderlineBold
   44              0.000800   syn region htmlItalicUnderlineBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop
   44              0.000826   syn region htmlItalicUnderlineBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop
                            
   44              0.000601   syn match htmlLeadingSpace "^\s\+" contained
   44              0.007417   syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a>"me=e-4 contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLeadingSpace,javaScript,@htmlPreproc
   44              0.000924   syn region htmlH1 start="<h1\>" end="</h1>"me=e-5 contains=@htmlTop
   44              0.000772   syn region htmlH2 start="<h2\>" end="</h2>"me=e-5 contains=@htmlTop
   44              0.000889   syn region htmlH3 start="<h3\>" end="</h3>"me=e-5 contains=@htmlTop
   44              0.000896   syn region htmlH4 start="<h4\>" end="</h4>"me=e-5 contains=@htmlTop
   44              0.000914   syn region htmlH5 start="<h5\>" end="</h5>"me=e-5 contains=@htmlTop
   44              0.001476   syn region htmlH6 start="<h6\>" end="</h6>"me=e-5 contains=@htmlTop
   44              0.008382   syn region htmlHead start="<head\>" end="</head>"me=e-7 end="<body\>"me=e-5 end="<h[1-6]\>"me=e-3 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,htmlTitle,javaScript,cssStyle,@htmlPreproc
   44              0.006226   syn region htmlTitle start="<title\>" end="</title>"me=e-8 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,javaScript,@htmlPreproc
   44              0.000122 endif
                            
   44              0.001032 syn keyword htmlTagName         contained noscript
   44              0.001002 syn keyword htmlSpecialTagName  contained script style
   44              0.000388 if main_syntax != 'java' || exists("java_javascript")
                              " JAVA SCRIPT
   44              0.112858   syn include @htmlJavaScript syntax/javascript.vim
   44              0.000244   unlet b:current_syntax
   44              0.002847   syn region  javaScript start=+<script\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlJavaScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
   44              0.005772   syn region  htmlScriptTag     contained start=+<script+ end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent
   44              0.001236   HtmlHiLink htmlScriptTag htmlTag
                            
                              " html events (i.e. arguments that include javascript commands)
   44              0.000305   if exists("html_extended_events")
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ contains=htmlEventSQ
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ contains=htmlEventDQ
                              else
   44              0.001219     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ keepend contains=htmlEventSQ
   44              0.001227     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ keepend contains=htmlEventDQ
   44              0.000088   endif
   44              0.000611   syn region htmlEventSQ        contained start=+'+ms=s+1 end=+'+me=s-1 contains=@htmlJavaScript
   44              0.000641   syn region htmlEventDQ        contained start=+"+ms=s+1 end=+"+me=s-1 contains=@htmlJavaScript
   44              0.000858   HtmlHiLink htmlEventSQ htmlEvent
   44              0.000768   HtmlHiLink htmlEventDQ htmlEvent
                            
                              " a javascript expression is used as an arg value
   44              0.000949   syn region  javaScriptExpression contained start=+&{+ keepend end=+};+ contains=@htmlJavaScript,@htmlPreproc
   44              0.000098 endif
                            
   44              0.000263 if main_syntax != 'java' || exists("java_vb")
                              " VB SCRIPT
   44              0.111103   syn include @htmlVbScript syntax/vb.vim
   44              0.000220   unlet b:current_syntax
   44              0.002503   syn region  javaScript start=+<script \_[^>]*language *=\_[^>]*vbscript\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlVbScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
   44              0.000134 endif
                            
   44              0.000240 syn cluster htmlJavaScript      add=@htmlPreproc
                            
   44              0.000381 if main_syntax != 'java' || exists("java_css")
                              " embedded style sheets
   44              0.000694   syn keyword htmlArg           contained media
   44              0.014969   syn include @htmlCss syntax/css.vim
   44              0.000228   unlet b:current_syntax
   44              0.004166   syn region cssStyle start=+<style+ keepend end=+</style>+ contains=@htmlCss,htmlTag,htmlEndTag,htmlCssStyleComment,@htmlPreproc
   44              0.000619   syn match htmlCssStyleComment contained "\(<!--\|-->\)"
   44              0.179102   syn region htmlCssDefinition matchgroup=htmlArg start='style="' keepend matchgroup=htmlString end='"' contains=css.*Attr,css.*Prop,cssComment,cssLength,cssColor,cssURL,cssImportant,cssError,cssString,@htmlPreproc
   44              0.001164   HtmlHiLink htmlStyleArg htmlString
   44              0.000076 endif
                            
   44              0.000263 if main_syntax == "html"
                              " synchronizing (does not always work if a comment includes legal
                              " html tags, but doing it right would mean to always start
                              " at the first line, which is too slow)
    1              0.000030   syn sync match htmlHighlight groupthere NONE "<[/a-zA-Z]"
    1              0.000017   syn sync match htmlHighlight groupthere javaScript "<script"
    1              0.000014   syn sync match htmlHighlightSkip "^.*['\"].*$"
    1              0.000003   syn sync minlines=10
    1              0.000001 endif
                            
                            " The default highlighting.
   44              0.000204 if version >= 508 || !exists("did_html_syn_inits")
   44              0.000087   if version < 508
                                let did_html_syn_inits = 1
                              endif
   44              0.001186   HtmlHiLink htmlTag                     Function
   44              0.001110   HtmlHiLink htmlEndTag                  Identifier
   44              0.001101   HtmlHiLink htmlArg                     Type
   44              0.000879   HtmlHiLink htmlTagName                 htmlStatement
   44              0.001094   HtmlHiLink htmlSpecialTagName          Exception
   44              0.000885   HtmlHiLink htmlValue                     String
   44              0.000871   HtmlHiLink htmlSpecialChar             Special
                              
   44              0.000292   if !exists("html_no_rendering")
   44              0.000983     HtmlHiLink htmlH1                      Title
   44              0.000679     HtmlHiLink htmlH2                      htmlH1
   44              0.000603     HtmlHiLink htmlH3                      htmlH2
   44              0.000605     HtmlHiLink htmlH4                      htmlH3
   44              0.000631     HtmlHiLink htmlH5                      htmlH4
   44              0.001044     HtmlHiLink htmlH6                      htmlH5
   44              0.000851     HtmlHiLink htmlHead                    PreProc
   44              0.001159     HtmlHiLink htmlTitle                   Title
   44              0.000734     HtmlHiLink htmlBoldItalicUnderline     htmlBoldUnderlineItalic
   44              0.000633     HtmlHiLink htmlUnderlineBold           htmlBoldUnderline
   44              0.000758     HtmlHiLink htmlUnderlineItalicBold     htmlBoldUnderlineItalic
   44              0.000739     HtmlHiLink htmlUnderlineBoldItalic     htmlBoldUnderlineItalic
   44              0.000669     HtmlHiLink htmlItalicUnderline         htmlUnderlineItalic
   44              0.000681     HtmlHiLink htmlItalicBold              htmlBoldItalic
   44              0.000716     HtmlHiLink htmlItalicBoldUnderline     htmlBoldUnderlineItalic
   44              0.000824     HtmlHiLink htmlItalicUnderlineBold     htmlBoldUnderlineItalic
   44              0.001514     HtmlHiLink htmlLink                    Underlined
   44              0.000696     HtmlHiLink htmlLeadingSpace            None
   44              0.000248     if !exists("html_my_rendering")
   44              0.001033       hi def htmlBold                term=bold cterm=bold gui=bold
   44              0.000516       hi def htmlBoldUnderline       term=bold,underline cterm=bold,underline gui=bold,underline
   44              0.000293       hi def htmlBoldItalic          term=bold,italic cterm=bold,italic gui=bold,italic
   44              0.000297       hi def htmlBoldUnderlineItalic term=bold,italic,underline cterm=bold,italic,underline gui=bold,italic,underline
   44              0.000300       hi def htmlUnderline           term=underline cterm=underline gui=underline
   44              0.000306       hi def htmlUnderlineItalic     term=italic,underline cterm=italic,underline gui=italic,underline
   44              0.000278       hi def htmlItalic              term=italic cterm=italic gui=italic
   44              0.000050     endif
   44              0.000036   endif
                              
   44              0.000837   HtmlHiLink htmlPreStmt            PreProc
   44              0.000827   HtmlHiLink htmlPreError           Error
   44              0.000848   HtmlHiLink htmlPreProc            PreProc
   44              0.000903   HtmlHiLink htmlPreAttr            String
   44              0.000909   HtmlHiLink htmlPreProcAttrName    PreProc
   44              0.000905   HtmlHiLink htmlPreProcAttrError   Error
   44              0.001038   HtmlHiLink htmlSpecial            Special
   44              0.000865   HtmlHiLink htmlSpecialChar        Special
   44              0.001004   HtmlHiLink htmlString             String
   44              0.000906   HtmlHiLink htmlStatement          Statement
   44              0.000880   HtmlHiLink htmlComment            Comment
   44              0.000902   HtmlHiLink htmlCommentPart        Comment
   44              0.000840   HtmlHiLink htmlValue              String
   44              0.000642   HtmlHiLink htmlCommentError       htmlError
   44              0.000603   HtmlHiLink htmlTagError           htmlError
   44              0.000793   HtmlHiLink htmlEvent              javaScript
   44              0.000855   HtmlHiLink htmlError              Error
                              
   44              0.001134   HtmlHiLink javaScript             Special
   44              0.000928   HtmlHiLink javaScriptExpression   javaScript
   44              0.000889   HtmlHiLink htmlCssStyleComment    Comment
   44              0.000869   HtmlHiLink htmlCssDefinition      Special
   44              0.000055 endif
                            
   44              0.000130 delcommand HtmlHiLink
                            
   44              0.000211 let b:current_syntax = "html"
                            
   44              0.000154 if main_syntax == 'html'
    1              0.000002   unlet main_syntax
    1              0.000001 endif
                            
   44              0.000552 let &cpo = s:cpo_save
   44              0.000112 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/syntax/javascript.vim
Sourced 44 times
Total time:   0.088217
 Self time:   0.088217

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2012 Oct 05
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
                            " tuning parameters:
                            " unlet javaScript_fold
                            
   44              0.000857 if !exists("main_syntax")
                              if version < 600
                                syntax clear
                              elseif exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'javascript'
                            elseif exists("b:current_syntax") && b:current_syntax == "javascript"
                              finish
                            endif
                            
   44              0.000451 let s:cpo_save = &cpo
   44              0.000417 set cpo&vim
                            
                            " Drop fold if it set but vim doesn't support it.
   44              0.000215 if version < 600 && exists("javaScript_fold")
                              unlet javaScript_fold
                            endif
                            
                            
   44              0.001625 syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
   44              0.001462 syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
   44              0.000844 syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
   44              0.001634 syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
   44              0.000696 syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
   44              0.001676 syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
   44              0.001388 syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
                            
   44              0.000538 syn match   javaScriptSpecialCharacter "'\\.'"
   44              0.000909 syn match   javaScriptNumber	       "-\=\<\d\+L\=\>\|0[xX][0-9a-fA-F]\+\>"
   44              0.001465 syn region  javaScriptRegexpString     start=+/[^/*]+me=e-1 skip=+\\\\\|\\/+ end=+/[gim]\{0,2\}\s*$+ end=+/[gim]\{0,2\}\s*[;.,)\]}]+me=e-1 contains=@htmlPreproc oneline
                            
   44              0.000973 syn keyword javaScriptConditional	if else switch
   44              0.000979 syn keyword javaScriptRepeat		while for do in
   44              0.000774 syn keyword javaScriptBranch		break continue
   44              0.001065 syn keyword javaScriptOperator		new delete instanceof typeof
   44              0.001216 syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
   44              0.000492 syn keyword javaScriptStatement		return with
   44              0.000478 syn keyword javaScriptBoolean		true false
   44              0.000482 syn keyword javaScriptNull		null undefined
   44              0.000554 syn keyword javaScriptIdentifier	arguments this var let
   44              0.000497 syn keyword javaScriptLabel		case default
   44              0.000532 syn keyword javaScriptException		try catch finally throw
   44              0.000540 syn keyword javaScriptMessage		alert confirm prompt status
   44              0.000651 syn keyword javaScriptGlobal		self window top parent
   44              0.000523 syn keyword javaScriptMember		document event location 
   44              0.000795 syn keyword javaScriptDeprecated	escape unescape
   44              0.001333 syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile 
                            
   44              0.000256 if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
                            else
   44              0.000546     syn keyword javaScriptFunction	function
   44              0.000618     syn match	javaScriptBraces	   "[{}\[\]]"
   44              0.000631     syn match	javaScriptParens	   "[()]"
   44              0.000088 endif
                            
   44              0.000127 syn sync fromstart
   44              0.000135 syn sync maxlines=100
                            
   44              0.000215 if main_syntax == "javascript"
                              syn sync ccomment javaScriptComment
                            endif
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
   44              0.000179 if version >= 508 || !exists("did_javascript_syn_inits")
   44              0.000105   if version < 508
                                let did_javascript_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
   44              0.000512     command -nargs=+ HiLink hi def link <args>
   44              0.013303   endif
   44              0.001852   HiLink javaScriptComment		Comment
   44              0.001302   HiLink javaScriptLineComment		Comment
   44              0.001196   HiLink javaScriptCommentTodo		Todo
   44              0.001154   HiLink javaScriptSpecial		Special
   44              0.001175   HiLink javaScriptStringS		String
   44              0.001149   HiLink javaScriptStringD		String
   44              0.001182   HiLink javaScriptCharacter		Character
   44              0.000890   HiLink javaScriptSpecialCharacter	javaScriptSpecial
   44              0.000798   HiLink javaScriptNumber		javaScriptValue
   44              0.001097   HiLink javaScriptConditional		Conditional
   44              0.001108   HiLink javaScriptRepeat		Repeat
   44              0.001148   HiLink javaScriptBranch		Conditional
   44              0.001154   HiLink javaScriptOperator		Operator
   44              0.001134   HiLink javaScriptType			Type
   44              0.001150   HiLink javaScriptStatement		Statement
   44              0.001114   HiLink javaScriptFunction		Function
   44              0.001097   HiLink javaScriptBraces		Function
   44              0.001094   HiLink javaScriptError		Error
   44              0.000811   HiLink javaScrParenError		javaScriptError
   44              0.001051   HiLink javaScriptNull			Keyword
   44              0.001096   HiLink javaScriptBoolean		Boolean
   44              0.001096   HiLink javaScriptRegexpString		String
                            
   44              0.001087   HiLink javaScriptIdentifier		Identifier
   44              0.001074   HiLink javaScriptLabel		Label
   44              0.001073   HiLink javaScriptException		Exception
   44              0.001070   HiLink javaScriptMessage		Keyword
   44              0.001068   HiLink javaScriptGlobal		Keyword
   44              0.001066   HiLink javaScriptMember		Keyword
   44              0.001297   HiLink javaScriptDeprecated		Exception 
   44              0.001384   HiLink javaScriptReserved		Keyword
   44              0.001166   HiLink javaScriptDebug		Debug
   44              0.001098   HiLink javaScriptConstant		Label
                            
   44              0.000158   delcommand HiLink
   44              0.000058 endif
                            
   44              0.000277 let b:current_syntax = "javascript"
   44              0.000283 if main_syntax == 'javascript'
                              unlet main_syntax
                            endif
   44              0.000816 let &cpo = s:cpo_save
   44              0.000149 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/syntax/vb.vim
Sourced 44 times
Total time:   0.339492
 Self time:   0.339492

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Visual Basic
                            " Maintainer:	Tim Chase <vb.vim@tim.thechases.com>
                            " Former Maintainer:	Robert M. Cortopassi <cortopar@mindspring.com>
                            "	(tried multiple times to contact, but email bounced)
                            " Last Change:
                            "   2005 May 25  Synched with work by Thomas Barthel
                            "   2004 May 30  Added a few keywords
                            
                            " This was thrown together after seeing numerous requests on the
                            " VIM and VIM-DEV mailing lists.  It is by no means complete.
                            " Send comments, suggestions and requests to the maintainer.
                            
                            " For version 5.x: Clear all syntax items
                            " For version 6.x: Quit when a syntax file was already loaded
   44              0.001293 if version < 600
                            	syntax clear
                            elseif exists("b:current_syntax")
                            	finish
                            endif
                            
                            " VB is case insensitive
   44              0.000219 syn case ignore
                            
   44              0.001594 syn keyword vbConditional If Then ElseIf Else Select Case
                            
   44              0.000885 syn keyword vbOperator AddressOf And ByRef ByVal Eqv Imp In
   44              0.000957 syn keyword vbOperator Is Like Mod Not Or To Xor
                            
   44              0.001060 syn match vbOperator "[()+.,\-/*=&]"
   44              0.000789 syn match vbOperator "[<>]=\="
   44              0.001030 syn match vbOperator "<>"
   44              0.000766 syn match vbOperator "\s\+_$"
                            
   44              0.000667 syn keyword vbBoolean  True False
   44              0.000635 syn keyword vbConst Null Nothing
                            
   44              0.000730 syn keyword vbRepeat Do For ForEach Loop Next
   44              0.000720 syn keyword vbRepeat Step To Until Wend While
                            
   44              0.000682 syn keyword vbEvents AccessKeyPress Activate ActiveRowChanged
   44              0.000702 syn keyword vbEvents AfterAddFile AfterChangeFileName AfterCloseFile
   44              0.000641 syn keyword vbEvents AfterColEdit AfterColUpdate AfterDelete
   44              0.000662 syn keyword vbEvents AfterInsert AfterLabelEdit AfterRemoveFile
   44              0.000625 syn keyword vbEvents AfterUpdate AfterWriteFile AmbientChanged
   44              0.000609 syn keyword vbEvents ApplyChanges Associate AsyncProgress
   44              0.000639 syn keyword vbEvents AsyncReadComplete AsyncReadProgress AxisActivated
   44              0.000591 syn keyword vbEvents AxisLabelActivated AxisLabelSelected
   44              0.000629 syn keyword vbEvents AxisLabelUpdated AxisSelected AxisTitleActivated
   44              0.000604 syn keyword vbEvents AxisTitleSelected AxisTitleUpdated AxisUpdated
   44              0.000594 syn keyword vbEvents BeforeClick BeforeColEdit BeforeColUpdate
   44              0.000586 syn keyword vbEvents BeforeConnect BeforeDelete BeforeInsert
   44              0.000600 syn keyword vbEvents BeforeLabelEdit BeforeLoadFile BeforeUpdate
   44              0.000588 syn keyword vbEvents BeginRequest BeginTrans ButtonClick
   44              0.000656 syn keyword vbEvents ButtonCompleted ButtonDropDown ButtonGotFocus
   44              0.000655 syn keyword vbEvents ButtonLostFocus CallbackKeyDown Change Changed
   44              0.000688 syn keyword vbEvents ChartActivated ChartSelected ChartUpdated Click
   44              0.000718 syn keyword vbEvents Close CloseQuery CloseUp ColEdit ColResize
   44              0.000643 syn keyword vbEvents Collapse ColumnClick CommitTrans Compare
   44              0.000588 syn keyword vbEvents ConfigChageCancelled ConfigChanged
   44              0.000651 syn keyword vbEvents ConfigChangedCancelled Connect ConnectionRequest
   44              0.000585 syn keyword vbEvents CurrentRecordChanged DECommandAdded
   44              0.000604 syn keyword vbEvents DECommandPropertyChanged DECommandRemoved
   44              0.000758 syn keyword vbEvents DEConnectionAdded DEConnectionPropertyChanged
   44              0.000653 syn keyword vbEvents DEConnectionRemoved DataArrival DataChanged
   44              0.000642 syn keyword vbEvents DataUpdated DateClicked DblClick Deactivate
   44              0.000608 syn keyword vbEvents DevModeChange DeviceArrival DeviceOtherEvent
   44              0.000581 syn keyword vbEvents DeviceQueryRemove DeviceQueryRemoveFailed
   44              0.000574 syn keyword vbEvents DeviceRemoveComplete DeviceRemovePending
   44              0.000648 syn keyword vbEvents Disconnect DisplayChanged Dissociate
   44              0.000666 syn keyword vbEvents DoGetNewFileName Done DonePainting DownClick
   44              0.000664 syn keyword vbEvents DragDrop DragOver DropDown EditProperty EditQuery
   44              0.000680 syn keyword vbEvents EndRequest EnterCell EnterFocus ExitFocus Expand
   44              0.000625 syn keyword vbEvents FontChanged FootnoteActivated FootnoteSelected
   44              0.000658 syn keyword vbEvents FootnoteUpdated Format FormatSize GotFocus
   44              0.000630 syn keyword vbEvents HeadClick HeightChanged Hide InfoMessage
   44              0.000589 syn keyword vbEvents IniProperties InitProperties Initialize
   44              0.000623 syn keyword vbEvents ItemActivated ItemAdded ItemCheck ItemClick
   44              0.000592 syn keyword vbEvents ItemReloaded ItemRemoved ItemRenamed
   44              0.000656 syn keyword vbEvents ItemSeletected KeyDown KeyPress KeyUp LeaveCell
   44              0.000603 syn keyword vbEvents LegendActivated LegendSelected LegendUpdated
   44              0.000643 syn keyword vbEvents LinkClose LinkError LinkExecute LinkNotify
   44              0.000628 syn keyword vbEvents LinkOpen Load LostFocus MouseDown MouseMove
   44              0.000696 syn keyword vbEvents MouseUp NodeCheck NodeClick OLECompleteDrag
   44              0.023511 syn keyword vbEvents OLEDragDrop OLEDragOver OLEGiveFeedback OLESetData
   44              0.000974 syn keyword vbEvents OLEStartDrag ObjectEvent ObjectMove OnAddNew
   44              0.001023 syn keyword vbEvents OnComm Paint PanelClick PanelDblClick PathChange
   44              0.000690 syn keyword vbEvents PatternChange PlotActivated PlotSelected
   44              0.000640 syn keyword vbEvents PlotUpdated PointActivated PointLabelActivated
   44              0.000652 syn keyword vbEvents PointLabelSelected PointLabelUpdated PointSelected
   44              0.000666 syn keyword vbEvents PointUpdated PowerQuerySuspend PowerResume
   44              0.000681 syn keyword vbEvents PowerStatusChanged PowerSuspend ProcessTag
   44              0.000607 syn keyword vbEvents ProcessingTimeout QueryChangeConfig QueryClose
   44              0.000606 syn keyword vbEvents QueryComplete QueryCompleted QueryTimeout
   44              0.000629 syn keyword vbEvents QueryUnload ReadProperties RepeatedControlLoaded
   44              0.000797 syn keyword vbEvents RepeatedControlUnloaded Reposition
   44              0.000651 syn keyword vbEvents RequestChangeFileName RequestWriteFile Resize
   44              0.000596 syn keyword vbEvents ResultsChanged RetainedProject RollbackTrans
   44              0.000584 syn keyword vbEvents RowColChange RowCurrencyChange RowResize
   44              0.000712 syn keyword vbEvents RowStatusChanged Scroll SelChange SelectionChanged
   44              0.000604 syn keyword vbEvents SendComplete SendProgress SeriesActivated
   44              0.000690 syn keyword vbEvents SeriesSelected SeriesUpdated SettingChanged Show
   44              0.000656 syn keyword vbEvents SplitChange Start StateChanged StatusUpdate
   44              0.000660 syn keyword vbEvents SysColorsChanged Terminate TimeChanged Timer
   44              0.000663 syn keyword vbEvents TitleActivated TitleSelected TitleUpdated
   44              0.000570 syn keyword vbEvents UnboundAddData UnboundDeleteRow
   44              0.000579 syn keyword vbEvents UnboundGetRelativeBookmark UnboundReadData
   44              0.000628 syn keyword vbEvents UnboundWriteData Unformat Unload UpClick Updated
   44              0.000613 syn keyword vbEvents UserEvent Validate ValidationError
   44              0.000649 syn keyword vbEvents VisibleRecordChanged WillAssociate WillChangeData
   44              0.000603 syn keyword vbEvents WillDissociate WillExecute WillUpdateRows
   44              0.000512 syn keyword vbEvents WriteProperties
                            
                            
   44              0.000814 syn keyword vbFunction Abs Array Asc AscB AscW Atn Avg BOF CBool CByte
   44              0.000779 syn keyword vbFunction CCur CDate CDbl CInt CLng CSng CStr CVDate CVErr
   44              0.000754 syn keyword vbFunction CVar CallByName Cdec Choose Chr ChrB ChrW Command
   44              0.000757 syn keyword vbFunction Cos Count CreateObject CurDir DDB Date DateAdd
   44              0.000684 syn keyword vbFunction DateDiff DatePart DateSerial DateValue Day Dir
   44              0.000686 syn keyword vbFunction DoEvents EOF Environ Error Exp FV FileAttr
   44              0.000661 syn keyword vbFunction FileDateTime FileLen FilterFix Fix Format
   44              0.000609 syn keyword vbFunction FormatCurrency FormatDateTime FormatNumber
   44              0.000619 syn keyword vbFunction FormatPercent FreeFile GetAllStrings GetAttr
   44              0.000631 syn keyword vbFunction GetAutoServerSettings GetObject GetSetting Hex
   44              0.000678 syn keyword vbFunction Hour IIf IMEStatus IPmt InStr Input InputB
   44              0.000690 syn keyword vbFunction InputBox InstrB Int IsArray IsDate IsEmpty IsError
   44              0.000661 syn keyword vbFunction IsMissing IsNull IsNumeric IsObject Join LBound
   44              0.000852 syn keyword vbFunction LCase LOF LTrim Left LeftB Len LenB LoadPicture
   44              0.000687 syn keyword vbFunction LoadResData LoadResPicture LoadResString Loc Log
   44              0.000665 syn keyword vbFunction MIRR Max Mid MidB Min Minute Month MonthName
   44              0.000681 syn keyword vbFunction MsgBox NPV NPer Now Oct PPmt PV Partition Pmt
   44              0.000690 syn keyword vbFunction QBColor RGB RTrim Rate Replace Right RightB Rnd
   44              0.000762 syn keyword vbFunction Round SLN SYD Second Seek Sgn Shell Sin Space Spc
   44              0.000675 syn keyword vbFunction Split Sqr StDev StDevP Str StrComp StrConv
   44              0.000659 syn keyword vbFunction StrReverse String Sum Switch Tab Tan Time
   44              0.000659 syn keyword vbFunction TimeSerial TimeValue Timer Trim TypeName UBound
   44              0.000690 syn keyword vbFunction UCase Val Var VarP VarType Weekday WeekdayName
   44              0.000525 syn keyword vbFunction Year
                            
   44              0.000661 syn keyword vbMethods AboutBox Accept Activate Add AddCustom AddFile
   44              0.000601 syn keyword vbMethods AddFromFile AddFromGuid AddFromString
   44              0.000638 syn keyword vbMethods AddFromTemplate AddItem AddNew AddToAddInToolbar
   44              0.000595 syn keyword vbMethods AddToolboxProgID Append AppendAppendChunk
   44              0.002930 syn keyword vbMethods AppendChunk Arrange Assert AsyncRead BatchUpdate
   44              0.005124 syn keyword vbMethods BeginQueryEdit BeginTrans Bind BuildPath
   44              0.003119 syn keyword vbMethods CanPropertyChange Cancel CancelAsyncRead
   44              0.003784 syn keyword vbMethods CancelBatch CancelUpdate CaptureImage CellText
   44              0.004002 syn keyword vbMethods CellValue Circle Clear ClearFields ClearSel
   44              0.003514 syn keyword vbMethods ClearSelCols ClearStructure Clone Close Cls
   44              0.005002 syn keyword vbMethods ColContaining CollapseAll ColumnSize CommitTrans
   44              0.004041 syn keyword vbMethods CompactDatabase Compose Connect Copy CopyFile
   44              0.002774 syn keyword vbMethods CopyFolder CopyQueryDef Count CreateDatabase
   44              0.002655 syn keyword vbMethods CreateDragImage CreateEmbed CreateField
   44              0.003192 syn keyword vbMethods CreateFolder CreateGroup CreateIndex CreateLink
   44              0.002531 syn keyword vbMethods CreatePreparedStatement CreatePropery CreateQuery
   44              0.002428 syn keyword vbMethods CreateQueryDef CreateRelation CreateTableDef
   44              0.002407 syn keyword vbMethods CreateTextFile CreateToolWindow CreateUser
   44              0.002462 syn keyword vbMethods CreateWorkspace Customize Cut Delete
   44              0.002716 syn keyword vbMethods DeleteColumnLabels DeleteColumns DeleteFile
   44              0.002654 syn keyword vbMethods DeleteFolder DeleteLines DeleteRowLabels
   44              0.003724 syn keyword vbMethods DeleteRows DeselectAll DesignerWindow DoVerb Drag
   44              0.004355 syn keyword vbMethods Draw DriveExists Edit EditCopy EditPaste EndDoc
   44              0.003204 syn keyword vbMethods EnsureVisible EstablishConnection Execute Exists
   44              0.002562 syn keyword vbMethods Expand Export ExportReport ExtractIcon Fetch
   44              0.003769 syn keyword vbMethods FetchVerbs FileExists Files FillCache Find
   44              0.003831 syn keyword vbMethods FindFirst FindItem FindLast FindNext FindPrevious
   44              0.002612 syn keyword vbMethods FolderExists Forward GetAbsolutePathName
   44              0.003171 syn keyword vbMethods GetBaseName GetBookmark GetChunk GetClipString
   44              0.004026 syn keyword vbMethods GetData GetDrive GetDriveName GetFile GetFileName
   44              0.003151 syn keyword vbMethods GetFirstVisible GetFolder GetFormat GetHeader
   44              0.002639 syn keyword vbMethods GetLineFromChar GetNumTicks GetParentFolderName
   44              0.002585 syn keyword vbMethods GetRows GetSelectedPart GetSelection
   44              0.002646 syn keyword vbMethods GetSpecialFolder GetTempName GetText
   44              0.003322 syn keyword vbMethods GetVisibleCount GoBack GoForward Hide HitTest
   44              0.003310 syn keyword vbMethods HoldFields Idle Import InitializeLabels Insert
   44              0.002688 syn keyword vbMethods InsertColumnLabels InsertColumns InsertFile
   44              0.002546 syn keyword vbMethods InsertLines InsertObjDlg InsertRowLabels
   44              0.005268 syn keyword vbMethods InsertRows Item Keys KillDoc Layout Line Lines
   44              0.003276 syn keyword vbMethods LinkExecute LinkPoke LinkRequest LinkSend Listen
   44              0.001361 syn keyword vbMethods LoadFile LoadResData LoadResPicture LoadResString
   44              0.002571 syn keyword vbMethods LogEvent MakeCompileFile MakeCompiledFile
   44              0.001299 syn keyword vbMethods MakeReplica MoreResults Move MoveData MoveFile
   44              0.000553 syn keyword vbMethods MoveFirst MoveFolder MoveLast MoveNext
   44              0.000508 syn keyword vbMethods MovePrevious NavigateTo NewPage NewPassword
   44              0.000528 syn keyword vbMethods NextRecordset OLEDrag OnAddinsUpdate OnConnection
   44              0.000474 syn keyword vbMethods OnDisconnection OnStartupComplete Open
   44              0.000478 syn keyword vbMethods OpenAsTextStream OpenConnection OpenDatabase
   44              0.000516 syn keyword vbMethods OpenQueryDef OpenRecordset OpenResultset OpenURL
   44              0.000511 syn keyword vbMethods Overlay PSet PaintPicture PastSpecialDlg Paste
   44              0.000491 syn keyword vbMethods PeekData Play Point PopulatePartial PopupMenu
   44              0.000511 syn keyword vbMethods Print PrintForm PrintReport PropertyChanged Quit
   44              0.000642 syn keyword vbMethods Raise RandomDataFill RandomFillColumns
   44              0.000517 syn keyword vbMethods RandomFillRows ReFill Read ReadAll ReadFromFile
   44              0.000517 syn keyword vbMethods ReadLine ReadProperty Rebind Refresh RefreshLink
   44              0.000481 syn keyword vbMethods RegisterDatabase ReleaseInstance Reload Remove
   44              0.000533 syn keyword vbMethods RemoveAddInFromToolbar RemoveAll RemoveItem Render
   44              0.000529 syn keyword vbMethods RepairDatabase ReplaceLine Reply ReplyAll Requery
   44              0.000450 syn keyword vbMethods ResetCustom ResetCustomLabel ResolveName
   44              0.000460 syn keyword vbMethods RestoreToolbar Resync Rollback RollbackTrans
   44              0.000496 syn keyword vbMethods RowBookmark RowContaining RowTop Save SaveAs
   44              0.000484 syn keyword vbMethods SaveFile SaveToFile SaveToOle1File SaveToolbar
   44              0.000507 syn keyword vbMethods Scale ScaleX ScaleY Scroll SelPrint SelectAll
   44              0.000546 syn keyword vbMethods SelectPart Send SendData Set SetAutoServerSettings
   44              0.000511 syn keyword vbMethods SetData SetFocus SetOption SetSelection SetSize
   44              0.000500 syn keyword vbMethods SetText SetViewport Show ShowColor ShowFont
   44              0.000512 syn keyword vbMethods ShowHelp ShowOpen ShowPrinter ShowSave
   44              0.000543 syn keyword vbMethods ShowWhatsThis SignOff SignOn Size Skip SkipLine
   44              0.000523 syn keyword vbMethods Span Split SplitContaining StartLabelEdit
   44              0.000538 syn keyword vbMethods StartLogging Stop Synchronize Tag TextHeight
   44              0.018601 syn keyword vbMethods TextWidth ToDefaults Trace TwipsToChartPart
   44              0.000588 syn keyword vbMethods TypeByChartType URLFor Update UpdateControls
   44              0.000527 syn keyword vbMethods UpdateRecord UpdateRow Upto ValidateControls Value
   44              0.000526 syn keyword vbMethods WhatsThisMode Write WriteBlankLines WriteLine
   44              0.000487 syn keyword vbMethods WriteProperty WriteTemplate ZOrder
   44              0.000539 syn keyword vbMethods rdoCreateEnvironment rdoRegisterDataSource
                            
   44              0.000564 syn keyword vbStatement Alias AppActivate As Base Beep Begin Call ChDir
   44              0.000668 syn keyword vbStatement ChDrive Close Const Date Declare DefBool DefByte
   44              0.000621 syn keyword vbStatement DefCur DefDate DefDbl DefDec DefInt DefLng DefObj
   44              0.000642 syn keyword vbStatement DefSng DefStr DefVar Deftype DeleteSetting Dim Do
   44              0.000612 syn keyword vbStatement Each ElseIf End Enum Erase Error Event Exit
   44              0.000591 syn keyword vbStatement Explicit FileCopy For ForEach Function Get GoSub
   44              0.000638 syn keyword vbStatement GoTo Gosub Implements Kill LSet Let Lib LineInput
   44              0.000764 syn keyword vbStatement Load Lock Loop Mid MkDir Name Next On OnError Open
   44              0.000569 syn keyword vbStatement Option Preserve Private Property Public Put RSet
   44              0.000511 syn keyword vbStatement RaiseEvent Randomize ReDim Redim Reset Resume
   44              0.000574 syn keyword vbStatement Return RmDir SavePicture SaveSetting Seek SendKeys
   44              0.000574 syn keyword vbStatement Sendkeys Set SetAttr Static Step Stop Sub Time
   44              0.000563 syn keyword vbStatement Type Unload Unlock Until Wend While Width With
   44              0.000383 syn keyword vbStatement Write
                            
   44              0.000586 syn keyword vbKeyword As Binary ByRef ByVal Date Empty Error Friend Get
   44              0.000634 syn keyword vbKeyword Input Is Len Lock Me Mid New Nothing Null On
   44              0.000519 syn keyword vbKeyword Option Optional ParamArray Print Private Property
   44              0.000495 syn keyword vbKeyword Public PublicNotCreateable OnNewProcessSingleUse
   44              0.000489 syn keyword vbKeyword InSameProcessMultiUse GlobalMultiUse Resume Seek
   44              0.000481 syn keyword vbKeyword Set Static Step String Time WithEvents
                            
   44              0.000375 syn keyword vbTodo contained	TODO
                            
                            "Datatypes
   44              0.000565 syn keyword vbTypes Boolean Byte Currency Date Decimal Double Empty
   44              0.000517 syn keyword vbTypes Integer Long Object Single String Variant
                            
                            "VB defined values
   44              0.000487 syn keyword vbDefine dbBigInt dbBinary dbBoolean dbByte dbChar
   44              0.000529 syn keyword vbDefine dbCurrency dbDate dbDecimal dbDouble dbFloat
   44              0.000526 syn keyword vbDefine dbGUID dbInteger dbLong dbLongBinary dbMemo
   44              0.000550 syn keyword vbDefine dbNumeric dbSingle dbText dbTime dbTimeStamp
   44              0.000454 syn keyword vbDefine dbVarBinary
                            
                            "VB defined values
   44              0.000484 syn keyword vbDefine vb3DDKShadow vb3DFace vb3DHighlight vb3DLight
   44              0.000464 syn keyword vbDefine vb3DShadow vbAbort vbAbortRetryIgnore
   44              0.000481 syn keyword vbDefine vbActiveBorder vbActiveTitleBar vbAlias
   44              0.000579 syn keyword vbDefine vbApplicationModal vbApplicationWorkspace
   44              0.000798 syn keyword vbDefine vbAppTaskManager vbAppWindows vbArchive vbArray
   44              0.000543 syn keyword vbDefine vbBack vbBinaryCompare vbBlack vbBlue vbBoolean
   44              0.000479 syn keyword vbDefine vbButtonFace vbButtonShadow vbButtonText vbByte
   44              0.000465 syn keyword vbDefine vbCalGreg vbCalHijri vbCancel vbCr vbCritical
   44              0.000480 syn keyword vbDefine vbCrLf vbCurrency vbCyan vbDatabaseCompare
   44              0.000456 syn keyword vbDefine vbDataObject vbDate vbDecimal vbDefaultButton1
   44              0.000462 syn keyword vbDefine vbDefaultButton2 vbDefaultButton3 vbDefaultButton4
   44              0.000487 syn keyword vbDefine vbDesktop vbDirectory vbDouble vbEmpty vbError
   44              0.000444 syn keyword vbDefine vbExclamation vbFirstFourDays vbFirstFullWeek
   44              0.000445 syn keyword vbDefine vbFirstJan1 vbFormCode vbFormControlMenu
   44              0.000471 syn keyword vbDefine vbFormFeed vbFormMDIForm vbFriday vbFromUnicode
   44              0.000491 syn keyword vbDefine vbGrayText vbGreen vbHidden vbHide vbHighlight
   44              0.000475 syn keyword vbDefine vbHighlightText vbHiragana vbIgnore vbIMEAlphaDbl
   44              0.000448 syn keyword vbDefine vbIMEAlphaSng vbIMEDisable vbIMEHiragana
   44              0.000447 syn keyword vbDefine vbIMEKatakanaDbl vbIMEKatakanaSng vbIMEModeAlpha
   44              0.000423 syn keyword vbDefine vbIMEModeAlphaFull vbIMEModeDisable
   44              0.000428 syn keyword vbDefine vbIMEModeHangul vbIMEModeHangulFull
   44              0.000433 syn keyword vbDefine vbIMEModeHiragana vbIMEModeKatakana
   44              0.000450 syn keyword vbDefine vbIMEModeKatakanaHalf vbIMEModeNoControl
   44              0.000495 syn keyword vbDefine vbIMEModeOff vbIMEModeOn vbIMENoOp vbIMEOff
   44              0.000445 syn keyword vbDefine vbIMEOn vbInactiveBorder vbInactiveCaptionText
   44              0.000467 syn keyword vbDefine vbInactiveTitleBar vbInfoBackground vbInformation
   44              0.000455 syn keyword vbDefine vbInfoText vbInteger vbKatakana vbKey0 vbKey1
   44              0.000461 syn keyword vbDefine vbKey2 vbKey3 vbKey4 vbKey5 vbKey6 vbKey7 vbKey8
   44              0.000773 syn keyword vbDefine vbKey9 vbKeyA vbKeyAdd vbKeyB vbKeyBack vbKeyC
   44              0.000456 syn keyword vbDefine vbKeyCancel vbKeyCapital vbKeyClear vbKeyControl
   44              0.000436 syn keyword vbDefine vbKeyD vbKeyDecimal vbKeyDelete vbKeyDivide
   44              0.000459 syn keyword vbDefine vbKeyDown vbKeyE vbKeyEnd vbKeyEscape vbKeyExecute
   44              0.000468 syn keyword vbDefine vbKeyF vbKeyF1 vbKeyF10 vbKeyF11 vbKeyF12 vbKeyF13
   44              0.000475 syn keyword vbDefine vbKeyF14 vbKeyF15 vbKeyF16 vbKeyF2 vbKeyF3 vbKeyF4
   44              0.000449 syn keyword vbDefine vbKeyF5 vbKeyF6 vbKeyF7 vbKeyF8 vbKeyF9 vbKeyG
   44              0.000557 syn keyword vbDefine vbKeyH vbKeyHelp vbKeyHome vbKeyI vbKeyInsert
   44              0.000529 syn keyword vbDefine vbKeyJ vbKeyK vbKeyL vbKeyLButton vbKeyLeft vbKeyM
   44              0.000471 syn keyword vbDefine vbKeyMButton vbKeyMenu vbKeyMultiply vbKeyN
   44              0.000443 syn keyword vbDefine vbKeyNumlock vbKeyNumpad0 vbKeyNumpad1
   44              0.000406 syn keyword vbDefine vbKeyNumpad2 vbKeyNumpad3 vbKeyNumpad4
   44              0.000410 syn keyword vbDefine vbKeyNumpad5 vbKeyNumpad6 vbKeyNumpad7
   44              0.000423 syn keyword vbDefine vbKeyNumpad8 vbKeyNumpad9 vbKeyO vbKeyP
   44              0.000436 syn keyword vbDefine vbKeyPageDown vbKeyPageUp vbKeyPause vbKeyPrint
   44              0.000438 syn keyword vbDefine vbKeyQ vbKeyR vbKeyRButton vbKeyReturn vbKeyRight
   44              0.000433 syn keyword vbDefine vbKeyS vbKeySelect vbKeySeparator vbKeyShift
   44              0.000426 syn keyword vbDefine vbKeySnapshot vbKeySpace vbKeySubtract vbKeyT
   44              0.000491 syn keyword vbDefine vbKeyTab vbKeyU vbKeyUp vbKeyV vbKeyW vbKeyX
   44              0.000486 syn keyword vbDefine vbKeyY vbKeyZ vbLf vbLong vbLowerCase vbMagenta
   44              0.000423 syn keyword vbDefine vbMaximizedFocus vbMenuBar vbMenuText
   44              0.000423 syn keyword vbDefine vbMinimizedFocus vbMinimizedNoFocus vbMonday
   44              0.000419 syn keyword vbDefine vbMsgBox vbMsgBoxHelpButton vbMsgBoxRight
   44              0.000400 syn keyword vbDefine vbMsgBoxRtlReading vbMsgBoxSetForeground
   44              0.000437 syn keyword vbDefine vbMsgBoxText vbNarrow vbNewLine vbNo vbNormal
   44              0.000442 syn keyword vbDefine vbNormalFocus vbNormalNoFocus vbNull vbNullChar
   44              0.000489 syn keyword vbDefine vbNullString vbObject vbObjectError vbOK
   44              0.000446 syn keyword vbDefine vbOKCancel vbOKOnly vbProperCase vbQuestion
   44              0.000451 syn keyword vbDefine vbReadOnly vbRed vbRetry vbRetryCancel vbSaturday
   44              0.000443 syn keyword vbDefine vbScrollBars vbSingle vbString vbSunday vbSystem
   44              0.000404 syn keyword vbDefine vbSystemModal vbTab vbTextCompare vbThursday
   44              0.000422 syn keyword vbDefine vbTitleBarText vbTuesday vbUnicode vbUpperCase
   44              0.000408 syn keyword vbDefine vbUseSystem vbUseSystemDayOfWeek vbVariant
   44              0.000430 syn keyword vbDefine vbVerticalTab vbVolume vbWednesday vbWhite vbWide
   44              0.000411 syn keyword vbDefine vbWindowBackground vbWindowFrame vbWindowText
   44              0.000406 syn keyword vbDefine vbYellow vbYes vbYesNo vbYesNoCancel
                            
                            "Numbers
                            "integer number, or floating point number without a dot.
   44              0.000696 syn match vbNumber "\<\d\+\>"
                            "floating point number, with dot
   44              0.000476 syn match vbNumber "\<\d\+\.\d*\>"
                            "floating point number, starting with a dot
   44              0.000443 syn match vbNumber "\.\d\+\>"
                            "syn match  vbNumber		"{[[:xdigit:]-]\+}\|&[hH][[:xdigit:]]\+&"
                            "syn match  vbNumber		":[[:xdigit:]]\+"
                            "syn match  vbNumber		"[-+]\=\<\d\+\>"
   44              0.000620 syn match  vbFloat		"[-+]\=\<\d\+[eE][\-+]\=\d\+"
   44              0.001460 syn match  vbFloat		"[-+]\=\<\d\+\.\d*\([eE][\-+]\=\d\+\)\="
   44              0.000647 syn match  vbFloat		"[-+]\=\<\.\d\+\([eE][\-+]\=\d\+\)\="
                            
                            " String and Character contstants
   44              0.000686 syn region  vbString		start=+"+  end=+"\|$+
   44              0.001179 syn region  vbComment		start="\(^\|\s\)REM\s" end="$" contains=vbTodo
   44              0.000983 syn region  vbComment		start="\(^\|\s\)\'"   end="$" contains=vbTodo
   44              0.000478 syn match   vbLineNumber	"^\d\+\(\s\|$\)"
   44              0.000642 syn match   vbTypeSpecifier  "[a-zA-Z0-9][\$%&!#]"ms=s+1
   44              0.000506 syn match   vbTypeSpecifier  "#[a-zA-Z0-9]"me=e-1
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
   44              0.000307 if version >= 508 || !exists("did_vb_syntax_inits")
   44              0.000097 	if version < 508
                            		let did_vb_syntax_inits = 1
                            		command -nargs=+ HiLink hi link <args>
                            	else
   44              0.000409 		command -nargs=+ HiLink hi def link <args>
   44              0.000053 	endif
                            
   44              0.001377 	HiLink vbBoolean		Boolean
   44              0.001108 	HiLink vbLineNumber		Comment
   44              0.000922 	HiLink vbComment		Comment
   44              0.000947 	HiLink vbConditional	Conditional
   44              0.000912 	HiLink vbConst			Constant
   44              0.000900 	HiLink vbDefine			Constant
   44              0.000896 	HiLink vbError			Error
   44              0.000908 	HiLink vbFunction		Identifier
   44              0.000894 	HiLink vbIdentifier		Identifier
   44              0.000904 	HiLink vbNumber			Number
   44              0.000885 	HiLink vbFloat			Float
   44              0.000913 	HiLink vbMethods		PreProc
   44              0.000881 	HiLink vbOperator		Operator
   44              0.000910 	HiLink vbRepeat			Repeat
   44              0.000878 	HiLink vbString			String
   44              0.000882 	HiLink vbStatement		Statement
   44              0.000874 	HiLink vbKeyword		Statement
   44              0.001162 	HiLink vbEvents			Special
   44              0.000934 	HiLink vbTodo			Todo
   44              0.000944 	HiLink vbTypes			Type
   44              0.000890 	HiLink vbTypeSpecifier	Type
                            
   44              0.000123 	delcommand HiLink
   44              0.000046 endif
                            
   44              0.000214 let b:current_syntax = "vb"
                            
                            " vim: ts=8

SCRIPT  /Users/Jack/.vim/plugged/vim-css3-syntax/after/syntax/html.vim
Sourced 44 times
Total time:  18.991171
 Self time:  17.896011

count  total (s)   self (s)
                            syn include @htmlCss syntax/css/compositing-1.vim
   44              0.027736 syn include @htmlCss syntax/css/css-align-3.vim
   44              0.028467 syn include @htmlCss syntax/css/css-backgrounds-4.vim
   44              0.027604 syn include @htmlCss syntax/css/css-break-3.vim
   44              0.022965 syn include @htmlCss syntax/css/css-cascade-3.vim
   44              0.029244 syn include @htmlCss syntax/css/css-cascade-4.vim
   44              0.027060 syn include @htmlCss syntax/css/css-color-4.vim
   44              0.026396 syn include @htmlCss syntax/css/css-contain-1.vim
   44              0.053418 syn include @htmlCss syntax/css/css-content-3.vim
   44              0.024115 syn include @htmlCss syntax/css/css-counter-styles-3.vim
   44              0.018842 syn include @htmlCss syntax/css/css-device-adapt-1.vim
   44              0.015120 syn include @htmlCss syntax/css/css-display-3.vim
   44              0.014265 syn include @htmlCss syntax/css/css-flexbox-1.vim
   44              0.015304 syn include @htmlCss syntax/css/css-font-loading-3.vim
   44              0.030001 syn include @htmlCss syntax/css/css-fonts-3.vim
   44              0.023266 syn include @htmlCss syntax/css/css-fonts-4.vim
   44              0.020301 syn include @htmlCss syntax/css/css-gcpm-3.vim
   44              0.022719 syn include @htmlCss syntax/css/css-grid-1.vim
   44              0.022399 syn include @htmlCss syntax/css/css-images-4.vim
   44              0.019393 syn include @htmlCss syntax/css/css-inline-3.vim
   44              0.019260 syn include @htmlCss syntax/css/css-line-grid-1.vim
   44              0.016727 syn include @htmlCss syntax/css/css-lists-3.vim
   44              0.017983 syn include @htmlCss syntax/css/css-logical-1.vim
   44              0.016126 syn include @htmlCss syntax/css/css-masking-1.vim
   44              0.016502 syn include @htmlCss syntax/css/css-overflow-3.vim
   44              0.021647 syn include @htmlCss syntax/css/css-overflow-4.vim
   44              0.030814 syn include @htmlCss syntax/css/css-page-floats-3.vim
   44              0.026412 syn include @htmlCss syntax/css/css-paint-api-1.vim
   44              0.026994 syn include @htmlCss syntax/css/css-position-3.vim
   44              0.028092 syn include @htmlCss syntax/css/css-properties-values-api-1.vim
   44              0.022685 syn include @htmlCss syntax/css/css-pseudo-4.vim
   44              0.022108 syn include @htmlCss syntax/css/css-regions-1.vim
   44              0.027148 syn include @htmlCss syntax/css/css-rhythm-1.vim
   44              0.027879 syn include @htmlCss syntax/css/css-round-display-1.vim
   44              0.022316 syn include @htmlCss syntax/css/css-ruby-1.vim
   44              0.020419 syn include @htmlCss syntax/css/css-scoping-1.vim
   44              0.020945 syn include @htmlCss syntax/css/css-scroll-snap-1.vim
   44              0.018599 syn include @htmlCss syntax/css/css-shapes-1.vim
   44              0.017797 syn include @htmlCss syntax/css/css-sizing-3.vim
   44              0.026464 syn include @htmlCss syntax/css/css-style-attr.vim
   44              0.023775 syn include @htmlCss syntax/css/css-syntax-3.vim
   44              0.020888 syn include @htmlCss syntax/css/css-text-3.vim
   44              0.019360 syn include @htmlCss syntax/css/css-text-4.vim
   44              0.020373 syn include @htmlCss syntax/css/css-text-decor-3.vim
   44              0.019006 syn include @htmlCss syntax/css/css-timing-1.vim
   44              0.019005 syn include @htmlCss syntax/css/css-transforms-1.vim
   44              0.033163 syn include @htmlCss syntax/css/css-typed-om-1.vim
   44              0.019408 syn include @htmlCss syntax/css/css-ui-3.vim
   44              0.022879 syn include @htmlCss syntax/css/css-ui-4.vim
   44              0.023830 syn include @htmlCss syntax/css/css-values-3.vim
   44              0.024161 syn include @htmlCss syntax/css/css-variables-1.vim
   44              0.022410 syn include @htmlCss syntax/css/css-will-change-1.vim
   44              0.021051 syn include @htmlCss syntax/css/css-writing-modes-3.vim
   44              0.019221 syn include @htmlCss syntax/css/css3-animations.vim
   44              0.018507 syn include @htmlCss syntax/css/css3-background.vim
   44              0.016809 syn include @htmlCss syntax/css/css3-box.vim
   44              0.016703 syn include @htmlCss syntax/css/css3-color.vim
   44              0.016574 syn include @htmlCss syntax/css/css3-conditional.vim
   44              0.015033 syn include @htmlCss syntax/css/css3-exclusions.vim
   44              0.013350 syn include @htmlCss syntax/css/css3-images.vim
   44              0.058921 syn include @htmlCss syntax/css/css3-multicol.vim
   44              0.019081 syn include @htmlCss syntax/css/css3-namespace.vim
   44              0.021834 syn include @htmlCss syntax/css/css3-page.vim
   44              0.029526 syn include @htmlCss syntax/css/css3-speech.vim
   44              0.019851 syn include @htmlCss syntax/css/css3-transitions.vim
   44              0.017129 syn include @htmlCss syntax/css/cssom-1.vim
   44              0.022326 syn include @htmlCss syntax/css/cssom-view-1.vim
   44              0.027295 syn include @htmlCss syntax/css/fill-stroke-3.vim
   44              0.025702 syn include @htmlCss syntax/css/filter-effects-1.vim
   44              0.024812 syn include @htmlCss syntax/css/geometry-1.vim
   44              0.021756 syn include @htmlCss syntax/css/html5.vim
   44              0.021485 syn include @htmlCss syntax/css/motion-1.vim
   44              0.023607 syn include @htmlCss syntax/css/pointerevents.vim
   44              0.042026 syn include @htmlCss syntax/css/selectors-nonelement-1.vim
   44              0.021892 syn include @htmlCss syntax/css/selectors.vim
   44              0.019480 syn include @htmlCss syntax/css/selectors4.vim
   44              0.018737 syn include @htmlCss syntax/css/svg2.vim
   44              0.021020 syn include @htmlCss syntax/css/web-animations-1.vim
   44              0.019881 syn include @htmlCss syntax/css/worklets-1.vim

SCRIPT  /Users/Jack/.vim/plugged/vim-haml/syntax/sass.vim
Sourced 43 times
Total time: 147.658481
 Self time:   1.250913

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Sass
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:	*.sass
                            " Last Change:	2016 Aug 29
                            
   43              0.002176 if exists("b:current_syntax")
                              finish
                            endif
                            
   43              0.020629 runtime! syntax/css.vim
                            
   43              0.000120 syn case ignore
                            
   43              0.006951 syn cluster sassCssProperties contains=cssFontProp,cssFontDescriptorProp,cssColorProp,cssTextProp,cssBoxProp,cssGeneratedContentProp,cssPagingProp,cssUIProp,cssRenderProp,cssAuralProp,cssTableProp
   43              0.125834 syn cluster sassCssAttributes contains=css.*Attr,sassEndOfLineComment,scssComment,cssValue.*,cssColor,cssURL,sassDefault,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssRenderProp
                            
   43              0.001115 syn region sassDefinition matchgroup=cssBraces start="{" end="}" contains=TOP
                            
   43              0.072371 syn match sassProperty "\%([{};]\s*\|^\)\@<=\%([[:alnum:]-]\|#{[^{}]*}\)\+\s*:" contains=css.*Prop skipwhite nextgroup=sassCssAttribute contained containedin=sassDefinition
   43              0.076629 syn match sassProperty "^\s*\zs\s\%(\%([[:alnum:]-]\|#{[^{}]*}\)\+\s*:\|:[[:alnum:]-]\+\)"hs=s+1 contains=css.*Prop skipwhite nextgroup=sassCssAttribute
   43              0.072456 syn match sassProperty "^\s*\zs\s\%(:\=[[:alnum:]-]\+\s*=\)"hs=s+1 contains=css.*Prop skipwhite nextgroup=sassCssAttribute
   43              0.002067 syn match sassCssAttribute +\%("\%([^"]\|\\"\)*"\|'\%([^']\|\\'\)*'\|#{[^{}]*}\|[^{};]\)*+ contained contains=@sassCssAttributes,sassVariable,sassFunction,sassInterpolation
   43              0.000542 syn match sassFlag "!\%(default\|global\|optional\)\>" contained
   43              0.000410 syn match sassVariable "$[[:alnum:]_-]\+"
   43              0.000969 syn match sassVariableAssignment "\%([!$][[:alnum:]_-]\+\s*\)\@<=\%(||\)\==" nextgroup=sassCssAttribute skipwhite
   43              0.000815 syn match sassVariableAssignment "\%([!$][[:alnum:]_-]\+\s*\)\@<=:" nextgroup=sassCssAttribute skipwhite
                            
   43              0.000496 syn match sassFunction "\<\%(rgb\|rgba\|red\|green\|blue\|mix\)\>(\@=" contained
   43              0.000957 syn match sassFunction "\<\%(hsl\|hsla\|hue\|saturation\|lightness\|adjust-hue\|lighten\|darken\|saturate\|desaturate\|grayscale\|complement\)\>(\@=" contained
   43              0.000669 syn match sassFunction "\<\%(alpha\|opacity\|rgba\|opacify\|fade-in\|transparentize\|fade-out\)\>(\@=" contained
   43              0.000522 syn match sassFunction "\<\%(unquote\|quote\)\>(\@=" contained
   43              0.000595 syn match sassFunction "\<\%(percentage\|round\|ceil\|floor\|abs\)\>(\@=" contained
   43              0.000576 syn match sassFunction "\<\%(type-of\|unit\|unitless\|comparable\)\>(\@=" contained
                            
   43              0.003760 syn region sassInterpolation matchgroup=sassInterpolationDelimiter start="#{" end="}" contains=@sassCssAttributes,sassVariable,sassFunction containedin=cssStringQ,cssStringQQ,cssPseudoClass,sassProperty
                            
   43              0.000724 syn match sassMixinName "[[:alnum:]_-]\+" contained nextgroup=sassCssAttribute
   43              0.000747 syn match sassMixin  "^="               nextgroup=sassMixinName skipwhite
   43              0.000813 syn match sassMixin  "\%([{};]\s*\|^\s*\)\@<=@mixin"   nextgroup=sassMixinName skipwhite
   43              0.000730 syn match sassMixing "^\s\+\zs+"        nextgroup=sassMixinName
   43              0.000794 syn match sassMixing "\%([{};]\s*\|^\s*\)\@<=@include" nextgroup=sassMixinName skipwhite
   43              0.000540 syn match sassExtend "\%([{};]\s*\|^\s*\)\@<=@extend"
   43              0.000811 syn match sassPlaceholder "\%([{};]\s*\|^\s*\)\@<=%"   nextgroup=sassMixinName skipwhite
                            
   43              0.000747 syn match sassFunctionName "[[:alnum:]_-]\+" contained nextgroup=sassCssAttribute
   43              0.000814 syn match sassFunctionDecl "\%([{};]\s*\|^\s*\)\@<=@function"   nextgroup=sassFunctionName skipwhite
   43              0.000460 syn match sassReturn "\%([{};]\s*\|^\s*\)\@<=@return"
                            
   43              0.000360 syn match sassEscape     "^\s*\zs\\"
   43              0.000764 syn match sassIdChar     "#[[:alnum:]_-]\@=" nextgroup=sassId
   43              0.000384 syn match sassId         "[[:alnum:]_-]\+" contained
   43              0.000774 syn match sassClassChar  "\.[[:alnum:]_-]\@=" nextgroup=sassClass
   43              0.000383 syn match sassClass      "[[:alnum:]_-]\+" contained
   43              0.000477 syn match sassAmpersand  "&"
                            
                            " TODO: Attribute namespaces
                            " TODO: Arithmetic (including strings and concatenation)
                            
   43              0.001100 syn region sassMediaQuery matchgroup=sassMedia start="@media" end="[{};]\@=\|$" contains=sassMediaOperators
   43              0.000393 syn keyword sassMediaOperators and not only contained
   43              0.004250 syn region sassCharset start="@charset" end=";\|$" contains=scssComment,cssStringQ,cssStringQQ,cssURL,cssUnicodeEscape,cssMediaType
   43              0.784679 syn region sassInclude start="@import" end=";\|$" contains=scssComment,cssStringQ,cssStringQQ,cssURL,cssUnicodeEscape,cssMediaType
   43              0.003385 syn region sassDebugLine end=";\|$" matchgroup=sassDebug start="@debug\>" contains=@sassCssAttributes,sassVariable,sassFunction
   43              0.003054 syn region sassWarnLine end=";\|$" matchgroup=sassWarn start="@warn\>" contains=@sassCssAttributes,sassVariable,sassFunction
   43              0.004143 syn region sassControlLine matchgroup=sassControl start="@\%(if\|else\%(\s\+if\)\=\|while\|for\|each\)\>" end="[{};]\@=\|$" contains=sassFor,@sassCssAttributes,sassVariable,sassFunction
   43              0.000834 syn keyword sassFor from to through in contained
                            
   43              0.000719 syn keyword sassTodo        FIXME NOTE TODO OPTIMIZE XXX contained
   43              0.001803 syn region  sassComment     start="^\z(\s*\)//"  end="^\%(\z1 \)\@!" contains=sassTodo,@Spell
   43              0.001685 syn region  sassCssComment  start="^\z(\s*\)/\*" end="^\%(\z1 \)\@!" contains=sassTodo,@Spell
   43              0.002062 syn match   sassEndOfLineComment "//.*" contains=sassComment,sassTodo,@Spell
                            
   43              0.000837 hi def link sassEndOfLineComment        sassComment
   43              0.000695 hi def link sassCssComment              sassComment
   43              0.001296 hi def link sassComment                 Comment
   43              0.001098 hi def link sassFlag                    cssImportant
   43              0.001092 hi def link sassVariable                Identifier
   43              0.001226 hi def link sassFunction                Function
   43              0.001125 hi def link sassMixing                  PreProc
   43              0.001219 hi def link sassMixin                   PreProc
   43              0.001184 hi def link sassPlaceholder             PreProc
   43              0.001166 hi def link sassExtend                  PreProc
   43              0.001106 hi def link sassFunctionDecl            PreProc
   43              0.001087 hi def link sassReturn                  PreProc
   43              0.001089 hi def link sassTodo                    Todo
   43              0.001471 hi def link sassCharset                 PreProc
   43              0.001165 hi def link sassMedia                   PreProc
   43              0.001161 hi def link sassMediaOperators          PreProc
   43              0.001067 hi def link sassInclude                 Include
   43              0.000665 hi def link sassDebug                   sassControl
   43              0.000638 hi def link sassWarn                    sassControl
   43              0.001001 hi def link sassControl                 PreProc
   43              0.001035 hi def link sassFor                     PreProc
   43              0.001040 hi def link sassEscape                  Special
   43              0.001028 hi def link sassIdChar                  Special
   43              0.001025 hi def link sassClassChar               Special
   43              0.001052 hi def link sassInterpolationDelimiter  Delimiter
   43              0.001090 hi def link sassAmpersand               Character
   43              0.001090 hi def link sassId                      Identifier
   43              0.001039 hi def link sassClass                   Type
                            
   43              0.000441 let b:current_syntax = "sass"
                            
                            " vim:set sw=2:

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/syntax/sass.vim
Sourced 43 times
Total time:   0.002345
 Self time:   0.002345

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Sass
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:	*.sass
                            " Last Change:	2013 May 30
                            
   43              0.001314 if exists("b:current_syntax")
   43              0.000269   finish

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/syntax/ruby.vim
Sourced 53 times
Total time:   0.405621
 Self time:   0.405621

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:		Ruby
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            " ----------------------------------------------------------------------------
                            "
                            " Previous Maintainer:	Mirko Nasato
                            " Thanks to perl.vim authors, and to Reimer Behrends. :-) (MN)
                            " ----------------------------------------------------------------------------
                            
   53              0.001619 if exists("b:current_syntax")
                              finish
                            endif
                            
   53              0.000814 if has("folding") && exists("ruby_fold")
                              setlocal foldmethod=syntax
                            endif
                            
   53              0.004833 syn cluster rubyNotTop contains=@rubyExtendedStringSpecial,@rubyRegexpSpecial,@rubyDeclaration,rubyConditional,rubyExceptional,rubyMethodExceptional,rubyTodo
                            
   53              0.000343 if exists("ruby_space_errors")
                              if !exists("ruby_no_trail_space_error")
                                syn match rubySpaceError display excludenl "\s\+$"
                              endif
                              if !exists("ruby_no_tab_space_error")
                                syn match rubySpaceError display " \+\t"me=e-1
                              endif
                            endif
                            
                            " Operators
   53              0.000543 if exists("ruby_operators")
                              syn match  rubyOperator "[~!^&|*/%+-]\|\%(class\s*\)\@<!<<\|<=>\|<=\|\%(<\|\<class\s\+\u\w*\s*\)\@<!<[^<]\@=\|===\|==\|=\~\|>>\|>=\|=\@<!>\|\*\*\|\.\.\.\|\.\.\|::"
                              syn match  rubyOperator "->\|-=\|/=\|\*\*=\|\*=\|&&=\|&=\|&&\|||=\||=\|||\|%=\|+=\|!\~\|!="
                              syn region rubyBracketOperator matchgroup=rubyOperator start="\%(\w[?!]\=\|[]})]\)\@<=\[\s*" end="\s*]" contains=ALLBUT,@rubyNotTop
                            endif
                            
                            " Expression Substitution and Backslash Notation
   53              0.001317 syn match rubyStringEscape "\\\\\|\\[abefnrstv]\|\\\o\{1,3}\|\\x\x\{1,2}"						    contained display
   53              0.001480 syn match rubyStringEscape "\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)" contained display
   53              0.000827 syn match rubyQuoteEscape  "\\[\\']"											    contained display
                            
   53              0.001495 syn region rubyInterpolation	      matchgroup=rubyInterpolationDelimiter start="#{" end="}" contained contains=ALLBUT,@rubyNotTop
   53              0.004761 syn match  rubyInterpolation	      "#\%(\$\|@@\=\)\w\+"    display contained contains=rubyInterpolationDelimiter,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable,rubyPredefinedVariable
   53              0.000840 syn match  rubyInterpolationDelimiter "#\ze\%(\$\|@@\=\)\w\+" display contained
   53              0.003120 syn match  rubyInterpolation	      "#\$\%(-\w\|\W\)"       display contained contains=rubyInterpolationDelimiter,rubyPredefinedVariable,rubyInvalidVariable
   53              0.000897 syn match  rubyInterpolationDelimiter "#\ze\$\%(-\w\|\W\)"    display contained
   53              0.000952 syn region rubyNoInterpolation	      start="\\#{" end="}"            contained
   53              0.000805 syn match  rubyNoInterpolation	      "\\#{"		      display contained
   53              0.000821 syn match  rubyNoInterpolation	      "\\#\%(\$\|@@\=\)\w\+"  display contained
   53              0.000785 syn match  rubyNoInterpolation	      "\\#\$\W"		      display contained
                            
   53              0.001610 syn match rubyDelimEscape	"\\[(<{\[)>}\]]" transparent display contained contains=NONE
                            
   53              0.001392 syn region rubyNestedParentheses    start="("  skip="\\\\\|\\)"  matchgroup=rubyString end=")"	transparent contained
   53              0.001759 syn region rubyNestedCurlyBraces    start="{"  skip="\\\\\|\\}"  matchgroup=rubyString end="}"	transparent contained
   53              0.001625 syn region rubyNestedAngleBrackets  start="<"  skip="\\\\\|\\>"  matchgroup=rubyString end=">"	transparent contained
   53              0.001478 syn region rubyNestedSquareBrackets start="\[" skip="\\\\\|\\\]" matchgroup=rubyString end="\]"	transparent contained
                            
                            " These are mostly Oniguruma ready
   53              0.001430 syn region rubyRegexpComment	matchgroup=rubyRegexpSpecial   start="(?#"								  skip="\\)"  end=")"  contained
   53              0.002113 syn region rubyRegexpParens	matchgroup=rubyRegexpSpecial   start="(\(?:\|?<\=[=!]\|?>\|?<[a-z_]\w*>\|?[imx]*-[imx]*:\=\|\%(?#\)\@!\)" skip="\\)"  end=")"  contained transparent contains=@rubyRegexpSpecial
   53              0.003536 syn region rubyRegexpBrackets	matchgroup=rubyRegexpCharClass start="\[\^\="								  skip="\\\]" end="\]" contained transparent contains=rubyStringEscape,rubyRegexpEscape,rubyRegexpCharClass oneline
   53              0.001100 syn match  rubyRegexpCharClass	"\\[DdHhSsWw]"	       contained display
   53              0.012757 syn match  rubyRegexpCharClass	"\[:\^\=\%(alnum\|alpha\|ascii\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\):\]" contained
   53              0.001096 syn match  rubyRegexpEscape	"\\[].*?+^$|\\/(){}[]" contained
   53              0.000857 syn match  rubyRegexpQuantifier	"[*?+][?+]\="	       contained display
   53              0.000992 syn match  rubyRegexpQuantifier	"{\d\+\%(,\d*\)\=}?\=" contained display
   53              0.000806 syn match  rubyRegexpAnchor	"[$^]\|\\[ABbGZz]"     contained display
   53              0.000608 syn match  rubyRegexpDot	"\."		       contained display
   53              0.000587 syn match  rubyRegexpSpecial	"|"		       contained display
   53              0.000743 syn match  rubyRegexpSpecial	"\\[1-9]\d\=\d\@!"     contained display
   53              0.000988 syn match  rubyRegexpSpecial	"\\k<\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\=>" contained display
   53              0.001008 syn match  rubyRegexpSpecial	"\\k'\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\='" contained display
   53              0.000883 syn match  rubyRegexpSpecial	"\\g<\%([a-z_]\w*\|-\=\d\+\)>" contained display
   53              0.000848 syn match  rubyRegexpSpecial	"\\g'\%([a-z_]\w*\|-\=\d\+\)'" contained display
                            
   53              0.002346 syn cluster rubyStringSpecial	      contains=rubyInterpolation,rubyNoInterpolation,rubyStringEscape
   53              0.002974 syn cluster rubyExtendedStringSpecial contains=@rubyStringSpecial,rubyNestedParentheses,rubyNestedCurlyBraces,rubyNestedAngleBrackets,rubyNestedSquareBrackets
   53              0.008088 syn cluster rubyRegexpSpecial	      contains=rubyInterpolation,rubyNoInterpolation,rubyStringEscape,rubyRegexpSpecial,rubyRegexpEscape,rubyRegexpBrackets,rubyRegexpCharClass,rubyRegexpDot,rubyRegexpQuantifier,rubyRegexpAnchor,rubyRegexpParens,rubyRegexpComment
                            
                            " Numbers and ASCII Codes
   53              0.001831 syn match rubyASCIICode	"\%(\w\|[]})\"'/]\)\@<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)\)"
   53              0.001253 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[xX]\x\+\%(_\x\+\)*\>"								display
   53              0.001167 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0[dD]\)\=\%(0\|[1-9]\d*\%(_\d\+\)*\)\>"						display
   53              0.001027 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[oO]\=\o\+\%(_\o\+\)*\>"								display
   53              0.001031 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[bB][01]\+\%(_[01]\+\)*\>"								display
   53              0.001094 syn match rubyFloat	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\.\d\+\%(_\d\+\)*\>"					display
   53              0.001423 syn match rubyFloat	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\%(\.\d\+\%(_\d\+\)*\)\=\%([eE][-+]\=\d\+\%(_\d\+\)*\)\>"	display
                            
                            " Identifiers
   53              0.001523 syn match rubyLocalVariableOrMethod "\<[_[:lower:]][_[:alnum:]]*[?!=]\=" contains=NONE display transparent
   53              0.001512 syn match rubyBlockArgument	    "&[_[:lower:]][_[:alnum:]]"		 contains=NONE display transparent
                            
   53              0.001128 syn match  rubyConstant		"\%(\%([.@$]\@<!\.\)\@<!\<\|::\)\_s*\zs\u\w*\%(\>\|::\)\@=\%(\s*(\)\@!"
   53              0.001221 syn match  rubyClassVariable	"@@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" display
   53              0.001027 syn match  rubyInstanceVariable "@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"  display
   53              0.000979 syn match  rubyGlobalVariable	"$\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\|-.\)"
   53              0.001505 syn match  rubySymbol		"[]})\"':]\@<!:\%(\^\|\~\|<<\|<=>\|<=\|<\|===\|[=!]=\|[=!]\~\|!\|>>\|>=\|>\||\|-@\|-\|/\|\[]=\|\[]\|\*\*\|\*\|&\|%\|+@\|+\|`\)"
   53              0.001100 syn match  rubySymbol		"[]})\"':]\@<!:\$\%(-.\|[`~<=>_,;:!?/.'"@$*\&+0]\)"
   53              0.001105 syn match  rubySymbol		"[]})\"':]\@<!:\%(\$\|@@\=\)\=\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"
   53              0.001071 syn match  rubySymbol		"[]})\"':]\@<!:\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\%([?!=]>\@!\)\="
   53              0.000942 syn match  rubySymbol		"\%([{(,]\_s*\)\@<=\l\w*[!?]\=::\@!"he=e-1
   53              0.001076 syn match  rubySymbol		"[]})\"':]\@<!\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:\s\@="he=e-1
   53              0.000941 syn match  rubySymbol		"\%([{(,]\_s*\)\@<=[[:space:],{]\l\w*[!?]\=::\@!"hs=s+1,he=e-1
   53              0.001019 syn match  rubySymbol		"[[:space:],{]\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:\s\@="hs=s+1,he=e-1
   53              0.001873 syn region rubySymbol		start="[]})\"':]\@<!:'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape fold
   53              0.001168 syn region rubySymbol		start="[]})\"':]\@<!:\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial fold
                            
   53              0.000804 syn match  rubyBlockParameter	  "\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" contained
   53              0.001569 syn region rubyBlockParameterList start="\%(\%(\<do\>\|{\)\s*\)\@<=|" end="|" oneline display contains=rubyBlockParameter
                            
   53              0.000663 syn match rubyInvalidVariable	 "$[^ A-Za-z_-]"
   53              0.000834 syn match rubyPredefinedVariable #$[!$&"'*+,./0:;<=>?@\`~]#
   53              0.002811 syn match rubyPredefinedVariable "$\d\+"										   display
   53              0.000655 syn match rubyPredefinedVariable "$_\>"											   display
   53              0.000769 syn match rubyPredefinedVariable "$-[0FIKadilpvw]\>"									   display
   53              0.001105 syn match rubyPredefinedVariable "$\%(deferr\|defout\|stderr\|stdin\|stdout\)\>"					   display
   53              0.001431 syn match rubyPredefinedVariable "$\%(DEBUG\|FILENAME\|KCODE\|LOADED_FEATURES\|LOAD_PATH\|PROGRAM_NAME\|SAFE\|VERBOSE\)\>" display
   53              0.001324 syn match rubyPredefinedConstant "\%(\%(\.\@<!\.\)\@<!\|::\)\_s*\zs\%(MatchingData\|ARGF\|ARGV\|ENV\)\>\%(\s*(\)\@!"
   53              0.001190 syn match rubyPredefinedConstant "\%(\%(\.\@<!\.\)\@<!\|::\)\_s*\zs\%(DATA\|FALSE\|NIL\)\>\%(\s*(\)\@!"
   53              0.001201 syn match rubyPredefinedConstant "\%(\%(\.\@<!\.\)\@<!\|::\)\_s*\zs\%(STDERR\|STDIN\|STDOUT\|TOPLEVEL_BINDING\|TRUE\)\>\%(\s*(\)\@!"
   53              0.001611 syn match rubyPredefinedConstant "\%(\%(\.\@<!\.\)\@<!\|::\)\_s*\zs\%(RUBY_\%(VERSION\|RELEASE_DATE\|PLATFORM\|PATCHLEVEL\|REVISION\|DESCRIPTION\|COPYRIGHT\|ENGINE\)\)\>\%(\s*(\)\@!"
                            
                            " Normal Regular Expression
   53              0.002748 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(^\|\<\%(and\|or\|while\|until\|unless\|if\|elsif\|when\|not\|then\|else\)\|[;\~=!|&(,[<>?:*+-]\)\s*\)\@<=/" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial fold
   53              0.001705 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\h\k*\s\+\)\@<=/[ \t=]\@!" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial fold
                            
                            " Generalized Regular Expression
   53              0.001935 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z([~`!@#$%^&*_\-+=|\:;"',.? /]\)" end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial fold
   53              0.001558 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r{"				 end="}[iomxneus]*"   skip="\\\\\|\\}"	 contains=@rubyRegexpSpecial fold
   53              0.002586 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r<"				 end=">[iomxneus]*"   skip="\\\\\|\\>"	 contains=@rubyRegexpSpecial,rubyNestedAngleBrackets,rubyDelimEscape fold
   53              0.001414 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\["				 end="\][iomxneus]*"  skip="\\\\\|\\\]"	 contains=@rubyRegexpSpecial fold
   53              0.002285 syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r("				 end=")[iomxneus]*"   skip="\\\\\|\\)"	 contains=@rubyRegexpSpecial fold
                            
                            " Normal String and Shell Command Output
   53              0.001302 syn region rubyString matchgroup=rubyStringDelimiter start="\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial,@Spell fold
   53              0.001874 syn region rubyString matchgroup=rubyStringDelimiter start="'"	end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape,@Spell    fold
   53              0.001255 syn region rubyString matchgroup=rubyStringDelimiter start="`"	end="`"  skip="\\\\\|\\`"  contains=@rubyStringSpecial fold
                            
                            " Generalized Single Quoted String, Symbol and Array of Strings
   53              0.001504 syn region rubyString matchgroup=rubyStringDelimiter start="%[qwi]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" fold
   53              0.002617 syn region rubyString matchgroup=rubyStringDelimiter start="%[qwi]{"				   end="}"   skip="\\\\\|\\}"	fold contains=rubyNestedCurlyBraces,rubyDelimEscape
   53              0.002446 syn region rubyString matchgroup=rubyStringDelimiter start="%[qwi]<"				   end=">"   skip="\\\\\|\\>"	fold contains=rubyNestedAngleBrackets,rubyDelimEscape
   53              0.002444 syn region rubyString matchgroup=rubyStringDelimiter start="%[qwi]\["				   end="\]"  skip="\\\\\|\\\]"	fold contains=rubyNestedSquareBrackets,rubyDelimEscape
   53              0.002393 syn region rubyString matchgroup=rubyStringDelimiter start="%[qwi]("				   end=")"   skip="\\\\\|\\)"	fold contains=rubyNestedParentheses,rubyDelimEscape
   53              0.001214 syn region rubyString matchgroup=rubyStringDelimiter start="%q "				   end=" "   skip="\\\\\|\\)"	fold
   53              0.001382 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\z([~`!@#$%^&*_\-+=|\:;"',.? /]\)"   end="\z1" skip="\\\\\|\\\z1" fold
   53              0.002334 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s{"				   end="}"   skip="\\\\\|\\}"	fold contains=rubyNestedCurlyBraces,rubyDelimEscape
   53              0.002311 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s<"				   end=">"   skip="\\\\\|\\>"	fold contains=rubyNestedAngleBrackets,rubyDelimEscape
   53              0.004136 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\["				   end="\]"  skip="\\\\\|\\\]"	fold contains=rubyNestedSquareBrackets,rubyDelimEscape
   53              0.003480 syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s("				   end=")"   skip="\\\\\|\\)"	fold contains=rubyNestedParentheses,rubyDelimEscape
                            
                            " Generalized Double Quoted String and Array of Strings and Shell Command Output
                            " Note: %= is not matched here as the beginning of a double quoted string
   53              0.001676 syn region rubyString matchgroup=rubyStringDelimiter start="%\z([~`!@#$%^&*_\-+|\:;"',.?/]\)"	    end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
   53              0.001647 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWIx]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
   53              0.002554 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWIx]\={"				    end="}"   skip="\\\\\|\\}"	 contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimEscape    fold
   53              0.002581 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWIx]\=<"				    end=">"   skip="\\\\\|\\>"	 contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimEscape  fold
   53              0.002642 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWIx]\=\["				    end="\]"  skip="\\\\\|\\\]"	 contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimEscape fold
   53              0.002428 syn region rubyString matchgroup=rubyStringDelimiter start="%[QWIx]\=("				    end=")"   skip="\\\\\|\\)"	 contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimEscape    fold
   53              0.001258 syn region rubyString matchgroup=rubyStringDelimiter start="%[Qx] "				    end=" "   skip="\\\\\|\\)"   contains=@rubyStringSpecial fold
                            
                            " Here Document
   53              0.001922 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<-\=\zs\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)+	 end=+$+ oneline contains=ALLBUT,@rubyNotTop
   53              0.001531 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<-\=\zs"\%([^"]*\)"+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
   53              0.001691 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<-\=\zs'\%([^']*\)'+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
   53              0.001666 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<-\=\zs`\%([^`]*\)`+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
                            
   53              0.003099 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
   53              0.002849 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<"\z([^"]*\)"\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
   53              0.002665 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<'\z([^']*\)'\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc			fold keepend
   53              0.002809 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<`\z([^`]*\)`\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
                            
   53              0.032188 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<-\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+3    matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
   53              0.002138 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<-"\z([^"]*\)"\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
   53              0.002587 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<-'\z([^']*\)'\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart		     fold keepend
   53              0.002116 syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<-`\z([^`]*\)`\ze\%(.*<<-\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
                            
   53              0.000614 if exists('main_syntax') && main_syntax == 'eruby'
                              let b:ruby_no_expensive = 1
                            end
                            
   53              0.003114 syn match  rubyAliasDeclaration    "[^[:space:];#.()]\+" contained contains=rubySymbol,rubyGlobalVariable,rubyPredefinedVariable nextgroup=rubyAliasDeclaration2 skipwhite
   53              0.002413 syn match  rubyAliasDeclaration2   "[^[:space:];#.()]\+" contained contains=rubySymbol,rubyGlobalVariable,rubyPredefinedVariable
   53              0.004035 syn match  rubyMethodDeclaration   "[^[:space:];#(]\+"	 contained contains=rubyConstant,rubyBoolean,rubyPseudoVariable,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable
   53              0.001691 syn match  rubyClassDeclaration    "[^[:space:];#<]\+"	 contained contains=rubyConstant,rubyOperator
   53              0.001739 syn match  rubyModuleDeclaration   "[^[:space:];#<]\+"	 contained contains=rubyConstant,rubyOperator
   53              0.001317 syn match  rubyFunction "\<[_[:alpha:]][_[:alnum:]]*[?!=]\=[[:alnum:]_.:?!=]\@!" contained containedin=rubyMethodDeclaration
   53              0.001968 syn match  rubyFunction "\%(\s\|^\)\@<=[_[:alpha:]][_[:alnum:]]*[?!=]\=\%(\s\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2
   53              0.002997 syn match  rubyFunction "\%([[:space:].]\|^\)\@<=\%(\[\]=\=\|\*\*\|[+-]@\=\|[*/%|&^~]\|<<\|>>\|[<>]=\=\|<=>\|===\|[=!]=\|[=!]\~\|!\|`\)\%([[:space:];#(]\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration
                            
   53              0.003906 syn cluster rubyDeclaration contains=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration,rubyModuleDeclaration,rubyClassDeclaration,rubyFunction,rubyBlockParameter
                            
                            " Keywords
                            " Note: the following keywords have already been defined:
                            " begin case class def do end for if module unless until while
   53              0.001322 syn match   rubyControl	       "\<\%(and\|break\|in\|next\|not\|or\|redo\|rescue\|retry\|return\)\>[?!]\@!"
   53              0.000675 syn match   rubyOperator       "\<defined?" display
   53              0.000941 syn match   rubyKeyword	       "\<\%(super\|yield\)\>[?!]\@!"
   53              0.000640 syn match   rubyBoolean	       "\<\%(true\|false\)\>[?!]\@!"
   53              0.001114 syn match   rubyPseudoVariable "\<\%(nil\|self\|__ENCODING__\|__FILE__\|__LINE__\|__callee__\|__method__\)\>[?!]\@!" " TODO: reorganise
   53              0.000743 syn match   rubyBeginEnd       "\<\%(BEGIN\|END\)\>[?!]\@!"
                            
                            " Expensive Mode - match 'end' with the appropriate opening keyword for syntax
                            " based folding and special highlighting of module/class/method definitions
   53              0.000457 if !exists("b:ruby_no_expensive") && !exists("ruby_no_expensive")
   10              0.000378   syn match  rubyDefine "\<alias\>"  nextgroup=rubyAliasDeclaration  skipwhite skipnl
   10              0.000296   syn match  rubyDefine "\<def\>"    nextgroup=rubyMethodDeclaration skipwhite skipnl
   10              0.000293   syn match  rubyDefine "\<undef\>"  nextgroup=rubyFunction	     skipwhite skipnl
   10              0.000257   syn match  rubyClass	"\<class\>"  nextgroup=rubyClassDeclaration  skipwhite skipnl
   10              0.000316   syn match  rubyModule "\<module\>" nextgroup=rubyModuleDeclaration skipwhite skipnl
                            
   10              0.000387   syn region rubyMethodBlock start="\<def\>"	matchgroup=rubyDefine end="\%(\<def\_s\+\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop fold
   10              0.000221   syn region rubyBlock	     start="\<class\>"	matchgroup=rubyClass  end="\<end\>"		       contains=ALLBUT,@rubyNotTop fold
   10              0.000169   syn region rubyBlock	     start="\<module\>" matchgroup=rubyModule end="\<end\>"		       contains=ALLBUT,@rubyNotTop fold
                            
                              " modifiers
   10              0.000127   syn match rubyConditionalModifier "\<\%(if\|unless\)\>"    display
   10              0.000146   syn match rubyRepeatModifier	     "\<\%(while\|until\)\>" display
                            
   10              0.000226   syn region rubyDoBlock      matchgroup=rubyControl start="\<do\>" end="\<end\>"                 contains=ALLBUT,@rubyNotTop fold
                              " curly bracket block or hash literal
   10              0.000214   syn region rubyCurlyBlock	matchgroup=rubyCurlyBlockDelimiter  start="{" end="}"				contains=ALLBUT,@rubyNotTop fold
   10              0.000204   syn region rubyArrayLiteral	matchgroup=rubyArrayDelimiter	    start="\%(\w\|[\]})]\)\@<!\[" end="]"	contains=ALLBUT,@rubyNotTop fold
                            
                              " statements without 'do'
   10              0.000202   syn region rubyBlockExpression       matchgroup=rubyControl	  start="\<begin\>" end="\<end\>" contains=ALLBUT,@rubyNotTop fold
   10              0.000283   syn region rubyCaseExpression	       matchgroup=rubyConditional start="\<case\>"  end="\<end\>" contains=ALLBUT,@rubyNotTop fold
   10              0.000380   syn region rubyConditionalExpression matchgroup=rubyConditional start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+=-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![?!]\)\s*\)\@<=\%(if\|unless\)\>" end="\%(\%(\%(\.\@<!\.\)\|::\)\s*\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop fold
                            
   10              0.000228   syn match rubyConditional "\<\%(then\|else\|when\)\>[?!]\@!"	contained containedin=rubyCaseExpression
   10              0.000225   syn match rubyConditional "\<\%(then\|else\|elsif\)\>[?!]\@!" contained containedin=rubyConditionalExpression
                            
   10              0.000246   syn match rubyExceptional	  "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>[?!]\@!" contained containedin=rubyBlockExpression
   10              0.000245   syn match rubyMethodExceptional "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>[?!]\@!" contained containedin=rubyMethodBlock
                            
                              " statements with optional 'do'
   10              0.000480   syn region rubyOptionalDoLine   matchgroup=rubyRepeat start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyOptionalDo end="\%(\<do\>\)" end="\ze\%(;\|$\)" oneline contains=ALLBUT,@rubyNotTop
   10              0.000457   syn region rubyRepeatExpression start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyRepeat end="\<end\>" contains=ALLBUT,@rubyNotTop nextgroup=rubyOptionalDoLine fold
                            
   10              0.000070   if !exists("ruby_minlines")
                                let ruby_minlines = 500
                              endif
   10              0.000160   exec "syn sync minlines=" . ruby_minlines
                            
   10              0.000020 else
   43              0.001009   syn match rubyControl "\<def\>[?!]\@!"    nextgroup=rubyMethodDeclaration skipwhite skipnl
   43              0.000962   syn match rubyControl "\<class\>[?!]\@!"  nextgroup=rubyClassDeclaration  skipwhite skipnl
   43              0.000988   syn match rubyControl "\<module\>[?!]\@!" nextgroup=rubyModuleDeclaration skipwhite skipnl
   43              0.001046   syn match rubyControl "\<\%(case\|begin\|do\|for\|if\|unless\|while\|until\|else\|elsif\|ensure\|then\|when\|end\)\>[?!]\@!"
   43              0.000554   syn match rubyKeyword "\<\%(alias\|undef\)\>[?!]\@!"
   43              0.000080 endif
                            
                            " Special Methods
   53              0.000438 if !exists("ruby_no_special_methods")
   53              0.000912   syn keyword rubyAccess    public protected private public_class_method private_class_method public_constant private_constant module_function
                              " attr is a common variable name
   53              0.000819   syn match   rubyAttribute "\%(\%(^\|;\)\s*\)\@<=attr\>\(\s*[.=]\)\@!"
   53              0.000552   syn keyword rubyAttribute attr_accessor attr_reader attr_writer
   53              0.001136   syn match   rubyControl   "\<\%(exit!\|\%(abort\|at_exit\|exit\|fork\|loop\|trap\)\>[?!]\@!\)"
   53              0.000635   syn keyword rubyEval	    eval class_eval instance_eval module_eval
   53              0.000658   syn keyword rubyException raise fail catch throw
                              " false positive with 'include?'
   53              0.000574   syn match   rubyInclude   "\<include\>[?!]\@!"
   53              0.000626   syn keyword rubyInclude   autoload extend load prepend require require_relative
   53              0.000512   syn keyword rubyKeyword   callcc caller lambda proc
   53              0.000077 endif
                            
                            " Comments and Documentation
   53              0.000608 syn match   rubySharpBang "\%^#!.*" display
   53              0.000635 syn keyword rubyTodo	  FIXME NOTE TODO OPTIMIZE XXX todo contained
   53              0.002042 syn match   rubyComment   "#.*" contains=rubySharpBang,rubySpaceError,rubyTodo,@Spell
   53              0.000280 if !exists("ruby_no_comment_fold")
   53              0.002249   syn region rubyMultilineComment start="\%(\%(^\s*#.*\n\)\@<!\%(^\s*#.*\n\)\)\%(\(^\s*#.*\n\)\{1,}\)\@=" end="\%(^\s*#.*\n\)\@<=\%(^\s*#.*\n\)\%(^\s*#\)\@!" contains=rubyComment transparent fold keepend
   53              0.001995   syn region rubyDocumentation	  start="^=begin\ze\%(\s.*\)\=$" end="^=end\%(\s.*\)\=$" contains=rubySpaceError,rubyTodo,@Spell fold
   53              0.000109 else
                              syn region rubyDocumentation	  start="^=begin\s*$" end="^=end\s*$" contains=rubySpaceError,rubyTodo,@Spell
                            endif
                            
                            " Note: this is a hack to prevent 'keywords' being highlighted as such when called as methods with an explicit receiver
   53              0.001490 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(alias\|and\|begin\|break\|case\|class\|def\|defined\|do\|else\)\>"		  transparent contains=NONE
   53              0.001528 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(elsif\|end\|ensure\|false\|for\|if\|in\|module\|next\|nil\)\>"		  transparent contains=NONE
   53              0.001963 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(not\|or\|redo\|rescue\|retry\|return\|self\|super\|then\|true\)\>"		  transparent contains=NONE
   53              0.001590 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(undef\|unless\|until\|when\|while\|yield\|BEGIN\|END\|__FILE__\|__LINE__\)\>" transparent contains=NONE
                            
   53              0.001492 syn match rubyKeywordAsMethod "\<\%(alias\|begin\|case\|class\|def\|do\|end\)[?!]" transparent contains=NONE
   53              0.001647 syn match rubyKeywordAsMethod "\<\%(if\|module\|undef\|unless\|until\|while\)[?!]" transparent contains=NONE
                            
   53              0.001498 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(abort\|at_exit\|attr\|attr_accessor\|attr_reader\)\>"	transparent contains=NONE
   53              0.001415 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(attr_writer\|autoload\|callcc\|catch\|caller\)\>"		transparent contains=NONE
   53              0.001486 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(eval\|class_eval\|instance_eval\|module_eval\|exit\)\>"	transparent contains=NONE
   53              0.001434 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(extend\|fail\|fork\|include\|lambda\)\>"			transparent contains=NONE
   53              0.001532 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(load\|loop\|prepend\|private\|proc\|protected\)\>"		transparent contains=NONE
   53              0.001429 syn match rubyKeywordAsMethod "\%(\%(\.\@<!\.\)\|::\)\_s*\%(public\|require\|require_relative\|raise\|throw\|trap\)\>"	transparent contains=NONE
                            
                            " __END__ Directive
   53              0.000976 syn region rubyData matchgroup=rubyDataDirective start="^__END__$" end="\%$" fold
                            
   53              0.001203 hi def link rubyClass			rubyDefine
   53              0.000973 hi def link rubyModule			rubyDefine
   53              0.000975 hi def link rubyMethodExceptional	rubyDefine
   53              0.001293 hi def link rubyDefine			Define
   53              0.001057 hi def link rubyFunction		Function
   53              0.000950 hi def link rubyConditional		Conditional
   53              0.000585 hi def link rubyConditionalModifier	rubyConditional
   53              0.000563 hi def link rubyExceptional		rubyConditional
   53              0.000880 hi def link rubyRepeat			Repeat
   53              0.000537 hi def link rubyRepeatModifier		rubyRepeat
   53              0.000522 hi def link rubyOptionalDo		rubyRepeat
   53              0.001259 hi def link rubyControl			Statement
   53              0.000916 hi def link rubyInclude			Include
   53              0.000923 hi def link rubyInteger			Number
   53              0.000919 hi def link rubyASCIICode		Character
   53              0.000965 hi def link rubyFloat			Float
   53              0.001020 hi def link rubyBoolean			Boolean
   53              0.001141 hi def link rubyException		Exception
   53              0.000347 if !exists("ruby_no_identifiers")
   53              0.000988   hi def link rubyIdentifier		Identifier
   53              0.000237 else
                              hi def link rubyIdentifier		NONE
                            endif
   53              0.000603 hi def link rubyClassVariable		rubyIdentifier
   53              0.000960 hi def link rubyConstant		Type
   53              0.000578 hi def link rubyGlobalVariable		rubyIdentifier
   53              0.000524 hi def link rubyBlockParameter		rubyIdentifier
   53              0.000533 hi def link rubyInstanceVariable	rubyIdentifier
   53              0.000517 hi def link rubyPredefinedIdentifier	rubyIdentifier
   53              0.000526 hi def link rubyPredefinedConstant	rubyPredefinedIdentifier
   53              0.000557 hi def link rubyPredefinedVariable	rubyPredefinedIdentifier
   53              0.000944 hi def link rubySymbol			Constant
   53              0.000944 hi def link rubyKeyword			Keyword
   53              0.003892 hi def link rubyOperator		Operator
   53              0.000895 hi def link rubyBeginEnd		Statement
   53              0.000883 hi def link rubyAccess			Statement
   53              0.000900 hi def link rubyAttribute		Statement
   53              0.000880 hi def link rubyEval			Statement
   53              0.000951 hi def link rubyPseudoVariable		Constant
                            
   53              0.000983 hi def link rubyComment			Comment
   53              0.000933 hi def link rubyData			Comment
   53              0.000965 hi def link rubyDataDirective		Delimiter
   53              0.000914 hi def link rubyDocumentation		Comment
   53              0.001032 hi def link rubyTodo			Todo
                            
   53              0.000579 hi def link rubyQuoteEscape		rubyStringEscape
   53              0.000888 hi def link rubyStringEscape		Special
   53              0.000950 hi def link rubyInterpolationDelimiter	Delimiter
   53              0.000589 hi def link rubyNoInterpolation		rubyString
   53              0.000888 hi def link rubySharpBang		PreProc
   53              0.000657 hi def link rubyRegexpDelimiter		rubyStringDelimiter
   53              0.000671 hi def link rubySymbolDelimiter		rubyStringDelimiter
   53              0.000880 hi def link rubyStringDelimiter		Delimiter
   53              0.000568 hi def link rubyHeredoc			rubyString
   53              0.000950 hi def link rubyString			String
   53              0.000617 hi def link rubyRegexpEscape		rubyRegexpSpecial
   53              0.000601 hi def link rubyRegexpQuantifier	rubyRegexpSpecial
   53              0.000522 hi def link rubyRegexpAnchor		rubyRegexpSpecial
   53              0.000529 hi def link rubyRegexpDot		rubyRegexpCharClass
   53              0.000532 hi def link rubyRegexpCharClass		rubyRegexpSpecial
   53              0.000882 hi def link rubyRegexpSpecial		Special
   53              0.000903 hi def link rubyRegexpComment		Comment
   53              0.002029 hi def link rubyRegexp			rubyString
                            
   53              0.001013 hi def link rubyInvalidVariable		Error
   53              0.000889 hi def link rubyError			Error
   53              0.000543 hi def link rubySpaceError		rubyError
                            
   53              0.000624 let b:current_syntax = "ruby"
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet:

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/syntax/haml.vim
Sourced 43 times
Total time:   0.001893
 Self time:   0.001893

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Haml
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:	*.haml
                            " Last Change:	2010 Aug 09
                            
   43              0.000999 if exists("b:current_syntax")
   43              0.000209   finish

SCRIPT  /Users/Jack/.vim/plugged/vim-haml/indent/haml.vim
Sourced 43 times
Total time:   2.572633
 Self time:   2.564825

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Haml
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:	2016 Aug 29
                            
   43              0.001586 if exists("b:did_indent")
                              finish
                            endif
   43              1.801471 runtime! indent/ruby.vim
   43              0.000418 unlet! b:did_indent
   43              0.000344 let b:did_indent = 1
                            
   43              0.001604 setlocal autoindent sw=2 et
   43              0.000434 setlocal indentexpr=GetHamlIndent()
   43              0.000410 setlocal indentkeys=o,O,*<Return>,},],0),!^F,=end,=else,=elsif,=rescue,=ensure,=when
                            
                            " Only define the function once.
   43              0.000420 if exists("*GetHamlIndent")
   43              0.000121   finish

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/indent/ruby.vim
Sourced 53 times
Total time:   0.007854
 Self time:   0.007854

count  total (s)   self (s)
                            " Vim indent file
                            " Language:		Ruby
                            " Maintainer:		Nikolai Weibull <now at bitwi.se>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            
                            " 0. Initialization {{{1
                            " =================
                            
                            " Only load this indent file when no other was loaded.
   53              0.001760 if exists("b:did_indent")
                              finish
                            endif
   53              0.000544 let b:did_indent = 1
                            
   53              0.001168 setlocal nosmartindent
                            
                            " Now, set up our indentation expression and keys that trigger it.
   53              0.000594 setlocal indentexpr=GetRubyIndent(v:lnum)
   53              0.000485 setlocal indentkeys=0{,0},0),0],!^F,o,O,e
   53              0.000468 setlocal indentkeys+==end,=else,=elsif,=when,=ensure,=rescue,==begin,==end
                            
                            " Only define the function once.
   53              0.000788 if exists("*GetRubyIndent")
   53              0.000191   finish

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/indent/haml.vim
Sourced 43 times
Total time:   0.002216
 Self time:   0.002216

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Haml
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:	2013 May 30
                            
   43              0.001411 if exists("b:did_indent")
   43              0.000232   finish

SCRIPT  /Users/Jack/.vim/plugged/vim-haml/ftplugin/haml.vim
Sourced 43 times
Total time:   5.401472
 Self time:   2.023974

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Haml
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:	2016 Aug 29
                            
                            " Only do this when not done yet for this buffer
   43              0.001198 if exists("b:did_ftplugin")
                              finish
                            endif
                            
   43              0.000721 let s:save_cpo = &cpo
   43              0.000743 set cpo-=C
                            
                            " Define some defaults in case the included ftplugins don't set them.
   43              0.000237 let s:undo_ftplugin = ""
   43              0.000509 let s:browsefilter = "All Files (*.*)\t*.*\n"
   43              0.000337 let s:match_words = ""
                            
   43              0.653316 runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
   43              0.000661 unlet! b:did_ftplugin
   43              0.000561 set matchpairs-=<:>
                            
                            " Override our defaults if these were set by an included ftplugin.
   43              0.000455 if exists("b:undo_ftplugin")
   43              0.000320   let s:undo_ftplugin = b:undo_ftplugin
   43              0.000139   unlet b:undo_ftplugin
   43              0.000081 endif
   43              0.000201 if exists("b:browsefilter")
                              let s:browsefilter = b:browsefilter
                              unlet b:browsefilter
                            endif
   43              0.000199 if exists("b:match_words")
   43              0.000207   let s:match_words = b:match_words
   43              0.000116   unlet b:match_words
   43              0.000068 endif
                            
   43              0.066616 runtime! ftplugin/ruby.vim ftplugin/ruby_*.vim ftplugin/ruby/*.vim
   43              0.000536 let b:did_ftplugin = 1
                            
                            " Combine the new set of values with those previously included.
   43              0.000323 if exists("b:undo_ftplugin")
   43              0.000431   let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin
   43              0.000091 endif
   43              0.000194 if exists ("b:browsefilter")
                              let s:browsefilter = substitute(b:browsefilter,'\cAll Files (\*\.\*)\t\*\.\*\n','','') . s:browsefilter
                            endif
   43              0.000199 if exists("b:match_words")
   43              0.000293   let s:match_words = b:match_words . ',' . s:match_words
   43              0.000074 endif
                            
                            " Change the browse dialog on Win32 to show mainly Haml-related files
   43              0.000261 if has("gui_win32")
                              let b:browsefilter="Haml Files (*.haml)\t*.haml\nSass Files (*.sass)\t*.sass\n" . s:browsefilter
                            endif
                            
                            " Load the combined list of match_words for matchit.vim
   43              0.000179 if exists("loaded_matchit")
   43              0.000184   let b:match_words = s:match_words
   43              0.000078 endif
                            
   43              0.000532 setlocal comments= commentstring=-#\ %s
                            
   43              0.000272 let b:undo_ftplugin = "setl cms< com< "
                                  \ " | unlet! b:browsefilter b:match_words | " . s:undo_ftplugin
                            
   43              0.000465 let &cpo = s:save_cpo
   43              0.000168 unlet s:save_cpo
                            
                            " vim:set sw=2:

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/ftplugin/html.vim
Sourced 44 times
Total time:   0.022123
 Self time:   0.011860

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	html
                            " Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
                            " Last Changed: 20 Jan 2009
                            " URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin
                            
   44              0.001739 if exists("b:did_ftplugin") | finish | endif
   44              0.000461 let b:did_ftplugin = 1
                            
                            " Make sure the continuation lines below do not cause problems in
                            " compatibility mode.
   44              0.000608 let s:save_cpo = &cpo
   44              0.000888 set cpo-=C
                            
   44              0.000357 setlocal matchpairs+=<:>
   44              0.000294 setlocal commentstring=<!--%s-->
   44              0.000314 setlocal comments=s:<!--,m:\ \ \ \ ,e:-->
                            
   44              0.000462 if exists("g:ft_html_autocomment") && (g:ft_html_autocomment == 1)
                                setlocal formatoptions-=t formatoptions+=croql
                            endif
                            
   44              0.000219 if exists('&omnifunc')
   44              0.000291   setlocal omnifunc=htmlcomplete#CompleteTags
   44   0.011468   0.001205   call htmlcomplete#DetectOmniFlavor()
   44              0.000125 endif
                            
                            " HTML:  thanks to Johannes Zellner and Benji Fisher.
   44              0.000279 if exists("loaded_matchit")
   44              0.000230     let b:match_ignorecase = 1
   44              0.000703     let b:match_words = '<:>,' .
                                \ '<\@<=[ou]l\>[^>]*\%(>\|$\):<\@<=li\>:<\@<=/[ou]l>,' .
                                \ '<\@<=dl\>[^>]*\%(>\|$\):<\@<=d[td]\>:<\@<=/dl>,' .
                                \ '<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'
   44              0.000088 endif
                            
                            " Change the :browse e filter to primarily show HTML-related files.
   44              0.000339 if has("gui_win32")
                                let  b:browsefilter="HTML Files (*.html,*.htm)\t*.htm;*.html\n" .
                            		\	"JavaScript Files (*.js)\t*.js\n" .
                            		\	"Cascading StyleSheets (*.css)\t*.css\n" .
                            		\	"All Files (*.*)\t*.*\n"
                            endif
                            
                            " Undo the stuff we changed.
   44              0.000436 let b:undo_ftplugin = "setlocal commentstring< matchpairs< omnifunc< comments< formatoptions<" .
                                \	" | unlet! b:match_ignorecase b:match_skip b:match_words b:browsefilter"
                            
                            " Restore the saved compatibility options.
   44              0.000517 let &cpo = s:save_cpo
   44              0.000419 unlet s:save_cpo

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/ftplugin/ruby.vim
Sourced 53 times
Total time:   3.650064
 Self time:   3.643922

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:		Ruby
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:  Doug Kearns <dougkearns@gmail.com>
                            " ----------------------------------------------------------------------------
                            
   53              0.001533 if (exists("b:did_ftplugin"))
                              finish
                            endif
   53              0.000368 let b:did_ftplugin = 1
                            
   53              0.000597 let s:cpo_save = &cpo
   53              0.000608 set cpo&vim
                            
   53              0.000495 if has("gui_running") && !has("gui_win32")
                              setlocal keywordprg=ri\ -T\ -f\ bs
                            else
   53              0.000444   setlocal keywordprg=ri
   53              0.000104 endif
                            
                            " Matchit support
   53              0.000411 if exists("loaded_matchit") && !exists("b:match_words")
   53              0.000251   let b:match_ignorecase = 0
                            
   53              0.001187   let b:match_words =
                            	\ '\<\%(if\|unless\|case\|while\|until\|for\|do\|class\|module\|def\|begin\)\>=\@!' .
                            	\ ':' .
                            	\ '\<\%(else\|elsif\|ensure\|when\|rescue\|break\|redo\|next\|retry\)\>' .
                            	\ ':' .
                            	\ '\<end\>' .
                            	\ ',{:},\[:\],(:)'
                            
   53              0.001032   let b:match_skip =
                            	\ "synIDattr(synID(line('.'),col('.'),0),'name') =~ '" .
                            	\ "\\<ruby\\%(String\\|StringDelimiter\\|ASCIICode\\|Escape\\|" .
                            	\ "Interpolation\\|NoInterpolation\\|Comment\\|Documentation\\|" .
                            	\ "ConditionalModifier\\|RepeatModifier\\|OptionalDo\\|" .
                            	\ "Function\\|BlockArgument\\|KeywordAsMethod\\|ClassVariable\\|" .
                            	\ "InstanceVariable\\|GlobalVariable\\|Symbol\\)\\>'"
   53              0.000094 endif
                            
   53              0.000545 setlocal formatoptions-=t formatoptions+=croql
                            
   53              0.000403 setlocal include=^\\s*\\<\\(load\\>\\\|require\\>\\\|autoload\\s*:\\=[\"']\\=\\h\\w*[\"']\\=,\\)
   53              0.000290 setlocal includeexpr=substitute(substitute(v:fname,'::','/','g'),'$','.rb','')
   53              0.000222 setlocal suffixesadd=.rb
                            
   53              0.000461 if exists("&ofu") && has("ruby")
                              setlocal omnifunc=rubycomplete#Complete
                            endif
                            
                            " To activate, :set ballooneval
   53              0.000308 if has('balloon_eval') && exists('+balloonexpr')
                              setlocal balloonexpr=RubyBalloonexpr()
                            endif
                            
                            
                            " TODO:
                            "setlocal define=^\\s*def
                            
   53              0.000259 setlocal comments=:#
   53              0.000257 setlocal commentstring=#\ %s
                            
   53              0.000346 if !exists('g:ruby_version_paths')
                              let g:ruby_version_paths = {}
                            endif
                            
   53              0.000465 function! s:query_path(root)
                              let code = "print $:.join %q{,}"
                              if &shell =~# 'sh' && $PATH !~# '\s'
                                let prefix = 'env PATH='.$PATH.' '
                              else
                                let prefix = ''
                              endif
                              if &shellxquote == "'"
                                let path_check = prefix.'ruby -e "' . code . '"'
                              else
                                let path_check = prefix."ruby -e '" . code . "'"
                              endif
                            
                              let cd = haslocaldir() ? 'lcd' : 'cd'
                              let cwd = getcwd()
                              try
                                exe cd fnameescape(a:root)
                                let path = split(system(path_check),',')
                                exe cd fnameescape(cwd)
                                return path
                              finally
                                exe cd fnameescape(cwd)
                              endtry
                            endfunction
                            
   53              0.000256 function! s:build_path(path)
                              let path = join(map(copy(a:path), 'v:val ==# "." ? "" : v:val'), ',')
                              if &g:path !~# '\v^\.%(,/%(usr|emx)/include)=,,$'
                                let path = substitute(&g:path,',,$',',','') . ',' . path
                              endif
                              return path
                            endfunction
                            
   53              0.003936 if !exists('b:ruby_version') && !exists('g:ruby_path') && isdirectory(expand('%:p:h'))
   53              2.849700   let s:version_file = findfile('.ruby-version', '.;')
   53              0.000999   if !empty(s:version_file)
                                let b:ruby_version = get(readfile(s:version_file, '', 1), '')
                                if !has_key(g:ruby_version_paths, b:ruby_version)
                                  let g:ruby_version_paths[b:ruby_version] = s:query_path(fnamemodify(s:version_file, ':p:h'))
                                endif
                              endif
   53              0.000130 endif
                            
   53              0.000389 if exists("g:ruby_path")
                              let s:ruby_path = type(g:ruby_path) == type([]) ? join(g:ruby_path, ',') : g:ruby_path
                            elseif has_key(g:ruby_version_paths, get(b:, 'ruby_version', ''))
                              let s:ruby_paths = g:ruby_version_paths[b:ruby_version]
                              let s:ruby_path = s:build_path(s:ruby_paths)
                            else
   53              0.000367   if !exists('g:ruby_default_path')
                                if has("ruby") && has("win32")
                                  ruby ::VIM::command( 'let g:ruby_default_path = split("%s",",")' % $:.join(%q{,}) )
                                elseif executable('ruby')
                                  let g:ruby_default_path = s:query_path($HOME)
                                else
                                  let g:ruby_default_path = map(split($RUBYLIB,':'), 'v:val ==# "." ? "" : v:val')
                                endif
                              endif
   53              0.000269   let s:ruby_paths = g:ruby_default_path
   53   0.007922   0.001780   let s:ruby_path = s:build_path(s:ruby_paths)
   53              0.000310 endif
                            
   53              0.000663 if stridx(&l:path, s:ruby_path) == -1
   53              0.000642   let &l:path = s:ruby_path
   53              0.000130 endif
   53              0.002539 if exists('s:ruby_paths') && stridx(&l:tags, join(map(copy(s:ruby_paths),'v:val."/tags"'),',')) == -1
   21              0.149101   let &l:tags = &tags . ',' . join(map(copy(s:ruby_paths),'v:val."/tags"'),',')
   21              0.000081 endif
                            
   53              0.000732 if has("gui_win32") && !exists("b:browsefilter")
                              let b:browsefilter = "Ruby Source Files (*.rb)\t*.rb\n" .
                                                 \ "All Files (*.*)\t*.*\n"
                            endif
                            
   53              0.001322 let b:undo_ftplugin = "setl fo< inc< inex< sua< def< com< cms< path< tags< kp<"
                                  \."| unlet! b:browsefilter b:match_ignorecase b:match_words b:match_skip"
                                  \."| if exists('&ofu') && has('ruby') | setl ofu< | endif"
                                  \."| if has('balloon_eval') && exists('+bexpr') | setl bexpr< | endif"
                            
   53              0.000592 if !exists("g:no_plugin_maps") && !exists("g:no_ruby_maps")
   53              0.002897   nnoremap <silent> <buffer> [m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','b','n')<CR>
   53              0.001239   nnoremap <silent> <buffer> ]m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','','n')<CR>
   53              0.001027   nnoremap <silent> <buffer> [M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','b','n')<CR>
   53              0.000920   nnoremap <silent> <buffer> ]M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','','n')<CR>
   53              0.000993   xnoremap <silent> <buffer> [m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','b','v')<CR>
   53              0.000898   xnoremap <silent> <buffer> ]m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','','v')<CR>
   53              0.000972   xnoremap <silent> <buffer> [M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','b','v')<CR>
   53              0.000981   xnoremap <silent> <buffer> ]M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','','v')<CR>
                            
   53              0.001321   nnoremap <silent> <buffer> [[ :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','b','n')<CR>
   53              0.001149   nnoremap <silent> <buffer> ]] :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','','n')<CR>
   53              0.001219   nnoremap <silent> <buffer> [] :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','b','n')<CR>
   53              0.001070   nnoremap <silent> <buffer> ][ :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','','n')<CR>
   53              0.001221   xnoremap <silent> <buffer> [[ :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','b','v')<CR>
   53              0.001110   xnoremap <silent> <buffer> ]] :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','','v')<CR>
   53              0.001076   xnoremap <silent> <buffer> [] :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','b','v')<CR>
   53              0.000983   xnoremap <silent> <buffer> ][ :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','','v')<CR>
                            
   53              0.000907   let b:undo_ftplugin = b:undo_ftplugin
                                    \."| sil! exe 'unmap <buffer> [[' | sil! exe 'unmap <buffer> ]]' | sil! exe 'unmap <buffer> []' | sil! exe 'unmap <buffer> ]['"
                                    \."| sil! exe 'unmap <buffer> [m' | sil! exe 'unmap <buffer> ]m' | sil! exe 'unmap <buffer> [M' | sil! exe 'unmap <buffer> ]M'"
                            
   53              0.001334   if maparg('im','n') == ''
   53              0.000989     onoremap <silent> <buffer> im :<C-U>call <SID>wrap_i('[m',']M')<CR>
   53              0.000889     onoremap <silent> <buffer> am :<C-U>call <SID>wrap_a('[m',']M')<CR>
   53              0.000750     xnoremap <silent> <buffer> im :<C-U>call <SID>wrap_i('[m',']M')<CR>
   53              0.000710     xnoremap <silent> <buffer> am :<C-U>call <SID>wrap_a('[m',']M')<CR>
   53              0.000778     let b:undo_ftplugin = b:undo_ftplugin
                                      \."| sil! exe 'ounmap <buffer> im' | sil! exe 'ounmap <buffer> am'"
                                      \."| sil! exe 'xunmap <buffer> im' | sil! exe 'xunmap <buffer> am'"
   53              0.000121   endif
                            
   53              0.000824   if maparg('iM','n') == ''
   53              0.000891     onoremap <silent> <buffer> iM :<C-U>call <SID>wrap_i('[[','][')<CR>
   53              0.000820     onoremap <silent> <buffer> aM :<C-U>call <SID>wrap_a('[[','][')<CR>
   53              0.000725     xnoremap <silent> <buffer> iM :<C-U>call <SID>wrap_i('[[','][')<CR>
   53              0.000713     xnoremap <silent> <buffer> aM :<C-U>call <SID>wrap_a('[[','][')<CR>
   53              0.000669     let b:undo_ftplugin = b:undo_ftplugin
                                      \."| sil! exe 'ounmap <buffer> iM' | sil! exe 'ounmap <buffer> aM'"
                                      \."| sil! exe 'xunmap <buffer> iM' | sil! exe 'xunmap <buffer> aM'"
   53              0.000111   endif
                            
   53              0.000773   if maparg("\<C-]>",'n') == ''
   21              0.000357     nnoremap <silent> <buffer> <C-]>       :<C-U>exe  v:count1."tag <C-R>=RubyCursorIdentifier()<CR>"<CR>
   21              0.000334     nnoremap <silent> <buffer> g<C-]>      :<C-U>exe         "tjump <C-R>=RubyCursorIdentifier()<CR>"<CR>
   21              0.000319     nnoremap <silent> <buffer> g]          :<C-U>exe       "tselect <C-R>=RubyCursorIdentifier()<CR>"<CR>
   21              0.001289     nnoremap <silent> <buffer> <C-W>]      :<C-U>exe v:count1."stag <C-R>=RubyCursorIdentifier()<CR>"<CR>
   21              0.000387     nnoremap <silent> <buffer> <C-W><C-]>  :<C-U>exe v:count1."stag <C-R>=RubyCursorIdentifier()<CR>"<CR>
   21              0.000367     nnoremap <silent> <buffer> <C-W>g<C-]> :<C-U>exe        "stjump <C-R>=RubyCursorIdentifier()<CR>"<CR>
   21              0.000339     nnoremap <silent> <buffer> <C-W>g]     :<C-U>exe      "stselect <C-R>=RubyCursorIdentifier()<CR>"<CR>
   21              0.000319     nnoremap <silent> <buffer> <C-W>}      :<C-U>exe          "ptag <C-R>=RubyCursorIdentifier()<CR>"<CR>
   21              0.000378     nnoremap <silent> <buffer> <C-W>g}     :<C-U>exe        "ptjump <C-R>=RubyCursorIdentifier()<CR>"<CR>
   21              0.000425     let b:undo_ftplugin = b:undo_ftplugin
                                      \."| sil! exe 'nunmap <buffer> <C-]>'| sil! exe 'nunmap <buffer> g<C-]>'| sil! exe 'nunmap <buffer> g]'"
                                      \."| sil! exe 'nunmap <buffer> <C-W>]'| sil! exe 'nunmap <buffer> <C-W><C-]>'"
                                      \."| sil! exe 'nunmap <buffer> <C-W>g<C-]>'| sil! exe 'nunmap <buffer> <C-W>g]'"
                                      \."| sil! exe 'nunmap <buffer> <C-W>}'| sil! exe 'nunmap <buffer> <C-W>g}'"
   21              0.000042   endif
                            
   53              0.000733   if maparg("gf",'n') == ''
                                " By using findfile() rather than gf's normal behavior, we prevent
                                " erroneously editing a directory.
    7              0.000109     nnoremap <silent> <buffer> gf         :<C-U>exe <SID>gf(v:count1,"gf",'edit')<CR>
    7              0.000121     nnoremap <silent> <buffer> <C-W>f     :<C-U>exe <SID>gf(v:count1,"\<Lt>C-W>f",'split')<CR>
    7              0.000158     nnoremap <silent> <buffer> <C-W><C-F> :<C-U>exe <SID>gf(v:count1,"\<Lt>C-W>\<Lt>C-F>",'split')<CR>
    7              0.000118     nnoremap <silent> <buffer> <C-W>gf    :<C-U>exe <SID>gf(v:count1,"\<Lt>C-W>gf",'tabedit')<CR>
    7              0.000094     let b:undo_ftplugin = b:undo_ftplugin
                                      \."| sil! exe 'nunmap <buffer> gf' | sil! exe 'nunmap <buffer> <C-W>f' | sil! exe 'nunmap <buffer> <C-W><C-F>' | sil! exe 'nunmap <buffer> <C-W>gf'"
    7              0.000014   endif
   53              0.000089 endif
                            
   53              0.000897 let &cpo = s:cpo_save
   53              0.000310 unlet s:cpo_save
                            
   53              0.000478 if exists("g:did_ruby_ftplugin_functions")
   53              0.000153   finish

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/ftplugin/haml.vim
Sourced 43 times
Total time:   0.001175
 Self time:   0.001175

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Haml
                            " Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:	2013 Jun 01
                            
                            " Only do this when not done yet for this buffer
   43              0.000601 if exists("b:did_ftplugin")
   43              0.000140   finish

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/scripts.vim
Sourced 15 times
Total time:   0.024410
 Self time:   0.024410

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2014 Aug 24
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
   15              0.000312 if did_filetype()
                              finish
                            endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
   15              0.000200 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
                            endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
   15              0.000341 let s:cpo_save = &cpo
   15              0.000265 set cpo&vim
                            
   15              0.000133 let s:line1 = getline(1)
                            
   15              0.000221 if s:line1 =~ "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env VAR=val bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              if s:line1 =~ '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~ '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~ '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~ '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~ '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~ '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~ '^csh\>'
                                if exists("g:filetype_csh")
                                  call SetFileTypeShell(g:filetype_csh)
                                else
                                  call SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~ '^tcsh\>'
                                call SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~ '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~ '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~ '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~ '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~ 'make\>'
                                set ft=make
                            
                                " Lua
                              elseif s:name =~ 'lua'
                                set ft=lua
                            
                                " Perl 6
                              elseif s:name =~ 'perl6'
                                set ft=perl6
                            
                                " Perl
                              elseif s:name =~ 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~ 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~ 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~ '^groovy\>'
                                set ft=groovy
                            
                                " Ruby
                              elseif s:name =~ 'ruby'
                                set ft=ruby
                            
                                " BC calculator
                              elseif s:name =~ '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~ 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~ 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts
                              elseif s:name =~ 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~ 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~ 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~ 'cfengine'
                                set ft=cfengine
                            
                                " Erlang scripts
                              elseif s:name =~ 'escript'
                                set ft=erlang
                            
                              endif
                              unlet s:name
                            
                            else
                              " File does not start with "#!".
                            
   15              0.000218   let s:line2 = getline(2)
   15              0.000101   let s:line3 = getline(3)
   15              0.000077   let s:line4 = getline(4)
   15              0.000072   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
   15              0.000332   if s:line1 =~ '^:$'
                                call SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " Z shell scripts
                              elseif s:line1 =~ '^#compdef\>' || s:line1 =~ '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~ '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh
                            
                              " ELM Mail files
                              elseif s:line1 =~ '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                                " Mason
                              elseif s:line1 =~ '^<[%&].*>'
                                set ft=mason
                            
                                " Vim scripts (must have '" vim' as the first line to trigger this)
                              elseif s:line1 =~ '^" *[vV]im$'
                                set ft=vim
                            
                                " MOO
                              elseif s:line1 =~ '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                " - "# HG changeset patch" in first line (Mercurial export format)
                              elseif s:line1 =~ '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	\ || (s:line1 =~ '^--- ' && s:line2 =~ '^+++ ')
                            	\ || (s:line1 =~ '^\* looking for ' && s:line2 =~ '^\* comparing to ')
                            	\ || (s:line1 =~ '^\*\*\* ' && s:line2 =~ '^--- ')
                            	\ || (s:line1 =~ '^=== ' && ((s:line2 =~ '^=\{66\}' && s:line3 =~ '^--- ' && s:line4 =~ '^+++') || (s:line2 =~ '^--- ' && s:line3 =~ '^+++ ')))
                            	\ || (s:line1 =~ '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
                              elseif s:line1 =~ '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
                              elseif s:line1 =~ '^\s*dnl\>'
                            	\ || s:line2 =~ '^\s*dnl\>'
                            	\ || s:line3 =~ '^\s*dnl\>'
                            	\ || s:line4 =~ '^\s*dnl\>'
                            	\ || s:line5 =~ '^\s*dnl\>'
                                set ft=m4
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
                              elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
                              elseif s:line1 =~ '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
                              elseif s:line1 =~ '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
                              elseif s:line1 =~ '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                              elseif s:line1 =~? '\<DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
                              elseif s:line1 =~ '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
                              elseif s:line1 =~ '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
                              elseif s:line1 =~ '^RCS file:' || s:line2 =~ '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
                              elseif s:line2 =~ '^CVS:' || getline("$") =~ '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
                              elseif s:line1 =~ '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
                              elseif s:line1 =~ '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
                              elseif s:line1 =~ '^SNNS network definition file'
                                set ft=snnsnet
                              elseif s:line1 =~ '^SNNS pattern definition file'
                                set ft=snnspat
                              elseif s:line1 =~ '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
                              elseif s:line1 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~ '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
                              elseif s:line1 =~ '^\(\[pid \d\+\] \)\=[0-9:.]* *execve(' || s:line1 =~ '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
                              elseif s:line1 =~ '^\* $$ JOB\>' || s:line1 =~ '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
                              elseif s:line4 =~ 'K & K  Associates' || s:line2 =~ 'TAK 2000'
                                set ft=takout
                              elseif s:line3 =~ 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
                              elseif getline(6) =~ 'Run Date: '
                                set ft=takcmp
                              elseif getline(9) =~ 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
                              elseif s:line1.s:line2.s:line3.s:line4 =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
                              elseif s:line1 =~ '|\*\{1,80}' && s:line2 =~ 'VRC '
                            	\ || s:line2 =~ '|\*\{1,80}' && s:line3 =~ 'VRC '
                                set ft=baan
                            
                              " Valgrind
                              elseif s:line1 =~ '^==\d\+== valgrind' || s:line3 =~ '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Go docs
                              elseif s:line1 =~ '^PACKAGE DOCUMENTATION$'
                                set ft=godoc
                            
                              " Renderman Interface Bytestream
                              elseif s:line1 =~ '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
                              elseif s:line1 =~ 'exec\s\+\S*scheme' || s:line2 =~ 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " Git output
                              elseif s:line1 =~ '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                               " Gprof (gnu profiler)
                               elseif s:line1 == 'Flat profile:'
                                 \ && s:line2 == ''
                                 \ && s:line3 =~ '^Each sample counts as .* seconds.$'
                                 set ft=gprof
                            
                              " Erlang terms
                              " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
                              elseif s:line1 =~? '-\*-.*erlang.*-\*-'
                                set ft=erlang
                            
                              " CVS diff
                              else
   15              0.000216     let s:lnum = 1
   15              0.000183     while getline(s:lnum) =~ "^? " && s:lnum < line("$")
                                  let s:lnum += 1
                                endwhile
   15              0.000135     if getline(s:lnum) =~ '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
                                elseif expand("%") =~ '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~ '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
                                endif
   15              0.000053     unlet s:lnum
                            
   15              0.000025   endif
                            
   15              0.000068   unlet s:line2 s:line3 s:line4 s:line5
                            
   15              0.000023 endif
                            
                            " Restore 'cpoptions'
   15              0.000222 let &cpo = s:cpo_save
                            
   15              0.000120 unlet s:cpo_save s:line1

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/indent/vim.vim
Sourced 2 times
Total time:   0.000274
 Self time:   0.000274

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2014 Dec 12
                            
                            " Only load this indent file when no other was loaded.
    2              0.000059 if exists("b:did_indent")
                              finish
                            endif
    2              0.000020 let b:did_indent = 1
                            
    2              0.000037 setlocal indentexpr=GetVimIndent()
    2              0.000024 setlocal indentkeys+==end,=else,=cat,=fina,=END,0\\
                            
    2              0.000014 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    2              0.000017 if exists("*GetVimIndent")
    2              0.000007   finish

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/ftplugin/vim.vim
Sourced 2 times
Total time:   0.001045
 Self time:   0.001045

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Vim
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2014 Sep 07
                            
                            " Only do this when not done yet for this buffer
    2              0.000063 if exists("b:did_ftplugin")
                              finish
                            endif
                            
                            " Don't load another plugin for this buffer
    2              0.000015 let b:did_ftplugin = 1
                            
    2              0.000023 let s:cpo_save = &cpo
    2              0.000034 set cpo-=C
                            
    2              0.000018 let b:undo_ftplugin = "setl fo< isk< com< tw< commentstring<"
                            	\ . "| unlet! b:match_ignorecase b:match_words b:match_skip"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    2              0.000027 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    2              0.000145 setlocal isk+=#
                            
                            " Set 'comments' to format dashed lists in comments
    2              0.000018 setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
                            
                            " Format comments to be up to 78 characters long
    2              0.000014 if &tw == 0
    2              0.000046   setlocal tw=78
    2              0.000006 endif
                            
                            " Comments start with a double quote
    2              0.000011 setlocal commentstring=\"%s
                            
                            " Move around functions.
    2              0.000069 nnoremap <silent><buffer> [[ m':call search('^\s*fu\%[nction]\>', "bW")<CR>
    2              0.000042 vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "bW")<CR>
    2              0.000028 nnoremap <silent><buffer> ]] m':call search('^\s*fu\%[nction]\>', "W")<CR>
    2              0.000032 vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "W")<CR>
    2              0.000027 nnoremap <silent><buffer> [] m':call search('^\s*endf*\%[unction]\>', "bW")<CR>
    2              0.000034 vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "bW")<CR>
    2              0.000026 nnoremap <silent><buffer> ][ m':call search('^\s*endf*\%[unction]\>', "W")<CR>
    2              0.000032 vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "W")<CR>
                            
                            " Move around comments
    2              0.000027 nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    2              0.000035 vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    2              0.000033 nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    2              0.000033 vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
                            
                            " Let the matchit plugin know what items can be matched.
    2              0.000013 if exists("loaded_matchit")
    2              0.000010   let b:match_ignorecase = 0
    2              0.000042   let b:match_words =
                            	\ '\<fu\%[nction]\>:\<retu\%[rn]\>:\<endf\%[unction]\>,' .
                             	\ '\<\(wh\%[ile]\|for\)\>:\<brea\%[k]\>:\<con\%[tinue]\>:\<end\(w\%[hile]\|fo\%[r]\)\>,' .
                            	\ '\<if\>:\<el\%[seif]\>:\<en\%[dif]\>,' .
                            	\ '\<try\>:\<cat\%[ch]\>:\<fina\%[lly]\>:\<endt\%[ry]\>,' .
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,' .
                            	\ '(:)'
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ â¦
    2              0.000013   let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
                                    \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
    2              0.000003 endif
                            
    2              0.000020 let &cpo = s:cpo_save
    2              0.000008 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/syntax/vim.vim
Sourced 2 times
Total time:   0.052776
 Self time:   0.045958

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Vim 7.4 script
                            " Maintainer:	Charles E. Campbell <NdrOchipS@PcampbellAfamily.Mbiz>
                            " Last Change:	Apr 02, 2015
                            " Version:	7.4-33
                            " Automatically generated keyword lists: {{{1
                            
                            " Quit when a syntax file was already loaded {{{2
    2              0.000136 if exists("b:current_syntax")
                              finish
                            endif
    2              0.000071 let s:keepcpo= &cpo
    2              0.000046 set cpo&vim
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    2              0.000143 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    2              0.000066 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " Special and plugin vim commands {{{2
    2              0.000159 syn match   vimCommand contained	"\<z[-+^.=]\="
    2              0.000101 syn keyword vimOnlyCommand contained	fix[del] op[en] sh[ell] P[rint]
    2              0.000040 syn keyword vimStdPlugin contained	DiffOrig Man N[ext] S TOhtml XMLent XMLns
                            
                            " Vim-specific options {{{2
    2              0.000132 syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert
                            
                            " Turn-off setting variants
    2              0.000065 syn keyword vimOnlyOption contained	nobiosk nobioskey noconsk noconskey nocp nocompatible noguipty nomacatsui nosn noshortname nota notextauto notx notextmode notf nottyfast notbi nottybuiltin nowiv noweirdinvert
                            
                            " Invertible setting variants
    2              0.000049 syn keyword vimOnlyOption contained	invbiosk invbioskey invconsk invconskey invcp invcompatible invguipty invmacatsui invsn invshortname invta invtextauto invtx invtextmode invtf invttyfast invtbi invttybuiltin invwiv invweirdinvert
                            " termcap codes (which can also be set) {{{2
    2              0.000556 syn keyword vimTermOption contained	t_AB t_al t_bc t_ce t_cl t_Co t_Cs t_CS t_CV t_da t_db t_dl t_DL t_EI t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_te t_ti t_ts t_u7 t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xs t_ZH t_ZR
    2              0.000035 syn keyword vimTermOption contained	t_AF t_AL t_cd t_Ce t_cm t_cs 
    2              0.000045 syn match   vimTermOption contained	"t_%1"
    2              0.000033 syn match   vimTermOption contained	"t_#2"
    2              0.000026 syn match   vimTermOption contained	"t_#4"
    2              0.000026 syn match   vimTermOption contained	"t_@7"
    2              0.000026 syn match   vimTermOption contained	"t_*7"
    2              0.000025 syn match   vimTermOption contained	"t_&8"
    2              0.000025 syn match   vimTermOption contained	"t_%i"
    2              0.000025 syn match   vimTermOption contained	"t_k;"
                            
                            " unsupported settings: these are supported by vi but don't do anything in vim {{{2
    2              0.000025 syn keyword vimErrSetting contained	hardtabs ht w1200 w300 w9600 
                            "}}}2
    2              0.000007 syn case ignore
                            " Highlight commonly used Groupnames {{{2
    2              0.000134 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo 
                            
                            " Default highlighting groups {{{2
    2              0.000152 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual WarningMsg WildMenu
    2              0.000032 syn match vimHLGroup contained	"Conceal"
    2              0.000025 syn keyword vimOnlyHLGroup contained	VisualNOS
    2              0.000029 syn keyword nvimHLGroup contained	EndOfBuffer TermCursor TermCursorNC
                            "}}}2
    2              0.000007 syn case match
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " commands not picked up by the generator (due to non-standard format)
    2              0.000054 syn keyword vimCommand contained	py3
                            
                            " Deprecated variable options {{{2
    2              0.000024 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
                            endif
    2              0.000022 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
                            endif
    2              0.000012 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
                            endif
                            
                            " Numbers {{{2
                            " =======
    2              0.000241 syn match vimNumber	"\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=" skipwhite nextgroup=vimGlobal,vimSubst,vimCommand
    2              0.000201 syn match vimNumber	"-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\="  skipwhite nextgroup=vimGlobal,vimSubst,vimCommand
    2              0.000037 syn match vimNumber	"\<0[xX]\x\+"
    2              0.000044 syn match vimNumber	"\%(^\|[^a-zA-Z]\)\zs#\x\{6}"
                            
                            " All vimCommands are contained by vimIsCommands. {{{2
    2              0.000599 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=vimAddress,vimAutoCmd,vimCommand,vimIsCommand,vimExtCmd,vimFilter,vimLet,vimMap,vimMark,vimSet,vimSyntax,vimUserCmd,vimOnlyCommand
    2              0.000184 syn match vimIsCommand	"\<\h\w*\>"	contains=vimCommand,vimOnlyCommand
    2              0.000074 syn match vimVar        contained	"\<\h[a-zA-Z0-9#_]*\>"
    2              0.000087 syn match vimVar		"\<[bwglsav]:\h[a-zA-Z0-9#_]*\>"
    2              0.000040 syn match vimFBVar      contained   "\<[bwglsav]:\h[a-zA-Z0-9#_]*\>"
    2              0.000058 syn keyword vimCommand  contained	in
                            
                            " Insertions And Appends: insert append {{{2
                            " =======================
    2              0.000187 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"	matchgroup=vimCommand end="^\.$""
    2              0.000158 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"	matchgroup=vimCommand end="^\.$""
    2              0.000170 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"	matchgroup=vimCommand end="^\.$""
                            
                            " Behave! {{{2
                            " =======
    2              0.000101 syn match   vimBehave	"\<be\%[have]\>" skipwhite nextgroup=vimBehaveModel,vimBehaveError
    2              0.000026 syn keyword vimBehaveModel contained	mswin	xterm
    2              0.000028 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    2              0.000050  syn match   vimBehaveError contained	"[^ ]\+"
    2              0.000007 endif
                            
                            " Filetypes {{{2
                            " =========
    2              0.000149 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    2              0.000022 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    2              0.000026  syn match   vimFTError  contained	"\I\i*"
    2              0.000005 endif
    2              0.000022 syn keyword vimFTCmd    contained	filet[ype]
    2              0.000039 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    2              0.000792 syn cluster vimAugroupList	contains=vimAugroup,vimIsCommand,vimCommand,vimUserCmd,vimExecute,vimNotFunc,vimFuncName,vimFunction,vimFunctionError,vimLineComment,vimMap,vimSpecFile,vimOper,vimNumber,vimOperParen,vimComment,vimString,vimSubst,vimMark,vimRegister,vimAddress,vimFilter,vimCmplxRepeat,vimComment,vimLet,vimSet,vimAutoCmd,vimRegion,vimSynLine,vimNotation,vimCtrlChar,vimFuncVar,vimContinue
    2              0.000016 if exists("g:vimsyn_folding") && g:vimsyn_folding =~ 'a'
                             syn region  vimAugroup	fold matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
                            else
    2              0.000072  syn region  vimAugroup	matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
    2              0.000005 endif
    2              0.000041 syn match   vimAugroup	"aug\%[roup]!"	contains=vimAugroupKey
    2              0.000018 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    2              0.000035  syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    2              0.000005 endif
    2              0.000033 syn keyword vimAugroupKey contained	aug[roup]
                            
                            " Operators: {{{2
                            " =========
    2              0.000226 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimRegister,vimContinue
    2              0.000100 syn match	vimOper	"\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    2              0.000063 syn match	vimOper	"||\|&&\|[-+.]"	skipwhite nextgroup=vimString,vimSpecFile
    2              0.000037 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=@vimOperGroup
    2              0.000121 syn region	vimOperParen	matchgroup=vimSep	start="{" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    2              0.000018 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    2              0.000035  syn match	vimOperError	")"
    2              0.000005 endif
                            
                            " Functions : Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    2              0.000306 syn cluster	vimFuncList	contains=vimCommand,vimFunctionError,vimFuncKey,Tag,vimFuncSID
    2              0.001060 syn cluster	vimFuncBodyList	contains=vimAbb,vimAddress,vimAugroupKey,vimAutoCmd,vimCmplxRepeat,vimComment,vimComment,vimContinue,vimCtrlChar,vimEcho,vimEchoHL,vimExecute,vimIf,vimIsCommand,vimFBVar,vimFunc,vimFunction,vimFuncVar,vimGlobal,vimHighlight,vimIsCommand,vimLet,vimLineComment,vimMap,vimMark,vimNorm,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegion,vimRegister,vimSet,vimSpecFile,vimString,vimSubst,vimSynLine,vimUnmap,vimUserCommand,nvimUnmap,nvimMap
    2              0.000112 syn match	vimFunction	"\<fu\%[nction]!\=\s\+\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)*\ze\s*("	contains=@vimFuncList nextgroup=vimFuncBody
                            
    2              0.000017 if exists("g:vimsyn_folding") && g:vimsyn_folding =~ 'f'
                             syn region	vimFuncBody  contained	fold start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
                            else
    2              0.000072  syn region	vimFuncBody  contained	start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
    2              0.000006 endif
    2              0.000023 syn match	vimFuncVar   contained	"a:\(\K\k*\|\d\+\)"
    2              0.000021 syn match	vimFuncSID   contained	"\c<sid>\|\<s:"
    2              0.000020 syn keyword	vimFuncKey   contained	fu[nction]
    2              0.000019 syn match	vimFuncBlank contained	"\s\+"
                            
    2              0.000017 syn keyword	vimPattern   contained	start	skip	end
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    2              0.000064 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst
    2              0.000064 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst
    2              0.000066 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    2              0.000089 syn match	vimSpecFile	"\s%$"ms=s+1	nextgroup=vimSpecFileMod,vimSubst
    2              0.000064 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    2              0.000065 syn match	vimSpecFile	"#\d\+\|[#%]<\>"	nextgroup=vimSpecFileMod,vimSubst
    2              0.000026 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    2              0.000755 syn cluster	vimUserCmdList	contains=vimAddress,vimSyntax,vimHighlight,vimAutoCmd,vimCmplxRepeat,vimComment,vimCtrlChar,vimEscapeBrace,vimFilter,vimFunc,vimFuncName,vimFunction,vimFunctionError,vimIsCommand,vimMark,vimNotation,vimNumber,vimOper,vimRegion,vimRegister,vimLet,vimSet,vimSetEqual,vimSetString,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange,vimSynLine
    2              0.000021 syn keyword	vimUserCommand	contained	com[mand]
    2              0.000084 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList
    2              0.000022 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    2              0.000059 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    2              0.000092 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    2              0.000080 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    2              0.000076 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    2              0.000060 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    2              0.000054 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    2              0.000061 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    2              0.000069 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    2              0.000020 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    2              0.000021  syn match	vimUserCmdError	contained	"\S\+\>"
    2              0.000004 endif
    2              0.000005 syn case ignore
    2              0.000039 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
    2              0.000070 syn keyword	vimUserAttrbCmplt contained	augroup buffer color command compiler cscope dir environment event expression file file_in_path filetype function help highlight locale mapping menu option shellcmd sign syntax tag tag_listfiles var
    2              0.000057 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    2              0.000056 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%(#\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    2              0.000005 syn case match
    2              0.000020 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    2              0.000111 syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    2              0.000100 syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    2              0.000112 syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
    2              0.000095 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e	end='"'
                            
                            " Environment Variables: {{{2
                            " =====================
    2              0.000027 syn match	vimEnvvar	"\$\I\i*"
    2              0.000024 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    2              0.000044 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    2              0.000027 syn match	vimPatSepErr	contained	"\\)"
    2              0.000028 syn match	vimPatSep	contained	"\\|"
    2              0.000062 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\]['"]"	contains=@vimStringGroup
    2              0.000068 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    2              0.000032 syn match	vimNotPatSep	contained	"\\\\"
    2              0.000098 syn cluster	vimStringGroup	contains=vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    2              0.000054 syn region	vimString	oneline keepend	start=+[^:a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ end=+"+	contains=@vimStringGroup
    2              0.000033 syn region	vimString	oneline keepend	start=+[^:a-zA-Z>!\\@]'+lc=1 end=+'+
    2              0.000032 syn region	vimString	oneline	start=+=!+lc=1	skip=+\\\\\|\\!+ end=+!+	contains=@vimStringGroup
    2              0.000057 syn region	vimString	oneline	start="=+"lc=1	skip="\\\\\|\\+" end="+"	contains=@vimStringGroup
    2              0.000081 syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup
    2              0.000043 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    2              0.000025 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
                            
                            " Substitutions: {{{2
                            " =============
    2              0.000117 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    2              0.000060 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    2              0.000033 syn cluster	vimSubstList	add=vimCollection
    2              0.000066 syn match	vimSubst	"\(:\+\s*\|^\s*\||\s*\)\<\%(s\%[ubstitute]\|sm\%[agic]\|sno\%[magic]\)[:[:alpha:]]\@!" nextgroup=vimSubstPat
    2              0.000045 syn match	vimSubst	"s\%[ubstitute][:#[:alpha:]]\@!"	nextgroup=vimSubstPat contained
    2              0.000042 syn match	vimSubst	"/\zss\%[ubstitute]\ze/"	nextgroup=vimSubstPat
    2              0.000043 syn match	vimSubst1       contained	"s\%[ubstitute]\>"	nextgroup=vimSubstPat
    2              0.000069 syn region	vimSubstPat     contained	matchgroup=vimSubstDelim start="\z([^a-zA-Z( \t[\]&]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	 contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    2              0.000079 syn region	vimSubstRep4    contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>" contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    2              0.000060 syn region	vimCollection   contained transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    2              0.000033 syn match	vimCollClassErr contained	"\[:.\{-\}:\]"
    2              0.000050 syn match	vimCollClass    contained transparent	"\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|return\|tab\|escape\|backspace\):\]"
    2              0.000019 syn match	vimSubstSubstr  contained	"\\z\=\d"
    2              0.000018 syn match	vimSubstTwoBS   contained	"\\\\"
    2              0.000041 syn match	vimSubstFlagErr contained	"[^< \t\r|]\+" contains=vimSubstFlags
    2              0.000025 syn match	vimSubstFlags   contained	"[&cegiIpr]\+"
                            
                            " 'String': {{{2
    2              0.000023 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    2              0.000079 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000079 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000079 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000109 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000115 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000069 syn match	vimMarkNumber	"[-+]\d\+"		nextgroup=vimSubst contained contains=vimOper
    2              0.000028 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
                            
    2              0.000030 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    2              0.000022 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    2              0.000021 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    2              0.000020 syn match	vimRegister	'@"'
    2              0.000019 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
                            
    2              0.000034 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    2              0.000055 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    2              0.000039 syn match	vimFilter contained	"^!.\{-}\(|\|$\)"		contains=vimSpecFile
    2              0.000088 syn match	vimFilter contained	"\A!.\{-}\(|\|$\)"ms=s+1	contains=vimSpecFile,vimFunction,vimFuncName,vimOperParen
                            
                            " Complex repeats (:h complex-repeat) {{{2
    2              0.000023 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    2              0.000023 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    2              0.000302 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\." end="$" matchgroup=vimNotation end="<[cC][rR]>" keepend oneline contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vimSetString,vimSetMod,vimTermOption,vimOnlyOption
    2              0.000115 syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]\|$"me=e-1 contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar oneline
    2              0.000043 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+	contains=vimCtrlChar
    2              0.000068 syn match	vimSetSep	contained	"[,:]" skipwhite nextgroup=vimCommand
    2              0.000030 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let {{{2
                            " ===
    2              0.000092 syn keyword	vimLet	let	unl[et]	skipwhite nextgroup=vimVar,vimFuncVar
                            
                            " Abbreviations {{{2
                            " =============
    2              0.000059 syn keyword vimAbb	ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev] skipwhite nextgroup=vimMapMod,vimMapLhs
                            
                            " Autocmd {{{2
                            " =======
    2              0.000070 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent,nvimAutoEvent nextgroup=vimAutoCmdSpace
    2              0.000028 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    2              0.000066 syn match	vimAutoCmdSfxList	contained	"\S*"
    2              0.000047 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
                            
                            " Echo and Execute -- prefer strings! {{{2
                            " ================
    2              0.000260 syn region	vimEcho	oneline excludenl matchgroup=vimCommand start="\<ec\%[ho]\>" skip="\(\\\\\)*\\|" end="$\||" contains=vimFunc,vimFuncVar,vimString,vimVar
    2              0.000247 syn region	vimExecute	oneline excludenl matchgroup=vimCommand start="\<exe\%[cute]\>" skip="\(\\\\\)*\\|" end="$\||\|<[cC][rR]>" contains=vimFuncVar,vimIsCommand,vimOper,vimNotation,vimOperParen,vimString,vimVar
    2              0.000134 syn match	vimEchoHL	"echohl\="	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchoHLNone,vimOnlyHLGroup,nvimHLGroup
    2              0.000006 syn case ignore
    2              0.000012 syn keyword	vimEchoHLNone	none
    2              0.000004 syn case match
                            
                            " Maps {{{2
                            " ====
    2              0.000045 syn match	vimMap		"\<map\>!\=\ze\s*[^(]" skipwhite nextgroup=vimMapMod,vimMapLhs
    2              0.000107 syn keyword	vimMap		cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    2              0.000056 syn keyword	nvimMap		tn[oremap] tm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    2              0.000016 syn keyword	vimMap		mapc[lear] smapc[lear]
    2              0.000077 syn keyword	vimUnmap		cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] unm[ap] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    2              0.000051 syn keyword	nvimUnmap 		tunm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    2              0.000058 syn match	vimMapLhs	contained	"\S\+"			contains=vimNotation,vimCtrlChar skipwhite nextgroup=vimMapRhs
    2              0.000044 syn match	vimMapBang	contained	"!"			skipwhite nextgroup=vimMapMod,vimMapLhs
    2              0.000090 syn match	vimMapMod	contained	"\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    2              0.000057 syn match	vimMapRhs	contained	".*" contains=vimNotation,vimCtrlChar	skipnl nextgroup=vimMapRhsExtend
    2              0.000034 syn match	vimMapRhsExtend	contained	"^\s*\\.*$"			contains=vimContinue
    2              0.000017 syn case ignore
    2              0.000023 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    2              0.000004 syn case match
                            
                            " Menus {{{2
                            " =====
    2              0.000065 syn cluster	vimMenuList contains=vimMenuBang,vimMenuPriority,vimMenuName,vimMenuMod
    2              0.000091 syn keyword	vimCommand	am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] skipwhite nextgroup=@vimMenuList
    2              0.000060 syn match	vimMenuName	"[^ \t\\<]\+"	contained nextgroup=vimMenuNameMore,vimMenuMap
    2              0.000034 syn match	vimMenuPriority	"\d\+\(\.\d\+\)*"	contained skipwhite nextgroup=vimMenuName
    2              0.000058 syn match	vimMenuNameMore	"\c\\\s\|<tab>\|\\\."	contained nextgroup=vimMenuName,vimMenuNameMore contains=vimNotation
    2              0.000059 syn match	vimMenuMod    contained	"\c<\(script\|silent\)\+>"  skipwhite contains=vimMapModKey,vimMapModErr nextgroup=@vimMenuList
    2              0.000033 syn match	vimMenuMap	"\s"	contained skipwhite nextgroup=vimMenuRhs
    2              0.000112 syn match	vimMenuRhs	".*$"	contained contains=vimString,vimComment,vimIsCommand
    2              0.000053 syn match	vimMenuBang	"!"	contained skipwhite nextgroup=@vimMenuList
                            
                            " Angle-Bracket Notation (tnx to Michael Geddes) {{{2
                            " ======================
    2              0.000008 syn case ignore
    2              0.000195 syn match	vimNotation	"\(\\\|<lt>\)\=<\([scamd]-\)\{0,4}x\=\(f\d\{1,2}\|[^ \t:]\|cr\|lf\|linefeed\|return\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|right\|left\|help\|undo\|insert\|ins\|k\=home\|k\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\(page\)\=\(\|down\|up\|k\d\>\)\)>" contains=vimBracket
    2              0.000091 syn match	vimNotation	"\(\\\|<lt>\)\=<\([scam2-4]-\)\{0,4}\(right\|left\|middle\)\(mouse\)\=\(drag\|release\)\=>"	contains=vimBracket
    2              0.000052 syn match	vimNotation	"\(\\\|<lt>\)\=<\(bslash\|plug\|sid\|space\|bar\|nop\|nul\|lt\)>"		contains=vimBracket
    2              0.000057 syn match	vimNotation	'\(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1			contains=vimBracket
    2              0.000054 syn match	vimNotation	'\(\\\|<lt>\)\=<\%(q-\)\=\(line[12]\|count\|bang\|reg\|args\|f-args\|lt\)>'	contains=vimBracket
    2              0.000051 syn match	vimNotation	"\(\\\|<lt>\)\=<\([cas]file\|abuf\|amatch\|cword\|cWORD\|client\)>"		contains=vimBracket
    2              0.000027 syn match	vimBracket contained	"[\\<>]"
    2              0.000007 syn case match
                            
                            " User Function Highlighting {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    2              0.000205 syn match vimFunc		"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%([a-zA-Z0-9_.]\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("		contains=vimFuncName,vimUserFunc,vimExecute
    2              0.000086 syn match vimUserFunc contained	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%([a-zA-Z0-9_.]\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation
    2              0.000038 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<return\>\|\<while\>"
                            
                            " Errors And Warnings: {{{2
                            " ====================
    2              0.000020 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    2              0.000065  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
                            " syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)[0-9]\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    2              0.000018  syn match	vimElseIfErr	"\<else\s\+if\>"
    2              0.000022  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    2              0.000004 endif
                            
                            " Norm {{{2
                            " ====
    2              0.000033 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    2              0.000015 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax {{{2
                            "=======
    2              0.000051 syn match	vimGroupList	contained	"@\=[^ \t,]*"	contains=vimGroupSpecial,vimPatSep
    2              0.000055 syn match	vimGroupList	contained	"@\=[^ \t,]*,"	nextgroup=vimGroupList contains=vimGroupSpecial,vimPatSep
    2              0.000015 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
    2              0.000014 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    2              0.000018  syn match	vimSynError	contained	"\i\+"
    2              0.000032  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    2              0.000005 endif
    2              0.000046 syn match	vimSynContains	contained	"\<contain\(s\|edin\)="	nextgroup=vimGroupList
    2              0.000040 syn match	vimSynKeyContainedin	contained	"\<containedin="	nextgroup=vimGroupList
    2              0.000031 syn match	vimSynNextgroup	contained	"nextgroup="	nextgroup=vimGroupList
                            
    2              0.000135 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    2              0.000149 syn match	vimAuSyntax	contained	"\s+sy\%[ntax]"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    2              0.000035 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    2              0.000058 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    2              0.000015 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    2              0.000015  syn match	vimSynCaseError	contained	"\i\+"
    2              0.000003 endif
    2              0.000015 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    2              0.000046 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    2              0.000044 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    2              0.000096 syn region	vimClusterName	contained	matchgroup=vimGroupName start="\k\+" skip="\\\\\|\\|" matchgroup=vimSep end="$\||" contains=vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    2              0.000029 syn match	vimGroupAdd	contained	"add="	nextgroup=vimGroupList
    2              0.000122 syn match	vimGroupRem	contained	"remove="	nextgroup=vimGroupList
    2              0.000123 syn cluster vimFuncBodyList add=vimSynType,vimGroupAdd,vimGroupRem
                            
                            " Syntax: include {{{2
    2              0.000106 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
    2              0.000089 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: keyword {{{2
    2              0.000062 syn cluster	vimSynKeyGroup	contains=vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    2              0.000066 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    2              0.000054 syn region	vimSynKeyRegion	contained oneline keepend	matchgroup=vimGroupName start="\k\+" skip="\\\\\|\\|" matchgroup=vimSep end="|\|$" contains=@vimSynKeyGroup
    2              0.000053 syn match	vimSynKeyOpt	contained	"\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
    2              0.000074 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: match {{{2
    2              0.000140 syn cluster	vimSynMtchGroup	contains=vimMtchComment,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation
    2              0.000051 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    2              0.000054 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\k\+" matchgroup=vimSep end="|\|$" contains=@vimSynMtchGroup
    2              0.000068 syn match	vimSynMtchOpt	contained	"\<\(conceal\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
    2              0.000013 if has("conceal")
    2              0.000050  syn match	vimSynMtchOpt	contained	"\<cchar="	nextgroup=vimSynMtchCchar
    2              0.000016  syn match	vimSynMtchCchar	contained	"\S"
    2              0.000003 endif
    2              0.000026 syn cluster vimFuncBodyList add=vimSynMtchGroup
                            
                            " Syntax: off and on {{{2
    2              0.000036 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    2              0.000114 syn cluster	vimSynRegPatGroup	contains=vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    2              0.000065 syn cluster	vimSynRegGroup	contains=vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    2              0.000045 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    2              0.000038 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\k\+" skip="\\\\\|\\|" end="|\|$" contains=@vimSynRegGroup
    2              0.000049 syn match	vimSynRegOpt	contained	"\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    2              0.000040 syn match	vimSynReg	contained	"\(start\|skip\|end\)="he=e-1	nextgroup=vimSynRegPat
    2              0.000129 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup,vimOnlyHLGroup,nvimHLGroup
    2              0.000068 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip="\\\\\|\\\z1"  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    2              0.000033 syn match	vimSynPatMod	contained	"\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    2              0.000037 syn match	vimSynPatMod	contained	"\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    2              0.000015 syn match	vimSynPatMod	contained	"lc=\d\+"
    2              0.000026 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    2              0.000024 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    2              0.000014 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    2              0.000015 syn match	vimMtchComment	contained	'"[^"]\+$'
    2              0.000071 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: sync {{{2
                            " ============
    2              0.000116 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    2              0.000100 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    2              0.000020  syn match	vimSyncError	contained	"\i\+"
    2              0.000003 endif
    2              0.000017 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    2              0.000024 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    2              0.000024 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    2              0.000045 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    2              0.000025 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    2              0.000046 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    2              0.000028 syn match	vimSyncGroupName	contained	"\k\+"	skipwhite	nextgroup=vimSyncKey
    2              0.000040 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    2              0.000038 syn match	vimSyncGroup	contained	"\k\+"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    2              0.000011 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand, here by reasons of precedence {{{2
                            " ====================
    2              0.000103 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting {{{2
                            " ============
    2              0.000096 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,vimComment
    2              0.000015 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    2              0.000016  syn match	vimHiCtermError	contained	"[^0-9]\i*"
    2              0.000003 endif
    2              0.000031 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    2              0.000015 syn match	vimHiBang	contained	"!"	skipwhite nextgroup=@vimHighlightCluster
                            
    2              0.000032 syn match	vimHiGroup	contained	"\i\+"
    2              0.000005 syn case ignore
    2              0.000021 syn keyword	vimHiAttrib	contained	none bold inverse italic reverse standout underline undercurl
    2              0.000015 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    2              0.000004 syn case match
    2              0.000024 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    2              0.000038 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    2              0.000006 syn case ignore
    2              0.000179 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred magenta red white yellow
    2              0.000023 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    2              0.000007 syn case match
    2              0.000018 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    2              0.000020 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    2              0.000016 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    2              0.000211 syn cluster	vimHiCluster contains=vimGroup,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation
    2              0.000032 syn region	vimHiKeyList	contained oneline start="\i\+" skip="\\\\\|\\|" end="$\||"	contains=@vimHiCluster
    2              0.000015 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    2              0.000014  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    2              0.000003 endif
    2              0.000025 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    2              0.000055 syn match	vimHiStartStop	contained	"\c\(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    2              0.000036 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    2              0.000067 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    2              0.000025 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    2              0.000033 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    2              0.000095 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    2              0.000027 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    2              0.000011 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    2              0.000060 syn keyword	vimHiClear	contained	clear	nextgroup=vimHiGroup
                            
                            " Highlight: link {{{2
    2              0.000229 syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation,vimOnlyHLGroup,nvimHLGroup
    2              0.000059 syn cluster vimFuncBodyList add=vimHiLink
                            
                            " Control Characters {{{2
                            " ==================
    2              0.000023 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    2              0.000102 syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    2              0.000052 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    2              0.000015 syn match	vimContinue	"^\s*\\"
    2              0.000054 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    2              0.000014 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    2              0.000026 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    2              0.000028 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    2              0.000068 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst
    2              0.000076 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst
                            
                            " Scripts  : perl,ruby : Benoit Cerrina {{{2
                            " =======    python,tcl: Johannes Zellner
                            "            lua
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed ~= 'P' : embed python   (but only if vim supports it)
    2              0.000011 if !exists("g:vimsyn_embed")
                             let g:vimsyn_embed= "P"
                            endif
                            
                            " [-- lua --] {{{3
    2              0.000078 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    2              0.000890 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
                            endif
                            
    2              0.000053 syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000019 syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
    2              0.000007 unlet s:luapath
                            
                            " [-- perl --] {{{3
    2              0.000057 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    2              0.000646 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
                            endif
                            
    2              0.000043 syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000041 syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
    2              0.000006 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    2              0.000054 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    2              0.000366 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
                            endif
                            
    2              0.000031 syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000027 syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
    2              0.000006 unlet s:rubypath
                            
                            " [-- python --] {{{3
    2              0.000055 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    2              0.000553 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
                            endif
    2              0.000040 if g:vimsyn_embed =~ 'P' && filereadable(s:pythonpath)
    2              0.000007  unlet! b:current_syntax
    2              0.000197  exe "syn include @vimPythonScript ".s:pythonpath
    2              0.000013  if exists("g:vimsyn_folding") && g:vimsyn_folding =~ 'P'
                              syn region vimPythonRegion fold matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimPythonScript
                              syn region vimPythonRegion fold matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+		contains=@vimPythonScript
                             else
    2              0.000035   syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+		contains=@vimPythonScript
    2              0.000039   syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+		contains=@vimPythonScript
    2              0.000004  endif
    2              0.000023  syn cluster vimFuncBodyList	add=vimPythonRegion
    2              0.000003 else
                             syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
                            endif
    2              0.000006 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    2              0.000028 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
                            else
    2              0.000006  let s:trytcl= 1
    2              0.000011 endif
    2              0.000005 if s:trytcl
    2              0.000073  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    2              0.000854  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
                             endif
                            
    2              0.000053  syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000029  syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    2              0.000009  unlet s:tclpath
                            
    2              0.000004 else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
                            endif
    2              0.000006 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    2              0.000086 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    2              0.000513 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
                            endif
                            
    2              0.000049 syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000032 syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    2              0.000009 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    2              0.000020 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
                            endif
    2              0.000008 if exists("g:vimsyn_maxlines")
                             exe "syn sync maxlines=".g:vimsyn_maxlines
                            else
    2              0.000008  syn sync maxlines=60
    2              0.000003 endif
    2              0.000013 syn sync linecont	"^\s\+\\"
    2              0.000033 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
                            
    2              0.000010 if !exists("g:vimsyn_noerror")
    2              0.000023  hi def link vimBehaveError	vimError
    2              0.000018  hi def link vimCollClassErr	vimError
    2              0.000019  hi def link vimErrSetting	vimError
    2              0.000015  hi def link vimEmbedError	vimError
    2              0.000018  hi def link vimFTError	vimError
    2              0.000018  hi def link vimFunctionError	vimError
    2              0.000045  hi def link vimFunc         	vimError
    2              0.000016  hi def link vimHiAttribList	vimError
    2              0.000015  hi def link vimHiCtermError	vimError
    2              0.000015  hi def link vimHiKeyError	vimError
    2              0.000014  hi def link vimKeyCodeError	vimError
    2              0.000016  hi def link vimMapModErr	vimError
    2              0.000017  hi def link vimSubstFlagErr	vimError
    2              0.000019  hi def link vimSynCaseError	vimError
    2              0.000016  hi def link vimBufnrWarn	vimWarn
    2              0.000024  hi def link vimOnlyCommand	vimError
    2              0.000018  hi def link vimTermOption	vimError
    2              0.000018  hi def link vimOnlyOption	vimError
    2              0.000018  hi def link vimOnlyHLGroup	vimError
    2              0.000003 endif
                            
    2              0.000055 hi def link vimAbb	vimCommand
    2              0.000025 hi def link vimAddress	vimMark
    2              0.000048 hi def link vimAugroupKey	vimCommand
    2              0.000017 hi def link vimAuHighlight	vimHighlight
    2              0.000013 hi def link vimAutoCmdOpt	vimOption
    2              0.000038 hi def link vimAutoCmd	vimCommand
    2              0.000037 hi def link vimAutoEvent	Type
    2              0.000019 hi def link nvimAutoEvent	vimAutoEvent
    2              0.000033 hi def link vimAutoSet	vimCommand
    2              0.000019 hi def link vimBehaveModel	vimBehave
    2              0.000035 hi def link vimBehave	vimCommand
    2              0.000035 hi def link vimBracket	Delimiter
    2              0.000037 hi def link vimCmplxRepeat	SpecialChar
    2              0.000055 hi def link vimCommand	Statement
    2              0.000037 hi def link vimComment	Comment
    2              0.000037 hi def link vimCommentString	vimString
    2              0.000034 hi def link vimCommentTitle	PreProc
    2              0.000034 hi def link vimCondHL	vimCommand
    2              0.000037 hi def link vimContinue	Special
    2              0.000037 hi def link vimCtrlChar	SpecialChar
    2              0.000035 hi def link vimEchoHLNone	vimGroup
    2              0.000036 hi def link vimEchoHL	vimCommand
    2              0.000036 hi def link vimElseIfErr	Error
    2              0.000013 hi def link vimElseif	vimCondHL
    2              0.000038 hi def link vimEnvvar	PreProc
    2              0.000035 hi def link vimError	Error
    2              0.000041 hi def link vimFBVar	vimVar
    2              0.000015 hi def link vimFgBgAttrib	vimHiAttrib
    2              0.000034 hi def link vimFold	Folded
    2              0.000037 hi def link vimFTCmd	vimCommand
    2              0.000036 hi def link vimFTOption	vimSynType
    2              0.000036 hi def link vimFuncKey	vimCommand
    2              0.000037 hi def link vimFuncName	Function
    2              0.000037 hi def link vimFuncSID	Special
    2              0.000037 hi def link vimFuncVar	Identifier
    2              0.000014 hi def link vimGroupAdd	vimSynOption
    2              0.000034 hi def link vimGroupName	vimGroup
    2              0.000014 hi def link vimGroupRem	vimSynOption
    2              0.000035 hi def link vimGroupSpecial	Special
    2              0.000055 hi def link vimGroup	Type
    2              0.000035 hi def link vimHiAttrib	PreProc
    2              0.000016 hi def link vimHiClear	vimHighlight
    2              0.000013 hi def link vimHiCtermFgBg	vimHiTerm
    2              0.000013 hi def link vimHiCTerm	vimHiTerm
    2              0.000035 hi def link vimHighlight	vimCommand
    2              0.000035 hi def link vimHiGroup	vimGroupName
    2              0.000013 hi def link vimHiGuiFgBg	vimHiTerm
    2              0.000013 hi def link vimHiGuiFont	vimHiTerm
    2              0.000015 hi def link vimHiGuiRgb	vimNumber
    2              0.000013 hi def link vimHiGui	vimHiTerm
    2              0.000034 hi def link vimHiNmbr	Number
    2              0.000014 hi def link vimHiStartStop	vimHiTerm
    2              0.000034 hi def link vimHiTerm	Type
    2              0.000037 hi def link vimHLGroup	vimGroup
    2              0.000019 hi def link nvimHLGroup	vimHLGroup
    2              0.000033 hi def link vimHLMod	PreProc
    2              0.000020 hi def link vimInsert	vimString
    2              0.000014 hi def link vimKeyCode	vimSpecFile
    2              0.000037 hi def link vimKeyword	Statement
    2              0.000053 hi def link vimLet	vimCommand
    2              0.000019 hi def link vimLineComment	vimComment
    2              0.000034 hi def link vimMapBang	vimCommand
    2              0.000017 hi def link vimMapModKey	vimFuncSID
    2              0.000015 hi def link vimMapMod	vimBracket
    2              0.000035 hi def link vimMap	vimCommand
    2              0.000018 hi def link nvimMap	vimMap
    2              0.000036 hi def link vimMark	Number
    2              0.000018 hi def link vimMarkNumber	vimNumber
    2              0.000015 hi def link vimMenuMod	vimMapMod
    2              0.000015 hi def link vimMenuNameMore	vimMenuName
    2              0.000035 hi def link vimMenuName	PreProc
    2              0.000016 hi def link vimMtchComment	vimComment
    2              0.000035 hi def link vimNorm	vimCommand
    2              0.000037 hi def link vimNotation	Special
    2              0.000036 hi def link vimNotFunc	vimCommand
    2              0.000017 hi def link vimNotPatSep	vimString
    2              0.000036 hi def link vimNumber	Number
    2              0.000037 hi def link vimOperError	Error
    2              0.000037 hi def link vimOper	Operator
    2              0.000036 hi def link vimOption	PreProc
    2              0.000036 hi def link vimParenSep	Delimiter
    2              0.000017 hi def link vimPatSepErr	vimPatSep
    2              0.000015 hi def link vimPatSepR	vimPatSep
    2              0.000035 hi def link vimPatSep	SpecialChar
    2              0.000017 hi def link vimPatSepZone	vimString
    2              0.000015 hi def link vimPatSepZ	vimPatSep
    2              0.000035 hi def link vimPattern	Type
    2              0.000017 hi def link vimPlainMark	vimMark
    2              0.000018 hi def link vimPlainRegister	vimRegister
    2              0.000052 hi def link vimRegister	SpecialChar
    2              0.000052 hi def link vimScriptDelim	Comment
    2              0.000055 hi def link vimSearchDelim	Statement
    2              0.000020 hi def link vimSearch	vimString
    2              0.000034 hi def link vimSep	Delimiter
    2              0.000016 hi def link vimSetMod	vimOption
    2              0.000033 hi def link vimSetSep	Statement
    2              0.000016 hi def link vimSetString	vimString
    2              0.000034 hi def link vimSpecFile	Identifier
    2              0.000017 hi def link vimSpecFileMod	vimSpecFile
    2              0.000031 hi def link vimSpecial	Type
    2              0.000032 hi def link vimStatement	Statement
    2              0.000016 hi def link vimStringCont	vimString
    2              0.000033 hi def link vimString	String
    2              0.000016 hi def link vimSubst1	vimSubst
    2              0.000033 hi def link vimSubstDelim	Delimiter
    2              0.000034 hi def link vimSubstFlags	Special
    2              0.000034 hi def link vimSubstSubstr	SpecialChar
    2              0.000017 hi def link vimSubstTwoBS	vimString
    2              0.000034 hi def link vimSubst	vimCommand
    2              0.000034 hi def link vimSynCaseError	Error
    2              0.000033 hi def link vimSynCase	Type
    2              0.000033 hi def link vimSyncC	Type
    2              0.000033 hi def link vimSyncError	Error
    2              0.000014 hi def link vimSyncGroupName	vimGroupName
    2              0.000013 hi def link vimSyncGroup	vimGroupName
    2              0.000032 hi def link vimSyncKey	Type
    2              0.000033 hi def link vimSyncNone	Type
    2              0.000016 hi def link vimSynContains	vimSynOption
    2              0.000033 hi def link vimSynError	Error
    2              0.000015 hi def link vimSynKeyContainedin	vimSynContains
    2              0.000015 hi def link vimSynKeyOpt	vimSynOption
    2              0.000012 hi def link vimSynMtchGrp	vimSynOption
    2              0.000034 hi def link vimSynMtchOpt	vimSynOption
    2              0.000013 hi def link vimSynNextgroup	vimSynOption
    2              0.000013 hi def link vimSynNotPatRange	vimSynRegPat
    2              0.000031 hi def link vimSynOption	Special
    2              0.000015 hi def link vimSynPatRange	vimString
    2              0.000012 hi def link vimSynRegOpt	vimSynOption
    2              0.000014 hi def link vimSynRegPat	vimString
    2              0.000032 hi def link vimSynReg	Type
    2              0.000034 hi def link vimSyntax	vimCommand
    2              0.000032 hi def link vimSynType	vimSpecial
    2              0.000034 hi def link vimTodo	Todo
    2              0.000017 hi def link vimUnmap	vimMap
    2              0.000016 hi def link nvimUnmap	vimMap
    2              0.000034 hi def link vimUserAttrbCmpltFunc	Special
    2              0.000014 hi def link vimUserAttrbCmplt	vimSpecial
    2              0.000014 hi def link vimUserAttrbKey	vimOption
    2              0.000013 hi def link vimUserAttrb	vimSpecial
    2              0.000033 hi def link vimUserCmdError	Error
    2              0.000034 hi def link vimUserCommand	vimCommand
    2              0.000051 hi def link vimUserFunc	Normal
    2              0.000052 hi def link vimVar	Identifier
    2              0.000033 hi def link vimWarn	WarningMsg
                            
                            " Current Syntax Variable: {{{2
    2              0.000010 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    2              0.000021 let &cpo = s:keepcpo
    2              0.000006 unlet s:keepcpo
                            " vim:ts=18  fdm=marker

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/syntax/python.vim
Sourced 2 times
Total time:   0.006742
 Self time:   0.006742

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Python
                            " Maintainer:	Zvezdan Petkovic <zpetkovic@acm.org>
                            " Last Change:	2015 Sep 15
                            " Credits:	Neil Schemenauer <nas@python.ca>
                            "		Dmitry Vasiliev
                            "
                            "		This version is a major rewrite by Zvezdan Petkovic.
                            "
                            "		- introduced highlighting of doctests
                            "		- updated keywords, built-ins, and exceptions
                            "		- corrected regular expressions for
                            "
                            "		  * functions
                            "		  * decorators
                            "		  * strings
                            "		  * escapes
                            "		  * numbers
                            "		  * space error
                            "
                            "		- corrected synchronization
                            "		- more highlighting is ON by default, except
                            "		- space error highlighting is OFF by default
                            "
                            " Optional highlighting can be controlled using these variables.
                            "
                            "   let python_no_builtin_highlight = 1
                            "   let python_no_doctest_code_highlight = 1
                            "   let python_no_doctest_highlight = 1
                            "   let python_no_exception_highlight = 1
                            "   let python_no_number_highlight = 1
                            "   let python_space_error_highlight = 1
                            "
                            " All the options above can be switched on together.
                            "
                            "   let python_highlight_all = 1
                            "
                            
                            " For version 5.x: Clear all syntax items.
                            " For version 6.x: Quit when a syntax file was already loaded.
    2              0.000023 if version < 600
                              syntax clear
                            elseif exists("b:current_syntax")
                              finish
                            endif
                            
                            " We need nocompatible mode in order to continue lines with backslashes.
                            " Original setting will be restored.
    2              0.000025 let s:cpo_save = &cpo
    2              0.000024 set cpo&vim
                            
                            " Keep Python keywords in alphabetical order inside groups for easy
                            " comparison with the table in the 'Python Language Reference'
                            " https://docs.python.org/2/reference/lexical_analysis.html#keywords,
                            " https://docs.python.org/3/reference/lexical_analysis.html#keywords.
                            " Groups are in the order presented in NAMING CONVENTIONS in syntax.txt.
                            " Exceptions come last at the end of each group (class and def below).
                            "
                            " Keywords 'with' and 'as' are new in Python 2.6
                            " (use 'from __future__ import with_statement' in Python 2.5).
                            "
                            " Some compromises had to be made to support both Python 3 and 2.
                            " We include Python 3 features, but when a definition is duplicated,
                            " the last definition takes precedence.
                            "
                            " - 'False', 'None', and 'True' are keywords in Python 3 but they are
                            "   built-ins in 2 and will be highlighted as built-ins below.
                            " - 'exec' is a built-in in Python 3 and will be highlighted as
                            "   built-in below.
                            " - 'nonlocal' is a keyword in Python 3 and will be highlighted.
                            " - 'print' is a built-in in Python 3 and will be highlighted as
                            "   built-in below (use 'from __future__ import print_function' in 2)
                            " - async and await were added in Python 3.5 and are soft keywords.
                            "
    2              0.000027 syn keyword pythonStatement	False, None, True
    2              0.000046 syn keyword pythonStatement	as assert break continue del exec global
    2              0.000025 syn keyword pythonStatement	lambda nonlocal pass print return with yield
    2              0.000035 syn keyword pythonStatement	class def nextgroup=pythonFunction skipwhite
    2              0.000019 syn keyword pythonConditional	elif else if
    2              0.000016 syn keyword pythonRepeat	for while
    2              0.000019 syn keyword pythonOperator	and in is not or
    2              0.000019 syn keyword pythonException	except finally raise try
    2              0.000015 syn keyword pythonInclude	from import
    2              0.000015 syn keyword pythonAsync		async await
                            
                            " Decorators (new in Python 2.4)
    2              0.000050 syn match   pythonDecorator	"@" display nextgroup=pythonFunction skipwhite
                            " The zero-length non-grouping match before the function name is
                            " extremely important in pythonFunction.  Without it, everything is
                            " interpreted as a function inside the contained environment of
                            " doctests.
                            " A dot must be allowed because of @MyClass.myfunc decorators.
    2              0.000041 syn match   pythonFunction
                                  \ "\%(\%(def\s\|class\s\|@\)\s*\)\@<=\h\%(\w\|\.\)*" contained
                            
    2              0.000049 syn match   pythonComment	"#.*$" contains=pythonTodo,@Spell
    2              0.000020 syn keyword pythonTodo		FIXME NOTE NOTES TODO XXX contained
                            
                            " Triple-quoted strings can contain doctests.
    2              0.000071 syn region  pythonString matchgroup=pythonQuotes
                                  \ start=+[uU]\=\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=pythonEscape,@Spell
    2              0.000119 syn region  pythonString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=\z('''\|"""\)+ skip=+\\["']+ end="\z1" keepend
                                  \ contains=pythonEscape,pythonSpaceError,pythonDoctest,@Spell
    2              0.000553 syn region  pythonRawString matchgroup=pythonQuotes
                                  \ start=+[uU]\=[rR]\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=@Spell
    2              0.000095 syn region  pythonRawString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=[rR]\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonSpaceError,pythonDoctest,@Spell
                            
    2              0.000024 syn match   pythonEscape	+\\[abfnrtv'"\\]+ contained
    2              0.000024 syn match   pythonEscape	"\\\o\{1,3}" contained
    2              0.000020 syn match   pythonEscape	"\\x\x\{2}" contained
    2              0.000027 syn match   pythonEscape	"\%(\\u\x\{4}\|\\U\x\{8}\)" contained
                            " Python allows case-insensitive Unicode IDs: http://www.unicode.org/charts/
    2              0.000026 syn match   pythonEscape	"\\N{\a\+\%(\s\a\+\)*}" contained
    2              0.000019 syn match   pythonEscape	"\\$"
                            
    2              0.000019 if exists("python_highlight_all")
                              if exists("python_no_builtin_highlight")
                                unlet python_no_builtin_highlight
                              endif
                              if exists("python_no_doctest_code_highlight")
                                unlet python_no_doctest_code_highlight
                              endif
                              if exists("python_no_doctest_highlight")
                                unlet python_no_doctest_highlight
                              endif
                              if exists("python_no_exception_highlight")
                                unlet python_no_exception_highlight
                              endif
                              if exists("python_no_number_highlight")
                                unlet python_no_number_highlight
                              endif
                              let python_space_error_highlight = 1
                            endif
                            
                            " It is very important to understand all details before changing the
                            " regular expressions below or their order.
                            " The word boundaries are *not* the floating-point number boundaries
                            " because of a possible leading or trailing decimal point.
                            " The expressions below ensure that all valid number literals are
                            " highlighted, and invalid number literals are not.  For example,
                            "
                            " - a decimal point in '4.' at the end of a line is highlighted,
                            " - a second dot in 1.0.0 is not highlighted,
                            " - 08 is not highlighted,
                            " - 08e0 or 08j are highlighted,
                            "
                            " and so on, as specified in the 'Python Language Reference'.
                            " https://docs.python.org/2/reference/lexical_analysis.html#numeric-literals
                            " https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals
    2              0.000011 if !exists("python_no_number_highlight")
                              " numbers (including longs and complex)
    2              0.000028   syn match   pythonNumber	"\<0[oO]\=\o\+[Ll]\=\>"
    2              0.000023   syn match   pythonNumber	"\<0[xX]\x\+[Ll]\=\>"
    2              0.000050   syn match   pythonNumber	"\<0[bB][01]\+[Ll]\=\>"
    2              0.000047   syn match   pythonNumber	"\<\%([1-9]\d*\|0\)[Ll]\=\>"
    2              0.000023   syn match   pythonNumber	"\<\d\+[jJ]\>"
    2              0.000046   syn match   pythonNumber	"\<\d\+[eE][+-]\=\d\+[jJ]\=\>"
    2              0.000041   syn match   pythonNumber
                            	\ "\<\d\+\.\%([eE][+-]\=\d\+\)\=[jJ]\=\%(\W\|$\)\@="
    2              0.000039   syn match   pythonNumber
                            	\ "\%(^\|\W\)\zs\d*\.\d\+\%([eE][+-]\=\d\+\)\=[jJ]\=\>"
    2              0.000005 endif
                            
                            " Group the built-ins in the order in the 'Python Library Reference' for
                            " easier comparison.
                            " https://docs.python.org/2/library/constants.html
                            " https://docs.python.org/3/library/constants.html
                            " http://docs.python.org/2/library/functions.html
                            " http://docs.python.org/3/library/functions.html
                            " http://docs.python.org/2/library/functions.html#non-essential-built-in-functions
                            " http://docs.python.org/3/library/functions.html#non-essential-built-in-functions
                            " Python built-in functions are in alphabetical order.
    2              0.000014 if !exists("python_no_builtin_highlight")
                              " built-in constants
                              " 'False', 'True', and 'None' are also reserved words in Python 3
    2              0.000021   syn keyword pythonBuiltin	False True None
    2              0.000018   syn keyword pythonBuiltin	NotImplemented Ellipsis __debug__
                              " built-in functions
    2              0.000020   syn keyword pythonBuiltin	abs all any bin bool bytearray callable chr
    2              0.000040   syn keyword pythonBuiltin	classmethod compile complex delattr dict dir
    2              0.000021   syn keyword pythonBuiltin	divmod enumerate eval filter float format
    2              0.000018   syn keyword pythonBuiltin	frozenset getattr globals hasattr hash
    2              0.000018   syn keyword pythonBuiltin	help hex id input int isinstance
    2              0.000018   syn keyword pythonBuiltin	issubclass iter len list locals map max
    2              0.000022   syn keyword pythonBuiltin	memoryview min next object oct open ord pow
    2              0.000019   syn keyword pythonBuiltin	print property range repr reversed round set
    2              0.000021   syn keyword pythonBuiltin	setattr slice sorted staticmethod str
    2              0.000020   syn keyword pythonBuiltin	sum super tuple type vars zip __import__
                              " Python 2 only
    2              0.000035   syn keyword pythonBuiltin	basestring cmp execfile file
    2              0.000120   syn keyword pythonBuiltin	long raw_input reduce reload unichr
    2              0.000018   syn keyword pythonBuiltin	unicode xrange
                              " Python 3 only
    2              0.000016   syn keyword pythonBuiltin	ascii bytes exec
                              " non-essential built-in functions; Python 2 only
    2              0.000017   syn keyword pythonBuiltin	apply buffer coerce intern
    2              0.000004 endif
                            
                            " From the 'Python Library Reference' class hierarchy at the bottom.
                            " http://docs.python.org/2/library/exceptions.html
                            " http://docs.python.org/3/library/exceptions.html
    2              0.000014 if !exists("python_no_exception_highlight")
                              " builtin base exceptions (used mostly as base classes for other exceptions)
    2              0.000016   syn keyword pythonExceptions	BaseException Exception
    2              0.000016   syn keyword pythonExceptions	ArithmeticError BufferError
    2              0.000023   syn keyword pythonExceptions	LookupError
                              " builtin base exceptions removed in Python 3
    2              0.000024   syn keyword pythonExceptions	EnvironmentError StandardError
                              " builtin exceptions (actually raised)
    2              0.000023   syn keyword pythonExceptions	AssertionError AttributeError
    2              0.000029   syn keyword pythonExceptions	EOFError FloatingPointError GeneratorExit
    2              0.000023   syn keyword pythonExceptions	ImportError IndentationError
    2              0.000023   syn keyword pythonExceptions	IndexError KeyError KeyboardInterrupt
    2              0.000190   syn keyword pythonExceptions	MemoryError NameError NotImplementedError
    2              0.000264   syn keyword pythonExceptions	OSError OverflowError ReferenceError
    2              0.000129   syn keyword pythonExceptions	RuntimeError StopIteration SyntaxError
    2              0.000161   syn keyword pythonExceptions	SystemError SystemExit TabError TypeError
    2              0.000086   syn keyword pythonExceptions	UnboundLocalError UnicodeError
    2              0.000093   syn keyword pythonExceptions	UnicodeDecodeError UnicodeEncodeError
    2              0.000086   syn keyword pythonExceptions	UnicodeTranslateError ValueError
    2              0.000057   syn keyword pythonExceptions	ZeroDivisionError
                              " builtin OS exceptions in Python 3
    2              0.000084   syn keyword pythonExceptions	BlockingIOError BrokenPipeError
    2              0.000089   syn keyword pythonExceptions	ChildProcessError ConnectionAbortedError
    2              0.000085   syn keyword pythonExceptions	ConnectionError ConnectionRefusedError
    2              0.000084   syn keyword pythonExceptions	ConnectionResetError FileExistsError
    2              0.000086   syn keyword pythonExceptions	FileNotFoundError InterruptedError
    2              0.000084   syn keyword pythonExceptions	IsADirectoryError NotADirectoryError
    2              0.000083   syn keyword pythonExceptions	PermissionError ProcessLookupError
    2              0.000083   syn keyword pythonExceptions	RecursionError StopAsyncIteration
    2              0.000061   syn keyword pythonExceptions	TimeoutError
                              " builtin exceptions deprecated/removed in Python 3
    2              0.000119   syn keyword pythonExceptions	IOError VMSError WindowsError
                              " builtin warnings
    2              0.000098   syn keyword pythonExceptions	BytesWarning DeprecationWarning FutureWarning
    2              0.000101   syn keyword pythonExceptions	ImportWarning PendingDeprecationWarning
    2              0.000140   syn keyword pythonExceptions	RuntimeWarning SyntaxWarning UnicodeWarning
    2              0.000075   syn keyword pythonExceptions	UserWarning Warning
                              " builtin warnings in Python 3
    2              0.000042   syn keyword pythonExceptions	ResourceWarning
    2              0.000004 endif
                            
    2              0.000013 if exists("python_space_error_highlight")
                              " trailing whitespace
                              syn match   pythonSpaceError	display excludenl "\s\+$"
                              " mixed tabs and spaces
                              syn match   pythonSpaceError	display " \+\t"
                              syn match   pythonSpaceError	display "\t\+ "
                            endif
                            
                            " Do not spell doctests inside strings.
                            " Notice that the end of a string, either ''', or """, will end the contained
                            " doctest too.  Thus, we do *not* need to have it as an end pattern.
    2              0.000022 if !exists("python_no_doctest_highlight")
    2              0.000009   if !exists("python_no_doctest_code_highlight")
    2              0.000048     syn region pythonDoctest
                            	  \ start="^\s*>>>\s" end="^\s*$"
                            	  \ contained contains=ALLBUT,pythonDoctest,@Spell
    2              0.000037     syn region pythonDoctestValue
                            	  \ start=+^\s*\%(>>>\s\|\.\.\.\s\|"""\|'''\)\@!\S\++ end="$"
                            	  \ contained
    2              0.000007   else
                                syn region pythonDoctest
                            	  \ start="^\s*>>>" end="^\s*$"
                            	  \ contained contains=@NoSpell
                              endif
    2              0.000002 endif
                            
                            " Sync at the beginning of class, function, or method definition.
    2              0.000048 syn sync match pythonSync grouphere NONE "^\s*\%(def\|class\)\s\+\h\w*\s*("
                            
    2              0.000010 if version >= 508 || !exists("did_python_syn_inits")
    2              0.000005   if version <= 508
                                let did_python_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
    2              0.000024     command -nargs=+ HiLink hi def link <args>
    2              0.000003   endif
                            
                              " The default highlight links.  Can be overridden later.
    2              0.000078   HiLink pythonStatement	Statement
    2              0.000064   HiLink pythonConditional	Conditional
    2              0.000049   HiLink pythonRepeat		Repeat
    2              0.000044   HiLink pythonOperator		Operator
    2              0.000048   HiLink pythonException	Exception
    2              0.000044   HiLink pythonInclude		Include
    2              0.000044   HiLink pythonAsync		Statement
    2              0.000043   HiLink pythonDecorator	Define
    2              0.000044   HiLink pythonFunction		Function
    2              0.000044   HiLink pythonComment		Comment
    2              0.000043   HiLink pythonTodo		Todo
    2              0.000043   HiLink pythonString		String
    2              0.000043   HiLink pythonRawString	String
    2              0.000043   HiLink pythonQuotes		String
    2              0.000022   HiLink pythonTripleQuotes	pythonQuotes
    2              0.000042   HiLink pythonEscape		Special
    2              0.000012   if !exists("python_no_number_highlight")
    2              0.000045     HiLink pythonNumber		Number
    2              0.000003   endif
    2              0.000009   if !exists("python_no_builtin_highlight")
    2              0.000044     HiLink pythonBuiltin	Function
    2              0.000003   endif
    2              0.000009   if !exists("python_no_exception_highlight")
    2              0.000044     HiLink pythonExceptions	Structure
    2              0.000003   endif
    2              0.000008   if exists("python_space_error_highlight")
                                HiLink pythonSpaceError	Error
                              endif
    2              0.000007   if !exists("python_no_doctest_highlight")
    2              0.000044     HiLink pythonDoctest	Special
    2              0.000044     HiLink pythonDoctestValue	Define
    2              0.000003   endif
                            
    2              0.000006   delcommand HiLink
    2              0.000004 endif
                            
    2              0.000015 let b:current_syntax = "python"
                            
    2              0.000024 let &cpo = s:cpo_save
    2              0.000006 unlet s:cpo_save
                            
                            " vim:set sw=2 sts=2 ts=8 noet:

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/syntax/vim/generated.vim
Sourced 2 times
Total time:   0.006329
 Self time:   0.006329

count  total (s)   self (s)
                            syn keyword vimCommand contained  a[ppend] ab[breviate] abc[lear] abo[veleft] al[l] am[enu] an[oremenu] ar[gs] arga[dd] argd[elete] argdo arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] au[tocmd] aug[roup] aun[menu] b[uffer] bN[ext] ba[ll] bad[d] bd[elete] be[have] bel[owright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] bu[ffers] bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] ca[bbrev] cabc[lear] cad[dbuffer] cadde[xpr] caddf[ile] cal[l] cat[ch] cb[uffer] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfi[rst] cg[etfile] cgetb[uffer] cgete[xpr] ch[dir] cha[nges] che[ckpath] checkt[ime] cl[ist] cla[st] clo[se] cm[ap] cmapc[lear] cme[nu] cn[ext] cnew[er] cnf[ile] cno[remap] cnorea[bbrev] cnorem[enu] co[py] col[der] colo[rscheme] com[mand] comc[lear]
    2              0.000275 syn keyword vimCommand contained  comp[iler] con[tinue] conf[irm] cop[en] cp[revious] cpf[ile] cq[uit] cr[ewind] cs[cope] cst[ag] cu[nmap] cuna[bbrev] cunm[enu] cw[indow] d[elete] delm[arks] deb[ug] debugg[reedy] del[command] delf[unction] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] dj[ump] dl[ist] do[autocmd] doautoa[ll] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] ec[ho] echoe[rr] echoh[l] echom[sg] echon el[se] elsei[f] em[enu] en[dif] endf[unction] endfo[r] endt[ry] endw[hile] ene[w] ex exe[cute] exi[t] exu[sage] f[ile] files filet[ype] fin[d] fina[lly] fini[sh] fir[st] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] for fu[nction] g[lobal] go[to] gr[ep] grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpg[rep] helpt[ags] ha[rdcopy] hi[ghlight] hid[e] his[tory] i[nsert] ia[bbrev]
    2              0.000245 syn keyword vimCommand contained  iabc[lear] if ij[ump] il[ist] im[ap] imapc[lear] ime[nu] in[oremap] inorea[bbrev] inorem[enu] int[ro] is[earch] isp[lit] iu[nmap] iuna[bbrev] iunm[enu] j[oin] ju[mps] k ke[epmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] lat[er] lb[uffer] lc[d] lch[dir] lcl[ose] lcs[cope] ld[o] le[ft] lefta[bove] let lex[pr] lf[ile] lfd[o] lfi[rst] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] ll lla[st] lli[st] lm[ap] lmapc[lear] lmak[e] ln[oremap] lne[xt] lnew[er] lnf[ile] lo[adview] loadk[eymap] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] lt[ag] lu[nmap] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd] lw[indow] ls m[ove] ma[rk] mak[e] map mapc[lear] mar[ks] mat[ch] me[nu] menut[ranslate] mes[sages] mk[exrc]
    2              0.000730 syn keyword vimCommand contained  mks[ession] mksp[ell] mkv[imrc] mkvie[w] mo[de] mz[scheme] mzf[ile] n[ext] nb[key] nbc[lose] nbs[tart] ne[w] nm[ap] nmapc[lear] nme[nu] nn[oremap] nnoreme[nu] no[remap] noa[utocmd] noh[lsearch] nor[eabbrev] norem[enu] nos[wapfile] nor[mal] nu[mber] nun[map] nunme[nu] o[ldfiles] om[ap] omapc[lear] ome[nu] on[ly] ono[remap] onoreme[nu] op[tions] ou[nmap] ounme[nu] ow[nsyntax] p[rint] pc[lose] pe[rl] perld[o] ped[it] po[p] popu[p] pp[op] pr[eserve] prev[ious] pro[mptfind] promptr[epl] prof[ile] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] pyt[hon3] py3[file] q[uit] quita[ll] qa[ll] r[ead] rec[over] red[o] redi[r] redr[aw] redraws[tatus] reg[isters] res[ize] ret[ab] retu[rn] rew[ind] ri[ght] rightb[elow]
    2              0.000228 syn keyword vimCommand contained  rs[hada] ru[ntime] rund[o] rub[y] rubyd[o] rubyf[ile] rv[iminfo] s[ubstitute] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] scs[cope] se[t] setf[iletype] setg[lobal] setl[ocal] sf[ind] sfir[st] si[malt] sig[n] sil[ent] sl[eep] sla[st] sm[agic] smap smapc[lear] sme[nu] sn[ext] sno[magic] snor[emap] snoreme[nu] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] sto[pinsert] stj[ump] sts[elect] su[nhide] sunm[ap] sunme[nu] sus[pend] sv[iew] sw[apname] sy[ntax] synti[me] sync[bind] t tc[d] tch[dir] tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit] tabf[ind] tabfir[st]
    2              0.000223 syn keyword vimCommand contained  tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly] tabp[revious] tabN[ext] tabr[ewind] tabs tc[l] tcld[o] tclf[ile] te[rminal] tf[irst] th[row] tj[ump] tl[ast] tm[ap] tmapc[lear] tme[nu] tn[ext] tno[remap] to[pleft] tp[revious] tr[ewind] try ts[elect] tu[nmap] tunme[nu] u[ndo] undoj[oin] undol[ist] una[bbreviate] unh[ide] unl[et] unlo[ckvar] unm[ap] unme[nu] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] viu[sage] vm[ap] vmapc[lear] vme[nu] vn[oremap] vne[w] vno[remenu] vs[plit] vu[nmap] vunme[nu] w[rite] wN[ext] wa[ll] wh[ile] wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] ws[verb] wsh[ada] wu[ndo] wv[iminfo] x[it] xa[ll] xm[ap] xmapc[lear] xme[nu] xn[oremap] xnoreme[nu] xu[nmap] xunme[nu] y[ank] N[ext]
                            
    2              0.000094 syn keyword vimOption contained  aleph al arabic arab invarabic noarabic invarab noarab arabicshape arshape invarabicshape noarabicshape invarshape noarshape allowrevins ari invallowrevins noallowrevins invari noari altkeymap akm invaltkeymap noaltkeymap invakm noakm ambiwidth ambw autochdir acd invautochdir noautochdir invacd noacd autoindent ai invautoindent noautoindent invai noai autoread ar invautoread noautoread invar noar autowrite aw invautowrite noautowrite invaw noaw autowriteall awa invautowriteall noautowriteall invawa noawa background bg backspace bs backup bk invbackup nobackup invbk nobk backupcopy bkc backupdir bdir backupext bex backupskip bsk belloff bo binary bin invbinary nobinary invbin nobin bomb invbomb nobomb breakat brk breakindent bri invbreakindent nobreakindent invbri nobri breakindentopt briopt browsedir bsdir bufhidden bh
    2              0.000215 syn keyword vimOption contained  buflisted bl invbuflisted nobuflisted invbl nobl buftype bt casemap cmp cdpath cd cedit charconvert ccv cindent cin invcindent nocindent invcin nocin cinkeys cink cinoptions cino cinwords cinw clipboard cb cmdheight ch cmdwinheight cwh colorcolumn cc columns co comments com commentstring cms complete cpt concealcursor cocu conceallevel cole completefunc cfu completeopt cot confirm cf invconfirm noconfirm invcf nocf copyindent ci invcopyindent nocopyindent invci noci cpoptions cpo cscopepathcomp cspc cscopeprg csprg cscopequickfix csqf cscoperelative csre invcscoperelative nocscoperelative invcsre nocsre cscopetag cst invcscopetag nocscopetag invcst nocst cscopetagorder csto cscopeverbose csverb invcscopeverbose nocscopeverbose invcsverb nocsverb cursorbind crb invcursorbind nocursorbind invcrb nocrb cursorcolumn cuc invcursorcolumn nocursorcolumn invcuc nocuc
    2              0.000161 syn keyword vimOption contained  cursorline cul invcursorline nocursorline invcul nocul debug define def delcombine deco invdelcombine nodelcombine invdeco nodeco dictionary dict diff invdiff nodiff diffexpr dex diffopt dip digraph dg invdigraph nodigraph invdg nodg directory dir display dy eadirection ead encoding enc endofline eol invendofline noendofline inveol noeol equalalways ea invequalalways noequalalways invea noea equalprg ep errorbells eb inverrorbells noerrorbells inveb noeb errorfile ef errorformat efm esckeys ek invesckeys noesckeys invek noek eventignore ei expandtab et invexpandtab noexpandtab invet noet exrc ex invexrc noexrc invex noex fileencoding fenc fileencodings fencs fileformat ff fileformats ffs fileignorecase fic invfileignorecase nofileignorecase invfic nofic filetype ft fillchars fcs fixendofline fixeol invfixendofline nofixendofline invfixeol nofixeol
    2              0.000117 syn keyword vimOption contained  fkmap fk invfkmap nofkmap invfk nofk foldclose fcl foldcolumn fdc foldenable fen invfoldenable nofoldenable invfen nofen foldexpr fde foldignore fdi foldlevel fdl foldlevelstart fdls foldmarker fmr foldmethod fdm foldminlines fml foldnestmax fdn foldopen fdo foldtext fdt formatexpr fex formatoptions fo formatlistpat flp formatprg fp fsync fs invfsync nofsync invfs nofs gdefault gd invgdefault nogdefault invgd nogd grepformat gfm grepprg gp guicursor gcr guifont gfn guifontset gfs guifontwide gfw guiheadroom ghr guioptions go guitablabel gtl guitabtooltip gtt helpfile hf helpheight hh helplang hlg hidden hid invhidden nohidden invhid nohid highlight hl history hi hkmap hk invhkmap nohkmap invhk nohk hkmapp hkp invhkmapp nohkmapp invhkp nohkp hlsearch hls invhlsearch nohlsearch invhls nohls icon invicon noicon
    2              0.000113 syn keyword vimOption contained  iconstring ignorecase ic invignorecase noignorecase invic noic imcmdline imc invimcmdline noimcmdline invimc noimc imdisable imd invimdisable noimdisable invimd noimd iminsert imi imsearch ims include inc includeexpr inex incsearch is invincsearch noincsearch invis nois indentexpr inde indentkeys indk infercase inf invinfercase noinfercase invinf noinf insertmode im invinsertmode noinsertmode invim noim isfname isf isident isi iskeyword isk isprint isp joinspaces js invjoinspaces nojoinspaces invjs nojs keymap kmp keymodel km keywordprg kp langmap lmap langmenu lm langnoremap lnr invlangnoremap nolangnoremap invlnr nolnr laststatus ls lazyredraw lz invlazyredraw nolazyredraw invlz nolz linebreak lbr invlinebreak nolinebreak invlbr nolbr lines linespace lsp lisp invlisp nolisp lispwords lw list invlist nolist
    2              0.000092 syn keyword vimOption contained  listchars lcs loadplugins lpl invloadplugins noloadplugins invlpl nolpl magic invmagic nomagic makeef mef makeprg mp matchpairs mps matchtime mat maxcombine mco maxfuncdepth mfd maxmapdepth mmd maxmem mm maxmempattern mmp maxmemtot mmt menuitems mis mkspellmem msm modeline ml invmodeline nomodeline invml noml modelines mls modifiable ma invmodifiable nomodifiable invma noma modified mod invmodified nomodified invmod nomod more invmore nomore mouse mousefocus mousef invmousefocus nomousefocus invmousef nomousef mousehide mh invmousehide nomousehide invmh nomh mousemodel mousem mouseshape mouses mousetime mouset nrformats nf number nu invnumber nonumber invnu nonu numberwidth nuw omnifunc ofu opendevice odev invopendevice noopendevice invodev noodev operatorfunc opfunc paragraphs para paste invpaste nopaste pastetoggle pt
    2              0.000073 syn keyword vimOption contained  patchexpr pex patchmode pm path pa preserveindent pi invpreserveindent nopreserveindent invpi nopi previewheight pvh previewwindow pvw invpreviewwindow nopreviewwindow invpvw nopvw printdevice pdev printencoding penc printexpr pexpr printfont pfn printheader pheader printmbcharset pmbcs printmbfont pmbfn printoptions popt prompt invprompt noprompt pumheight ph quoteescape qe readonly ro invreadonly noreadonly invro noro redrawtime rdt regexpengine re relativenumber rnu invrelativenumber norelativenumber invrnu nornu remap invremap noremap report revins ri invrevins norevins invri nori rightleft rl invrightleft norightleft invrl norl rightleftcmd rlc ruler ru invruler noruler invru noru rulerformat ruf runtimepath rtp scroll scr scrollbind scb invscrollbind noscrollbind invscb noscb scrolljump sj scrolloff so
    2              0.000096 syn keyword vimOption contained  scrollopt sbo sections sect secure invsecure nosecure selection sel selectmode slm sessionoptions ssop shada sd shell sh shellcmdflag shcf shellpipe sp shellquote shq shellredir srr shellslash ssl invshellslash noshellslash invssl nossl shelltemp stmp invshelltemp noshelltemp invstmp nostmp shellxquote sxq shellxescape sxe shiftround sr invshiftround noshiftround invsr nosr shiftwidth sw shortmess shm showbreak sbr showcmd sc invshowcmd noshowcmd invsc nosc showfulltag sft invshowfulltag noshowfulltag invsft nosft showmatch sm invshowmatch noshowmatch invsm nosm showmode smd invshowmode noshowmode invsmd nosmd showtabline stal sidescroll ss sidescrolloff siso smartcase scs invsmartcase nosmartcase invscs noscs smartindent si invsmartindent nosmartindent invsi nosi smarttab sta invsmarttab nosmarttab invsta nosta
    2              0.000080 syn keyword vimOption contained  softtabstop sts spell invspell nospell spellcapcheck spc spellfile spf spelllang spl spellsuggest sps splitbelow sb invsplitbelow nosplitbelow invsb nosb splitright spr invsplitright nosplitright invspr nospr startofline sol invstartofline nostartofline invsol nosol statusline stl suffixes su suffixesadd sua swapfile swf invswapfile noswapfile invswf noswf switchbuf swb synmaxcol smc syntax syn tabline tal tabpagemax tpm tabstop ts tagbsearch tbs invtagbsearch notagbsearch invtbs notbs taglength tl tagrelative tr invtagrelative notagrelative invtr notr tags tag tagstack tgst invtagstack notagstack invtgst notgst termbidi tbidi invtermbidi notermbidi invtbidi notbidi termencoding tenc terse invterse noterse textwidth tw thesaurus tsr tildeop top invtildeop notildeop invtop notop timeout to invtimeout notimeout invto noto
    2              0.000078 syn keyword vimOption contained  timeoutlen tm title invtitle notitle titlelen titleold titlestring ttimeout invttimeout nottimeout ttimeoutlen ttm undodir udir undofile udf invundofile noundofile invudf noudf undolevels ul undoreload ur updatecount uc updatetime ut verbose vbs verbosefile vfile viewdir vdir viewoptions vop viminfo vi virtualedit ve visualbell vb invvisualbell novisualbell invvb novb warn invwarn nowarn whichwrap ww wildchar wc wildcharm wcm wildignore wig wildignorecase wic invwildignorecase nowildignorecase invwic nowic wildmenu wmnu invwildmenu nowildmenu invwmnu nowmnu wildmode wim wildoptions wop winaltkeys wak window wi winheight wh winfixheight wfh invwinfixheight nowinfixheight invwfh nowfh winfixwidth wfw invwinfixwidth nowinfixwidth invwfw nowfw winminheight wmh winminwidth wmw winwidth wiw wrap invwrap nowrap wrapmargin wm
    2              0.000023 syn keyword vimOption contained  wrapscan ws invwrapscan nowrapscan invws nows write invwrite nowrite writeany wa invwriteany nowriteany invwa nowa writebackup wb invwritebackup nowritebackup invwb nowb writedelay wd
                            
    2              0.000005 syn case ignore
                            
    2              0.000220 syn keyword vimAutoEvent contained  BufAdd BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWriteCmd BufWritePost BufWritePre CmdUndefined CmdWinEnter CmdWinLeave ColorScheme CompleteDone CursorHold CursorHoldI CursorMoved CursorMovedI EncodingChanged FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave JobActivity MenuPopup OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePre
    2              0.000045 syn keyword vimAutoEvent contained  SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabEnter TabLeave TermChanged TermResponse TextChanged TextChangedI TextYankPost User VimEnter VimLeave VimLeavePre VimResized WinEnter WinLeave BufWrite FileEncoding BufCreate BufRead
                            
    2              0.000016 syn keyword nvimAutoEvent contained  TabNewEntered TabClosed TabNew TermClose TermOpen
                            
    2              0.000004 syn case match
                            
    2              0.000016 syn keyword vimFuncName contained 

SCRIPT  /Users/Jack/.vim/plugged/emmet-vim/autoload/emmet/lang/scss.vim
Sourced 1 time
Total time:   0.000279
 Self time:   0.000279

count  total (s)   self (s)
                            function! emmet#lang#scss#findTokens(str) abort
                              return emmet#lang#css#findTokens(a:str)
                            endfunction
                            
    1              0.000007 function! emmet#lang#scss#parseIntoTree(abbr, type) abort
                              if a:abbr =~# '>'
                                return emmet#lang#html#parseIntoTree(a:abbr, a:type)
                              else
                                return emmet#lang#css#parseIntoTree(a:abbr, a:type)
                              endif
                            endfunction
                            
    1              0.000009 function! emmet#lang#scss#toString(settings, current, type, inline, filters, itemno, indent) abort
                              let settings = a:settings
                              let current = a:current
                              let type = a:type
                              let inline = a:inline
                              let filters = a:filters
                              let itemno = a:itemno
                              let indent = a:indent
                              let str = ''
                            
                              let current_name = substitute(current.name, '\$$', itemno+1, '')
                              if len(current.name) > 0
                                let str .= current_name
                                let tmp = ''
                                for attr in keys(current.attr)
                                  let val = current.attr[attr]
                                  while val =~# '\$\([^#{]\|$\)'
                                    let val = substitute(val, '\(\$\+\)\([^{]\|$\)', '\=printf("%0".len(submatch(1))."d", itemno+1).submatch(2)', 'g')
                                  endwhile
                                  let attr = substitute(attr, '\$$', itemno+1, '')
                                  if attr ==# 'id'
                                    let str .= '#' . val
                                  elseif attr ==# 'class'
                                    let str .= '.' . val
                                  else
                                    let tmp .= attr . ': ' . val . ';'
                                  endif
                                endfor
                                if len(tmp) > 0
                                  let str .= " {\n"
                                  for line in split(tmp, "\n")
                                    let str .= indent . line . "\n"
                                  endfor
                                else
                                  let str .= " {\n"
                                endif
                            
                                let inner = ''
                                for child in current.child
                                  let inner .= emmet#toString(child, type, inline, filters, itemno)
                                endfor
                                let inner = substitute(inner, "\n", "\n" . escape(indent, '\'), 'g')
                                let inner = substitute(inner, "\n" . escape(indent, '\') . '$', '', 'g')
                                let str .= indent . inner . "${cursor}\n}\n"
                              else
                                return emmet#lang#css#toString(settings, current, type, inline, filters, itemno, indent)
                              endif
                              return str
                            endfunction
                            
    1              0.000005 function! emmet#lang#scss#imageSize() abort
                              call emmet#lang#css#imageSize()
                            endfunction
                            
    1              0.000005 function! emmet#lang#scss#encodeImage() abort
                              return emmet#lang#css#encodeImage()
                            endfunction
                            
    1              0.000005 function! emmet#lang#scss#parseTag(tag) abort
                              return emmet#lang#css#parseTag(a:tag)
                            endfunction
                            
    1              0.000005 function! emmet#lang#scss#toggleComment() abort
                              call emmet#lang#css#toggleComment()
                            endfunction
                            
    1              0.000005 function! emmet#lang#scss#balanceTag(flag) range abort
                              if a:flag == -2 || a:flag == 2
                                let curpos = [0, line("'<"), col("'<"), 0]
                                call setpos('.', curpos)
                              else
                                let curpos = emmet#util#getcurpos()
                              endif
                              if a:flag < 0
                                let ret = searchpair('}', '', '.\zs{')
                              else
                                let ret = searchpair('{', '', '}', 'bW')
                              endif
                              if ret > 0
                                let pos1 = emmet#util#getcurpos()[1:2]
                                if a:flag < 0
                                  let pos2 = searchpairpos('{', '', '}')
                                else
                                  let pos2 = searchpairpos('{', '', '}')
                                endif
                                let block = [pos1, pos2]
                                if emmet#util#regionIsValid(block)
                                  call emmet#util#selectRegion(block)
                                  return
                                endif
                              endif
                              if a:flag == -2 || a:flag == 2
                                silent! exe 'normal! gv'
                              else
                                call setpos('.', curpos)
                              endif
                            endfunction
                            
    1              0.000006 function! emmet#lang#scss#moveNextPrevItem(flag) abort
                              return emmet#lang#scss#moveNextPrev(a:flag)
                            endfunction
                            
    1              0.000005 function! emmet#lang#scss#moveNextPrev(flag) abort
                              call emmet#lang#css#moveNextPrev(a:flag)
                            endfunction
                            
    1              0.000005 function! emmet#lang#scss#splitJoinTag() abort
                              call emmet#lang#css#splitJoinTag()
                            endfunction
                            
    1              0.000005 function! emmet#lang#scss#removeTag() abort
                              call emmet#lang#css#removeTag()
                            endfunction

SCRIPT  /Users/Jack/.vim/plugged/emmet-vim/autoload/emmet/lang/css.vim
Sourced 1 time
Total time:   0.001234
 Self time:   0.001234

count  total (s)   self (s)
                            function! emmet#lang#css#findTokens(str) abort
                              let tmp = substitute(substitute(a:str, '^.*[;{]\s*', '', ''), '}\s*$', '', '')
                              if tmp =~ '/' && tmp =~ '^[a-zA-Z0-9/_.]\+$'
                                " maybe path or something
                                return ''
                              endif
                              return substitute(substitute(a:str, '^.*[;{]\s*', '', ''), '}\s*$', '', '')
                            endfunction
                            
    1              0.000010 function! emmet#lang#css#parseIntoTree(abbr, type) abort
                              let abbr = a:abbr
                              let type = a:type
                              let prefix = 0
                              let value = ''
                            
                              let indent = emmet#getIndentation(type)
                              let aliases = emmet#getResource(type, 'aliases', {})
                              let snippets = emmet#getResource(type, 'snippets', {})
                              let use_pipe_for_cursor = emmet#getResource(type, 'use_pipe_for_cursor', 1)
                            
                              let root = emmet#newNode()
                            
                              " emmet
                              let tokens = split(abbr, '+\ze[^+)!]')
                              let block = emmet#util#searchRegion('{', '}')
                              if abbr !~# '^@' && emmet#getBaseType(type) ==# 'css' && type !=# 'sass' && block[0] ==# [0,0] && block[1] ==# [0,0]
                                let current = emmet#newNode()
                                let current.snippet = substitute(abbr, '\s\+$', '', '') . " {\n" . indent . "${cursor}\n}"
                                let current.name = ''
                                call add(root.child, deepcopy(current))
                              else
                                for n in range(len(tokens))
                                  let token = tokens[n]
                                  let prop = matchlist(token, '^\(-\{0,1}[a-zA-Z]\+\|[a-zA-Z0-9]\++\{0,1}\|([a-zA-Z0-9]\++\{0,1})\)\(\%([0-9.-]\+\%(p\|e\|em\|vh\|vw\|re\|rem\|%\)\{0,1}-\{0,1}\|-auto\)*\)$')
                                  if len(prop)
                                    let token = substitute(prop[1], '^(\(.*\))', '\1', '')
                                    if token =~# '^-'
                                      let prefix = 1
                                      let token = token[1:]
                                    endif
                                    let value = ''
                                    for v in split(prop[2], '\d\zs-')
                                      if len(value) > 0
                                        let value .= ' '
                                      endif
                                      if token =~# '^[z]'
                                        " TODO
                                        let value .= substitute(v, '[^0-9.]*$', '', '')
                                      elseif v =~# 'p$'
                                        let value .= substitute(v, 'p$', '%', '')
                                      elseif v =~# '%$'
                                        let value .= v
                                      elseif v =~# 'e$'
                                        let value .= substitute(v, 'e$', 'em', '')
                                      elseif v =~# 'em$'
                                        let value .= v
                                      elseif v =~# 'vh$'
                                        let value .= v
                                      elseif v =~# 'vw$'
                                        let value .= v
                                      elseif v =~# 're$'
                                        let value .= substitute(v, 're$', 'rem', '')
                                      elseif v =~# 'rem$'
                                        let value .= v
                                      elseif v =~# '\.'
                                        let value .= v . 'em'
                                      elseif v ==# 'auto'
                                        let value .= v
                                      elseif v ==# '0'
                                        let value .= '0'
                                      else
                                        let value .= v . 'px'
                                      endif
                                    endfor
                                  endif
                            
                                  let tag_name = token
                                  if tag_name =~# '.!$'
                                    let tag_name = tag_name[:-2]
                                    let important = 1
                                  else
                                    let important = 0
                                  endif
                                  " make default node
                                  let current = emmet#newNode()
                                  let current.important = important
                                  let current.name = tag_name
                            
                                  " aliases
                                  if has_key(aliases, tag_name)
                                    let current.name = aliases[tag_name]
                                  endif
                            
                                  " snippets
                                  if !empty(snippets)
                                    let snippet_name = tag_name
                                    if !has_key(snippets, snippet_name)
                                      let pat = '^' . join(split(tag_name, '\zs'), '\%(\|[^:-]\+-\)')
                                      let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                      if len(vv) == 0
                                        let vv = filter(sort(keys(snippets)), 'substitute(v:val, ":", "", "g") == snippet_name')
                                      endif
                                      if len(vv) > 0
                                        let snippet_name = vv[0]
                                      else
                                        let pat = '^' . join(split(tag_name, '\zs'), '\%(\|[^:-]\+-*\)')
                                        let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                        if len(vv) == 0
                                          let pat = '^' . join(split(tag_name, '\zs'), '[^:]\{-}')
                                          let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                          if len(vv) == 0
                                            let pat = '^' . join(split(tag_name, '\zs'), '.\{-}')
                                            let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                          endif
                                        endif
                                        let minl = -1
                                        for vk in vv
                                          let vvs = snippets[vk]
                                          if minl == -1 || len(vvs) < minl
                                            let snippet_name = vk
                                            let minl = len(vvs)
                                          endif
                                        endfor
                                      endif
                                    endif
                                    if has_key(snippets, snippet_name)
                                      let snippet = snippets[snippet_name]
                                      if use_pipe_for_cursor
                                        let snippet = substitute(snippet, '|', '${cursor}', 'g')
                                      endif
                                      let lines = split(snippet, "\n")
                                      call map(lines, 'substitute(v:val, "\\(    \\|\\t\\)", escape(indent, "\\\\"), "g")')
                                      let current.snippet = join(lines, "\n")
                                      let current.name = ''
                                      let current.snippet = substitute(current.snippet, ';', value . ';', '')
                                      if use_pipe_for_cursor && len(value) > 0
                                        let current.snippet = substitute(current.snippet, '\${cursor}', '', 'g')
                                      endif
                                      if n < len(tokens) - 1
                                        let current.snippet .= "\n"
                                      endif
                                    endif
                                  endif
                            
                                  let current.pos = 0
                                  let lg = matchlist(token, '^\%(linear-gradient\|lg\)(\s*\(\S\+\)\s*,\s*\([^,]\+\)\s*,\s*\([^)]\+\)\s*)$')
                                  if len(lg) == 0
                                    let lg = matchlist(token, '^\%(linear-gradient\|lg\)(\s*\(\S\+\)\s*,\s*\([^,]\+\)\s*)$')
                                    if len(lg)
                                      let [lg[1], lg[2], lg[3]] = ['linear', lg[1], lg[2]]
                                    endif
                                  endif
                                  if len(lg)
                                    let current.name = ''
                                    let current.snippet = printf("background-image:-webkit-gradient(%s, 0 0, 0 100%, from(%s), to(%s));\n", lg[1], lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:-webkit-linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:-moz-linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:-o-linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                  elseif prefix
                                    let snippet = current.snippet
                                    let current.snippet = '-webkit-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = '-moz-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = '-o-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = '-ms-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = snippet
                                    call add(root.child, current)
                                  elseif token =~# '^c#\([0-9a-fA-F]\{3}\|[0-9a-fA-F]\{6}\)\(\.[0-9]\+\)\?'
                                    let cs = split(token, '\.')
                                    let current.name = ''
                                    let [r,g,b] = [0,0,0]
                                    if len(cs[0]) == 5
                                      let rgb = matchlist(cs[0], 'c#\(.\)\(.\)\(.\)')
                                      let r = eval('0x'.rgb[1].rgb[1])
                                      let g = eval('0x'.rgb[2].rgb[2])
                                      let b = eval('0x'.rgb[3].rgb[3])
                                    elseif len(cs[0]) == 8
                                      let rgb = matchlist(cs[0], 'c#\(..\)\(..\)\(..\)')
                                      let r = eval('0x'.rgb[1])
                                      let g = eval('0x'.rgb[2])
                                      let b = eval('0x'.rgb[3])
                                    endif
                                    if len(cs) == 1
                                      let current.snippet = printf('color:rgb(%d, %d, %d);', r, g, b)
                                    else
                                      let current.snippet = printf('color:rgb(%d, %d, %d, %s);', r, g, b, string(str2float('0.'.cs[1])))
                                    endif
                                    call add(root.child, current)
                                  elseif token =~# '^c#'
                                    let current.name = ''
                                    let current.snippet = 'color:\${cursor};'
                                    call add(root.child, current)
                                  else
                                    call add(root.child, current)
                                  endif
                                endfor
                              endif
                              return root
                            endfunction
                            
    1              0.000015 function! emmet#lang#css#toString(settings, current, type, inline, filters, itemno, indent) abort
                              let current = a:current
                              let value = current.value[1:-2]
                              let tmp = substitute(value, '\${cursor}', '', 'g')
                              if tmp !~ '.*{[ \t\r\n]*}$'
                                if emmet#useFilter(a:filters, 'fc')
                                  let value = substitute(value, '\([^:]\+\):\([^;]*\)', '\1: \2', 'g')
                                else
                                  let value = substitute(value, '\([^:]\+\):\([^;]*\)', '\1:\2', 'g')
                                endif
                                if current.important
                                  let value = substitute(value, ';', ' !important;', '')
                                endif
                              endif
                              return value
                            endfunction
                            
    1              0.000009 function! emmet#lang#css#imageSize() abort
                              let img_region = emmet#util#searchRegion('{', '}')
                              if !emmet#util#regionIsValid(img_region) || !emmet#util#cursorInRegion(img_region)
                                return
                              endif
                              let content = emmet#util#getContent(img_region)
                              let fn = matchstr(content, '\<url(\zs[^)]\+\ze)')
                              let fn = substitute(fn, '[''" \t]', '', 'g')
                              if fn =~# '^\s*$'
                                return
                              elseif fn !~# '^\(/\|http\)'
                                let fn = simplify(expand('%:h') . '/' . fn)
                              endif
                              let [width, height] = emmet#util#getImageSize(fn)
                              if width == -1 && height == -1
                                return
                              endif
                              let indent = emmet#getIndentation('css')
                              if content =~# '.*\<width\s*:[^;]*;.*'
                                let content = substitute(content, '\<width\s*:[^;]*;', 'width: ' . width . 'px;', '')
                              else
                                let content = substitute(content, '}', indent . 'width: ' . width . "px;\n}", '')
                              endif
                              if content =~# '.*\<height\s*:[^;]*;.*'
                                let content = substitute(content, '\<height\s*:[^;]*;', 'height: ' . height . 'px;', '')
                              else
                                let content = substitute(content, '}', indent . 'height: ' . height . "px;\n}", '')
                              endif
                              call emmet#util#setContent(img_region, content)
                            endfunction
                            
    1              0.000010 function! emmet#lang#css#encodeImage() abort
                            endfunction
                            
    1              0.000011 function! emmet#lang#css#parseTag(tag) abort
                              return {}
                            endfunction
                            
    1              0.000006 function! emmet#lang#css#toggleComment() abort
                              let line = getline('.')
                              let mx = '^\(\s*\)/\*\s*\(.*\)\s*\*/\s*$'
                              if line =~# '{\s*$'
                                let block = emmet#util#searchRegion('/\*', '\*/\zs')
                                if emmet#util#regionIsValid(block)
                                  let content = emmet#util#getContent(block)
                                  let content = substitute(content, '/\*\s\(.*\)\s\*/', '\1', '')
                                  call emmet#util#setContent(block, content)
                                else
                                  let node = expand('<cword>')
                                  if len(node)
                                    exe "normal ciw\<c-r>='/* '.node.' */'\<cr>"
                                  endif
                                endif
                              else
                                if line =~# mx
                                  let space = substitute(matchstr(line, mx), mx, '\1', '')
                                  let line = substitute(matchstr(line, mx), mx, '\2', '')
                                  let line = space . substitute(line, '^\s*\|\s*$', '\1', 'g')
                                else
                                  let mx = '^\(\s*\)\(.*\)\s*$'
                                  let line = substitute(line, mx, '\1/* \2 */', '')
                                endif
                                call setline('.', line)
                              endif
                            endfunction
                            
    1              0.000018 function! emmet#lang#css#balanceTag(flag) range abort
                              if a:flag == -2 || a:flag == 2
                                let curpos = [0, line("'<"), col("'<"), 0]
                              else
                                let curpos = emmet#util#getcurpos()
                              endif
                              let block = emmet#util#getVisualBlock()
                              if !emmet#util#regionIsValid(block)
                                if a:flag > 0
                                  let block = emmet#util#searchRegion('^', ';')
                                  if emmet#util#regionIsValid(block)
                                    call emmet#util#selectRegion(block)
                                    return
                                  endif
                                endif
                              else
                                if a:flag > 0
                                  let content = emmet#util#getContent(block)
                                  if content !~# '^{.*}$'
                                    let block = emmet#util#searchRegion('{', '}')
                                    if emmet#util#regionIsValid(block)
                                      call emmet#util#selectRegion(block)
                                      return
                                    endif
                                  endif
                                else
                                  let pos = searchpos('.*;', 'nW')
                                  if pos[0] != 0
                                    call setpos('.', [0, pos[0], pos[1], 0])
                                    let block = emmet#util#searchRegion('^', ';')
                                    if emmet#util#regionIsValid(block)
                                      call emmet#util#selectRegion(block)
                                      return
                                    endif
                                  endif
                                endif
                              endif
                              if a:flag == -2 || a:flag == 2
                                silent! exe 'normal! gv'
                              else
                                call setpos('.', curpos)
                              endif
                            endfunction
                            
    1              0.000008 function! emmet#lang#css#moveNextPrevItem(flag) abort
                              return emmet#lang#css#moveNextPrev(a:flag)
                            endfunction
                            
    1              0.000007 function! emmet#lang#css#moveNextPrev(flag) abort
                              let pos = search('""\|()\|\(:\s*\zs$\)', a:flag ? 'Wbp' : 'Wp')
                              if pos == 2
                                startinsert!
                              else
                                silent! normal! l
                                startinsert
                              endif
                            endfunction
                            
    1              0.000007 function! emmet#lang#css#splitJoinTag() abort
                              " nothing to do
                            endfunction
                            
    1              0.000007 function! emmet#lang#css#removeTag() abort
                              " nothing to do
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/autoload/provider/clipboard.vim
Sourced 1 time
Total time:   0.043840
 Self time:   0.043840

count  total (s)   self (s)
                            " The clipboard provider uses shell commands to communicate with the clipboard.
                            " The provider function will only be registered if a supported command is
                            " available.
    1              0.000017 let s:copy = {}
    1              0.000004 let s:paste = {}
                            
                            " When caching is enabled, store the jobid of the xclip/xsel process keeping
                            " ownership of the selection, so we know how long the cache is valid.
    1              0.000009 let s:selection = { 'owner': 0, 'data': [] }
                            
    1              0.000008 function! s:selection.on_exit(jobid, data, event)
                              " At this point this nvim instance might already have launched
                              " a new provider instance. Don't drop ownership in this case.
                              if self.owner == a:jobid
                                let self.owner = 0
                              endif
                            endfunction
                            
    1              0.000014 let s:selections = { '*': s:selection, '+': copy(s:selection)}
                            
    1              0.000005 function! s:try_cmd(cmd, ...)
                              let argv = split(a:cmd, " ")
                              let out = a:0 ? systemlist(argv, a:1, 1) : systemlist(argv, [''], 1)
                              if v:shell_error
                                echohl WarningMsg
                                echo "clipboard: error: ".(len(out) ? out[0] : '')
                                echohl None
                                return 0
                              endif
                              return out
                            endfunction
                            
    1              0.000004 let s:cache_enabled = 1
    1              0.043110 if executable('pbcopy')
    1              0.000053   let s:copy['+'] = 'pbcopy'
    1              0.000018   let s:paste['+'] = 'pbpaste'
    1              0.000021   let s:copy['*'] = s:copy['+']
    1              0.000026   let s:paste['*'] = s:paste['+']
    1              0.000009   let s:cache_enabled = 0
    1              0.000012 elseif exists('$DISPLAY') && executable('xsel')
                              let s:copy['+'] = 'xsel --nodetach -i -b'
                              let s:paste['+'] = 'xsel -o -b'
                              let s:copy['*'] = 'xsel --nodetach -i -p'
                              let s:paste['*'] = 'xsel -o -p'
                            elseif exists('$DISPLAY') && executable('xclip')
                              let s:copy['+'] = 'xclip -quiet -i -selection clipboard'
                              let s:paste['+'] = 'xclip -o -selection clipboard'
                              let s:copy['*'] = 'xclip -quiet -i -selection primary'
                              let s:paste['*'] = 'xclip -o -selection primary'
                            elseif executable('lemonade')
                              let s:copy['+'] = 'lemonade copy'
                              let s:paste['+'] = 'lemonade paste'
                              let s:copy['*'] = 'lemonade copy'
                              let s:paste['*'] = 'lemonade paste'
                            else
                              echom 'clipboard: No clipboard tool available. See :help nvim-clipboard'
                              finish
                            endif
                            
    1              0.000065 let s:clipboard = {}
                            
    1              0.000013 function! s:clipboard.get(reg)
                              let reg = a:reg == '"' ? '+' : a:reg
                              if s:selections[reg].owner > 0
                                return s:selections[reg].data
                              end
                              return s:try_cmd(s:paste[reg])
                            endfunction
                            
    1              0.000010 function! s:clipboard.set(lines, regtype, reg)
                              if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
                              end
                              if s:cache_enabled == 0
                                call s:try_cmd(s:copy[a:reg], a:lines)
                                return 0
                              end
                            
                              let selection = s:selections[a:reg]
                              if selection.owner > 0
                                " The previous provider instance should exit when the new one takes
                                " ownership, but kill it to be sure we don't fill up the job table.
                                call jobstop(selection.owner)
                              end
                              let selection.data = [a:lines, a:regtype]
                              let argv = split(s:copy[a:reg], " ")
                              let selection.detach = s:cache_enabled
                              let jobid = jobstart(argv, selection)
                              if jobid <= 0
                                echohl WarningMsg
                                echo "clipboard: error when invoking provider"
                                echohl None
                                return 0
                              endif
                              call jobsend(jobid, a:lines)
                              call jobclose(jobid, 'stdin')
                              let selection.owner = jobid
                            endfunction
                            
    1              0.000020 function! provider#clipboard#Call(method, args)
                              return call(s:clipboard[a:method],a:args,s:clipboard)
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/0.1.4/share/nvim/runtime/indent/html.vim
Sourced 1 time
Total time:   0.007655
 Self time:   0.006635

count  total (s)   self (s)
                            " Vim indent script for HTML
                            " Header: "{{{
                            " Maintainer:	Bram Moolenaar
                            " Original Author: Andy Wokula <anwoku@yahoo.de>
                            " Last Change:	2015 Sep 25
                            " Version:	1.0
                            " Description:	HTML indent script with cached state for faster indenting on a
                            "		range of lines.
                            "		Supports template systems through hooks.
                            "		Supports Closure stylesheets.
                            "
                            " Credits:
                            "	indent/html.vim (2006 Jun 05) from J. Zellner
                            "	indent/css.vim (2006 Dec 20) from N. Weibull
                            "
                            " History:
                            " 2014 June	(v1.0) overhaul (Bram)
                            " 2012 Oct 21	(v0.9) added support for shiftwidth()
                            " 2011 Sep 09	(v0.8) added HTML5 tags (thx to J. Zuckerman)
                            " 2008 Apr 28	(v0.6) revised customization
                            " 2008 Mar 09	(v0.5) fixed 'indk' issue (thx to C.J. Robinson)
                            "}}}
                            
                            " Init Folklore, check user settings (2nd time ++)
    1              0.000017 if exists("b:did_indent") "{{{
                              finish
                            endif
    1              0.000007 let b:did_indent = 1
                            
    1              0.000013 setlocal indentexpr=HtmlIndent()
    1              0.000006 setlocal indentkeys=o,O,<Return>,<>>,{,},!^F
                            
                            " "j1" is included to make cindent() work better with Javascript.
    1              0.000012 setlocal cino=j1
                            " "J1" should be included, but it doen't work properly before 7.4.355.
    1              0.004907 if has("patch-7.4.355")
    1              0.000026   setlocal cino+=J1
    1              0.000002 endif
                            " Before patch 7.4.355 indenting after "(function() {" does not work well, add
                            " )2 to limit paren search.
    1              0.000010 if !has("patch-7.4.355")
                              setlocal cino+=)2
                            endif
                            
                            " Needed for % to work when finding start/end of a tag.
    1              0.000011 setlocal matchpairs+=<:>
                            
    1              0.000006 let b:undo_indent = "setlocal inde< indk< cino<"
                            
                            " b:hi_indent keeps state to speed up indenting consecutive lines.
    1              0.000004 let b:hi_indent = {"lnum": -1}
                            
                            """""" Code below this is loaded only once. """""
    1              0.000006 if exists("*HtmlIndent") && !exists('g:force_reload_html')
                              call HtmlIndent_CheckUserSettings()
                              finish
                            endif
                            
                            " shiftwidth() exists since patch 7.3.694
    1              0.000003 if exists('*shiftwidth')
    1              0.000009   let s:ShiftWidth = function('shiftwidth')
    1              0.000001 else
                              func! s:ShiftWidth()
                                return &shiftwidth
                              endfunc
                            endif
                            
                            " Allow for line continuation below.
    1              0.000005 let s:cpo_save = &cpo
    1              0.000011 set cpo-=C
                            "}}}
                            
                            " Check and process settings from b:html_indent and g:html_indent... variables.
                            " Prefer using buffer-local settings over global settings, so that there can
                            " be defaults for all HTML files and exceptions for specific types of HTML
                            " files.
    1              0.000003 func! HtmlIndent_CheckUserSettings()
                              "{{{
                              let inctags = ''
                              if exists("b:html_indent_inctags")
                                let inctags = b:html_indent_inctags
                              elseif exists("g:html_indent_inctags")
                                let inctags = g:html_indent_inctags
                              endif
                              let b:hi_tags = {}
                              if len(inctags) > 0
                                call s:AddITags(b:hi_tags, split(inctags, ","))
                              endif
                            
                              let autotags = ''
                              if exists("b:html_indent_autotags")
                                let autotags = b:html_indent_autotags
                              elseif exists("g:html_indent_autotags")
                                let autotags = g:html_indent_autotags
                              endif
                              let b:hi_removed_tags = {}
                              if len(autotags) > 0
                                call s:RemoveITags(b:hi_removed_tags, split(autotags, ","))
                              endif
                            
                              " Syntax names indicating being inside a string of an attribute value.
                              let string_names = []
                              if exists("b:html_indent_string_names")
                                let string_names = b:html_indent_string_names
                              elseif exists("g:html_indent_string_names")
                                let string_names = g:html_indent_string_names
                              endif
                              let b:hi_insideStringNames = ['htmlString']
                              if len(string_names) > 0
                                for s in string_names
                                  call add(b:hi_insideStringNames, s)
                                endfor
                              endif
                            
                              " Syntax names indicating being inside a tag.
                              let tag_names = []
                              if exists("b:html_indent_tag_names")
                                let tag_names = b:html_indent_tag_names
                              elseif exists("g:html_indent_tag_names")
                                let tag_names = g:html_indent_tag_names
                              endif
                              let b:hi_insideTagNames = ['htmlTag', 'htmlScriptTag']
                              if len(tag_names) > 0
                                for s in tag_names
                                  call add(b:hi_insideTagNames, s)
                                endfor
                              endif
                            
                              let indone = {"zero": 0
                                          \,"auto": "indent(prevnonblank(v:lnum-1))"
                                          \,"inc": "b:hi_indent.blocktagind + s:ShiftWidth()"}
                            
                              let script1 = ''
                              if exists("b:html_indent_script1")
                                let script1 = b:html_indent_script1
                              elseif exists("g:html_indent_script1")
                                let script1 = g:html_indent_script1
                              endif
                              if len(script1) > 0
                                let b:hi_js1indent = get(indone, script1, indone.zero)
                              else
                                let b:hi_js1indent = 0
                              endif
                            
                              let style1 = ''
                              if exists("b:html_indent_style1")
                                let style1 = b:html_indent_style1
                              elseif exists("g:html_indent_style1")
                                let style1 = g:html_indent_style1
                              endif
                              if len(style1) > 0
                                let b:hi_css1indent = get(indone, style1, indone.zero)
                              else
                                let b:hi_css1indent = 0
                              endif
                            
                              if !exists('b:html_indent_line_limit')
                                if exists('g:html_indent_line_limit')
                                  let b:html_indent_line_limit = g:html_indent_line_limit
                                else
                                  let b:html_indent_line_limit = 200
                                endif
                              endif
                            endfunc "}}}
                            
                            " Init Script Vars
                            "{{{
    1              0.000006 let b:hi_lasttick = 0
    1              0.000033 let b:hi_newstate = {}
    1              0.000006 let s:countonly = 0
                             "}}}
                            
                            " Fill the s:indent_tags dict with known tags.
                            " The key is "tagname" or "/tagname".  {{{
                            " The value is:
                            " 1   opening tag
                            " 2   "pre"
                            " 3   "script"
                            " 4   "style"
                            " 5   comment start
                            " 6   conditional comment start
                            " -1  closing tag
                            " -2  "/pre"
                            " -3  "/script"
                            " -4  "/style"
                            " -5  comment end
                            " -6  conditional comment end
    1              0.000003 let s:indent_tags = {}
    1              0.000004 let s:endtags = [0,0,0,0,0,0,0]   " long enough for the highest index
                            "}}}
                            
                            " Add a list of tag names for a pair of <tag> </tag> to "tags".
    1              0.000005 func! s:AddITags(tags, taglist)
                              "{{{
                              for itag in a:taglist
                                let a:tags[itag] = 1
                                let a:tags['/' . itag] = -1
                              endfor
                            endfunc "}}}
                            
                            " Take a list of tag name pairs that are not to be used as tag pairs.
    1              0.000003 func! s:RemoveITags(tags, taglist)
                              "{{{
                              for itag in a:taglist
                                let a:tags[itag] = 1
                                let a:tags['/' . itag] = 1
                              endfor
                            endfunc "}}}
                            
                            " Add a block tag, that is a tag with a different kind of indenting.
    1              0.000003 func! s:AddBlockTag(tag, id, ...)
                              "{{{
                              if !(a:id >= 2 && a:id < len(s:endtags))
                                echoerr 'AddBlockTag ' . a:id
                                return
                              endif
                              let s:indent_tags[a:tag] = a:id
                              if a:0 == 0
                                let s:indent_tags['/' . a:tag] = -a:id
                                let s:endtags[a:id] = "</" . a:tag . ">"
                              else
                                let s:indent_tags[a:1] = -a:id
                                let s:endtags[a:id] = a:1
                              endif
                            endfunc "}}}
                            
                            " Add known tag pairs.
                            " Self-closing tags and tags that are sometimes {{{
                            " self-closing (e.g., <p>) are not here (when encountering </p> we can find
                            " the matching <p>, but not the other way around).
                            " Old HTML tags:
    1   0.000565   0.000063 call s:AddITags(s:indent_tags, [
                                \ 'a', 'abbr', 'acronym', 'address', 'b', 'bdo', 'big',
                                \ 'blockquote', 'body', 'button', 'caption', 'center', 'cite', 'code',
                                \ 'colgroup', 'del', 'dfn', 'dir', 'div', 'dl', 'em', 'fieldset', 'font',
                                \ 'form', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'html',
                                \ 'i', 'iframe', 'ins', 'kbd', 'label', 'legend', 'li',
                                \ 'map', 'menu', 'noframes', 'noscript', 'object', 'ol',
                                \ 'optgroup', 'q', 's', 'samp', 'select', 'small', 'span', 'strong', 'sub',
                                \ 'sup', 'table', 'textarea', 'title', 'tt', 'u', 'ul', 'var', 'th', 'td',
                                \ 'tr', 'tbody', 'tfoot', 'thead'])
                            
                            " Tags added 2011 Sep 09 (especially HTML5 tags):
    1   0.000261   0.000014 call s:AddITags(s:indent_tags, [
                                \ 'area', 'article', 'aside', 'audio', 'bdi', 'canvas',
                                \ 'command', 'datalist', 'details', 'embed', 'figure', 'footer',
                                \ 'header', 'group', 'keygen', 'mark', 'math', 'meter', 'nav', 'output',
                                \ 'progress', 'ruby', 'section', 'svg', 'texture', 'time', 'video',
                                \ 'wbr', 'text'])
                            
                            " Tags added for web components:
    1   0.000040   0.000006 call s:AddITags(s:indent_tags, [
                                \ 'content', 'shadow', 'template'])
                            "}}}
                            
                            " Add Block Tags: these contain alien content
                            "{{{
    1   0.000044   0.000015 call s:AddBlockTag('pre', 2)
    1   0.000026   0.000006 call s:AddBlockTag('script', 3)
    1   0.000021   0.000004 call s:AddBlockTag('style', 4)
    1   0.000022   0.000005 call s:AddBlockTag('<!--', 5, '-->')
    1   0.000021   0.000004 call s:AddBlockTag('<!--[', 6, '![endif]-->')
                            "}}}
                            
                            " Return non-zero when "tagname" is an opening tag, not being a block tag, for
                            " which there should be a closing tag.  Can be used by scripts that include
                            " HTML indenting.
    1              0.000002 func! HtmlIndent_IsOpenTag(tagname)
                              "{{{
                              if get(s:indent_tags, a:tagname) == 1
                                return 1
                              endif
                              return get(b:hi_tags, a:tagname) == 1
                            endfunc "}}}
                            
                            " Get the value for "tagname", taking care of buffer-local tags.
    1              0.000002 func! s:get_tag(tagname)
                              "{{{
                              let i = get(s:indent_tags, a:tagname)
                              if (i == 1 || i == -1) && get(b:hi_removed_tags, a:tagname) != 0
                                return 0
                              endif
                              if i == 0
                                let i = get(b:hi_tags, a:tagname)
                              endif
                              return i
                            endfunc "}}}
                            
                            " Count the number of start and end tags in "text".
    1              0.000003 func! s:CountITags(text)
                              "{{{
                              " Store the result in s:curind and s:nextrel.
                              let s:curind = 0  " relative indent steps for current line [unit &sw]:
                              let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
                              let s:block = 0		" assume starting outside of a block
                              let s:countonly = 1	" don't change state
                              call substitute(a:text, '<\zs/\=\w\+\(-\w\+\)*\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
                              let s:countonly = 0
                            endfunc "}}}
                            
                            " Count the number of start and end tags in text.
    1              0.000003 func! s:CountTagsAndState(text)
                              "{{{
                              " Store the result in s:curind and s:nextrel.  Update b:hi_newstate.block.
                              let s:curind = 0  " relative indent steps for current line [unit &sw]:
                              let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
                            
                              let s:block = b:hi_newstate.block
                              let tmp = substitute(a:text, '<\zs/\=\w\+\(-\w\+\)*\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
                              if s:block == 3
                                let b:hi_newstate.scripttype = s:GetScriptType(matchstr(tmp, '\C.*<SCRIPT\>\zs[^>]*'))
                              endif
                              let b:hi_newstate.block = s:block
                            endfunc "}}}
                            
                            " Used by s:CountITags() and s:CountTagsAndState().
    1              0.000002 func! s:CheckTag(itag)
                              "{{{
                              " Returns an empty string or "SCRIPT".
                              " a:itag can be "tag" or "/tag" or "<!--" or "-->"
                              if (s:CheckCustomTag(a:itag))
                                return ""
                              endif
                              let ind = s:get_tag(a:itag)
                              if ind == -1
                                " closing tag
                                if s:block != 0
                                  " ignore itag within a block
                                  return ""
                                endif
                                if s:nextrel == 0
                                  let s:curind -= 1
                                else
                                  let s:nextrel -= 1
                                endif
                              elseif ind == 1
                                " opening tag
                                if s:block != 0
                                  return ""
                                endif
                                let s:nextrel += 1
                              elseif ind != 0
                                " block-tag (opening or closing)
                                return s:CheckBlockTag(a:itag, ind)
                              " else ind==0 (other tag found): keep indent
                              endif
                              return ""
                            endfunc "}}}
                            
                            " Used by s:CheckTag(). Returns an empty string or "SCRIPT".
    1              0.000004 func! s:CheckBlockTag(blocktag, ind)
                              "{{{
                              if a:ind > 0
                                " a block starts here
                                if s:block != 0
                                  " already in a block (nesting) - ignore
                                  " especially ignore comments after other blocktags
                                  return ""
                                endif
                                let s:block = a:ind		" block type
                                if s:countonly
                                  return ""
                                endif
                                let b:hi_newstate.blocklnr = v:lnum
                                " save allover indent for the endtag
                                let b:hi_newstate.blocktagind = b:hi_indent.baseindent + (s:nextrel + s:curind) * s:ShiftWidth()
                                if a:ind == 3
                                  return "SCRIPT"    " all except this must be lowercase
                                  " line is to be checked again for the type attribute
                                endif
                              else
                                let s:block = 0
                                " we get here if starting and closing a block-tag on the same line
                              endif
                              return ""
                            endfunc "}}}
                            
                            " Used by s:CheckTag().
    1              0.000004 func! s:CheckCustomTag(ctag)
                              "{{{
                              " Returns 1 if ctag is the tag for a custom element, 0 otherwise.
                              " a:ctag can be "tag" or "/tag" or "<!--" or "-->"
                              let pattern = '\%\(\w\+-\)\+\w\+'
                              if match(a:ctag, pattern) == -1
                                return 0
                              endif
                              if matchstr(a:ctag, '\/\ze.\+') == "/"
                                " closing tag
                                if s:block != 0
                                  " ignore ctag within a block
                                  return 1
                                endif
                                if s:nextrel == 0
                                  let s:curind -= 1
                                else
                                  let s:nextrel -= 1
                                endif
                              else
                                " opening tag
                                if s:block != 0
                                  return 1
                                endif
                                let s:nextrel += 1
                              endif
                              return 1
                            endfunc "}}}
                            
                            " Return the <script> type: either "javascript" or ""
    1              0.000011 func! s:GetScriptType(str)
                              "{{{
                              if a:str == "" || a:str =~ "java"
                                return "javascript"
                              else
                                return ""
                              endif
                            endfunc "}}}
                            
                            " Look back in the file, starting at a:lnum - 1, to compute a state for the
                            " start of line a:lnum.  Return the new state.
    1              0.000002 func! s:FreshState(lnum)
                              "{{{
                              " A state is to know ALL relevant details about the
                              " lines 1..a:lnum-1, initial calculating (here!) can be slow, but updating is
                              " fast (incremental).
                              " TODO: this should be split up in detecting the block type and computing the
                              " indent for the block type, so that when we do not know the indent we do
                              " not need to clear the whole state and re-detect the block type again.
                              " State:
                              "	lnum		last indented line == prevnonblank(a:lnum - 1)
                              "	block = 0	a:lnum located within special tag: 0:none, 2:<pre>,
                              "			3:<script>, 4:<style>, 5:<!--, 6:<!--[
                              "	baseindent	use this indent for line a:lnum as a start - kind of
                              "			autoindent (if block==0)
                              "	scripttype = ''	type attribute of a script tag (if block==3)
                              "	blocktagind	indent for current opening (get) and closing (set)
                              "			blocktag (if block!=0)
                              "	blocklnr	lnum of starting blocktag (if block!=0)
                              "	inattr		line {lnum} starts with attributes of a tag
                              let state = {}
                              let state.lnum = prevnonblank(a:lnum - 1)
                              let state.scripttype = ""
                              let state.blocktagind = -1
                              let state.block = 0
                              let state.baseindent = 0
                              let state.blocklnr = 0
                              let state.inattr = 0
                            
                              if state.lnum == 0
                                return state
                              endif
                            
                              " Heuristic:
                              " remember startline state.lnum
                              " look back for <pre, </pre, <script, </script, <style, </style tags
                              " remember stopline
                              " if opening tag found,
                              "	assume a:lnum within block
                              " else
                              "	look back in result range (stopline, startline) for comment
                              "	    \ delimiters (<!--, -->)
                              "	if comment opener found,
                              "	    assume a:lnum within comment
                              "	else
                              "	    assume usual html for a:lnum
                              "	    if a:lnum-1 has a closing comment
                              "		look back to get indent of comment opener
                              " FI
                            
                              " look back for a blocktag
                              let stopline2 = v:lnum + 1
                              if has_key(b:hi_indent, 'block') && b:hi_indent.block > 5
                                let [stopline2, stopcol2] = searchpos('<!--', 'bnW')
                              endif
                              let [stopline, stopcol] = searchpos('\c<\zs\/\=\%(pre\>\|script\>\|style\>\)', "bnW")
                              if stopline > 0 && stopline < stopline2
                                " ugly ... why isn't there searchstr()
                                let tagline = tolower(getline(stopline))
                                let blocktag = matchstr(tagline, '\/\=\%(pre\>\|script\>\|style\>\)', stopcol - 1)
                                if blocktag[0] != "/"
                                  " opening tag found, assume a:lnum within block
                                  let state.block = s:indent_tags[blocktag]
                                  if state.block == 3
                                    let state.scripttype = s:GetScriptType(matchstr(tagline, '\>[^>]*', stopcol))
                                  endif
                                  let state.blocklnr = stopline
                                  " check preceding tags in the line:
                                  call s:CountITags(tagline[: stopcol-2])
                                  let state.blocktagind = indent(stopline) + (s:curind + s:nextrel) * s:ShiftWidth()
                                  return state
                                elseif stopline == state.lnum
                                  " handle special case: previous line (= state.lnum) contains a
                                  " closing blocktag which is preceded by line-noise;
                                  " blocktag == "/..."
                                  let swendtag = match(tagline, '^\s*</') >= 0
                                  if !swendtag
                                    let [bline, bcol] = searchpos('<'.blocktag[1:].'\>', "bnW")
                                    call s:CountITags(tolower(getline(bline)[: bcol-2]))
                                    let state.baseindent = indent(bline) + (s:curind + s:nextrel) * s:ShiftWidth()
                                    return state
                                  endif
                                endif
                              endif
                              if stopline > stopline2
                                let stopline = stopline2
                                let stopcol = stopcol2
                              endif
                            
                              " else look back for comment
                              let [comlnum, comcol, found] = searchpos('\(<!--\[\)\|\(<!--\)\|-->', 'bpnW', stopline)
                              if found == 2 || found == 3
                                " comment opener found, assume a:lnum within comment
                                let state.block = (found == 3 ? 5 : 6)
                                let state.blocklnr = comlnum
                                " check preceding tags in the line:
                                call s:CountITags(tolower(getline(comlnum)[: comcol-2]))
                                if found == 2
                                  let state.baseindent = b:hi_indent.baseindent
                                endif
                                let state.blocktagind = indent(comlnum) + (s:curind + s:nextrel) * s:ShiftWidth()
                                return state
                              endif
                            
                              " else within usual HTML
                              let text = tolower(getline(state.lnum))
                            
                              " Check a:lnum-1 for closing comment (we need indent from the opening line).
                              " Not when other tags follow (might be --> inside a string).
                              let comcol = stridx(text, '-->')
                              if comcol >= 0 && match(text, '[<>]', comcol) <= 0
                                call cursor(state.lnum, comcol + 1)
                                let [comlnum, comcol] = searchpos('<!--', 'bW')
                                if comlnum == state.lnum
                                  let text = text[: comcol-2]
                                else
                                  let text = tolower(getline(comlnum)[: comcol-2])
                                endif
                                call s:CountITags(text)
                                let state.baseindent = indent(comlnum) + (s:curind + s:nextrel) * s:ShiftWidth()
                                " TODO check tags that follow "-->"
                                return state
                              endif
                            
                              " Check if the previous line starts with end tag.
                              let swendtag = match(text, '^\s*</') >= 0
                            
                              " If previous line ended in a closing tag, line up with the opening tag.
                              if !swendtag && text =~ '</\w\+\s*>\s*$'
                                call cursor(state.lnum, 99999)
                                normal! F<
                                let start_lnum = HtmlIndent_FindStartTag()
                                if start_lnum > 0
                                  let state.baseindent = indent(start_lnum)
                                  if col('.') > 2
                                    " check for tags before the matching opening tag.
                                    let text = getline(start_lnum)
                                    let swendtag = match(text, '^\s*</') >= 0
                                    call s:CountITags(text[: col('.') - 2])
                                    let state.baseindent += s:nextrel * s:ShiftWidth()
                                    if !swendtag
                                      let state.baseindent += s:curind * s:ShiftWidth()
                                    endif
                                  endif
                                  return state
                                endif
                              endif
                            
                              " Else: no comments. Skip backwards to find the tag we're inside.
                              let [state.lnum, found] = HtmlIndent_FindTagStart(state.lnum)
                              " Check if that line starts with end tag.
                              let text = getline(state.lnum)
                              let swendtag = match(text, '^\s*</') >= 0
                              call s:CountITags(tolower(text))
                              let state.baseindent = indent(state.lnum) + s:nextrel * s:ShiftWidth()
                              if !swendtag
                                let state.baseindent += s:curind * s:ShiftWidth()
                              endif
                              return state
                            endfunc "}}}
                            
                            " Indent inside a <pre> block: Keep indent as-is.
    1              0.000004 func! s:Alien2()
                              "{{{
                              return -1
                            endfunc "}}}
                            
                            " Return the indent inside a <script> block for javascript.
    1              0.000002 func! s:Alien3()
                              "{{{
                              let lnum = prevnonblank(v:lnum - 1)
                              while lnum > 1 && getline(lnum) =~ '^\s*/[/*]'
                                " Skip over comments to avoid that cindent() aligns with the <script> tag
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
                              if lnum == b:hi_indent.blocklnr
                                " indent for the first line after <script>
                                return eval(b:hi_js1indent)
                              endif
                              if b:hi_indent.scripttype == "javascript"
                                return cindent(v:lnum)
                              else
                                return -1
                              endif
                            endfunc "}}}
                            
                            " Return the indent inside a <style> block.
    1              0.000002 func! s:Alien4()
                              "{{{
                              if prevnonblank(v:lnum-1) == b:hi_indent.blocklnr
                                " indent for first content line
                                return eval(b:hi_css1indent)
                              endif
                              return s:CSSIndent()
                            endfunc "}}}
                            
                            " Indending inside a <style> block.  Returns the indent.
    1              0.000002 func! s:CSSIndent()
                              "{{{
                              " This handles standard CSS and also Closure stylesheets where special lines
                              " start with @.
                              " When the line starts with '*' or the previous line starts with "/*"
                              " and does not end in "*/", use C indenting to format the comment.
                              " Adopted $VIMRUNTIME/indent/css.vim
                              let curtext = getline(v:lnum)
                              if curtext =~ '^\s*[*]'
                                    \ || (v:lnum > 1 && getline(v:lnum - 1) =~ '\s*/\*'
                                    \     && getline(v:lnum - 1) !~ '\*/\s*$')
                                return cindent(v:lnum)
                              endif
                            
                              let min_lnum = b:hi_indent.blocklnr
                              let prev_lnum = s:CssPrevNonComment(v:lnum - 1, min_lnum)
                              let [prev_lnum, found] = HtmlIndent_FindTagStart(prev_lnum)
                              if prev_lnum <= min_lnum
                                " Just below the <style> tag, indent for first content line after comments.
                                return eval(b:hi_css1indent)
                              endif
                            
                              " If the current line starts with "}" align with it's match.
                              if curtext =~ '^\s*}'
                                call cursor(v:lnum, 1)
                                try
                                  normal! %
                                  " Found the matching "{", align with it after skipping unfinished lines.
                                  let align_lnum = s:CssFirstUnfinished(line('.'), min_lnum)
                                  return indent(align_lnum)
                                catch
                                  " can't find it, try something else, but it's most likely going to be
                                  " wrong
                                endtry
                              endif
                            
                              " add indent after {
                              let brace_counts = HtmlIndent_CountBraces(prev_lnum)
                              let extra = brace_counts.c_open * s:ShiftWidth()
                            
                              let prev_text = getline(prev_lnum)
                              let below_end_brace = prev_text =~ '}\s*$'
                            
                              " Search back to align with the first line that's unfinished.
                              let align_lnum = s:CssFirstUnfinished(prev_lnum, min_lnum)
                            
                              " Handle continuation lines if aligning with previous line and not after a
                              " "}".
                              if extra == 0 && align_lnum == prev_lnum && !below_end_brace
                                let prev_hasfield = prev_text =~ '^\s*[a-zA-Z0-9-]\+:'
                                let prev_special = prev_text =~ '^\s*\(/\*\|@\)'
                                if curtext =~ '^\s*\(/\*\|@\)'
                                  " if the current line is not a comment or starts with @ (used by template
                                  " systems) reduce indent if previous line is a continuation line
                                  if !prev_hasfield && !prev_special
                                    let extra = -s:ShiftWidth()
                                  endif
                                else
                                  let cur_hasfield = curtext =~ '^\s*[a-zA-Z0-9-]\+:'
                                  let prev_unfinished = s:CssUnfinished(prev_text)
                                  if !cur_hasfield && (prev_hasfield || prev_unfinished)
                                    " Continuation line has extra indent if the previous line was not a
                                    " continuation line.
                                    let extra = s:ShiftWidth()
                                    " Align with @if
                                    if prev_text =~ '^\s*@if '
                                      let extra = 4
                                    endif
                                  elseif cur_hasfield && !prev_hasfield && !prev_special
                                    " less indent below a continuation line
                                    let extra = -s:ShiftWidth()
                                  endif
                                endif
                              endif
                            
                              if below_end_brace
                                " find matching {, if that line starts with @ it's not the start of a rule
                                " but something else from a template system
                                call cursor(prev_lnum, 1)
                                call search('}\s*$')
                                try
                                  normal! %
                                  " Found the matching "{", align with it.
                                  let align_lnum = s:CssFirstUnfinished(line('.'), min_lnum)
                                  let special = getline(align_lnum) =~ '^\s*@'
                                catch
                                  let special = 0
                                endtry
                                if special
                                  " do not reduce indent below @{ ... }
                                  if extra < 0
                                    let extra += s:ShiftWidth()
                                  endif
                                else
                                  let extra -= (brace_counts.c_close - (prev_text =~ '^\s*}')) * s:ShiftWidth()
                                endif
                              endif
                            
                              " if no extra indent yet...
                              if extra == 0
                                if brace_counts.p_open > brace_counts.p_close
                                  " previous line has more ( than ): add a shiftwidth
                                  let extra = s:ShiftWidth()
                                elseif brace_counts.p_open < brace_counts.p_close
                                  " previous line has more ) than (: subtract a shiftwidth
                                  let extra = -s:ShiftWidth()
                                endif
                              endif
                            
                              return indent(align_lnum) + extra
                            endfunc "}}}
                            
                            " Inside <style>: Whether a line is unfinished.
    1              0.000003 func! s:CssUnfinished(text)
                              "{{{
                              return a:text =~ '\s\(||\|&&\|:\)\s*$'
                            endfunc "}}}
                            
                            " Search back for the first unfinished line above "lnum".
    1              0.000004 func! s:CssFirstUnfinished(lnum, min_lnum)
                              "{{{
                              let align_lnum = a:lnum
                              while align_lnum > a:min_lnum && s:CssUnfinished(getline(align_lnum - 1))
                                let align_lnum -= 1
                              endwhile
                              return align_lnum
                            endfunc "}}}
                            
                            " Find the non-empty line at or before "lnum" that is not a comment.
    1              0.000002 func! s:CssPrevNonComment(lnum, stopline)
                              "{{{
                              " caller starts from a line a:lnum + 1 that is not a comment
                              let lnum = prevnonblank(a:lnum)
                              while 1
                                let ccol = match(getline(lnum), '\*/')
                                if ccol < 0
                                  " No comment end thus its something else.
                                  return lnum
                                endif
                                call cursor(lnum, ccol + 1)
                                " Search back for the /* that starts the comment
                                let lnum = search('/\*', 'bW', a:stopline)
                                if indent(".") == virtcol(".") - 1
                                  " The  found /* is at the start of the line. Now go back to the line
                                  " above it and again check if it is a comment.
                                  let lnum = prevnonblank(lnum - 1)
                                else
                                  " /* is after something else, thus it's not a comment line.
                                  return lnum
                                endif
                              endwhile
                            endfunc "}}}
                            
                            " Check the number of {} and () in line "lnum". Return a dict with the counts.
    1              0.000002 func! HtmlIndent_CountBraces(lnum)
                              "{{{
                              let brs = substitute(getline(a:lnum), '[''"].\{-}[''"]\|/\*.\{-}\*/\|/\*.*$\|[^{}()]', '', 'g')
                              let c_open = 0
                              let c_close = 0
                              let p_open = 0
                              let p_close = 0
                              for brace in split(brs, '\zs')
                                if brace == "{"
                                  let c_open += 1
                                elseif brace == "}"
                                  if c_open > 0
                                    let c_open -= 1
                                  else
                                    let c_close += 1
                                  endif
                                elseif brace == '('
                                  let p_open += 1
                                elseif brace == ')'
                                  if p_open > 0
                                    let p_open -= 1
                                  else
                                    let p_close += 1
                                  endif
                                endif
                              endfor
                              return {'c_open': c_open,
                                    \ 'c_close': c_close,
                                    \ 'p_open': p_open,
                                    \ 'p_close': p_close}
                            endfunc "}}}
                            
                            " Return the indent for a comment: <!-- -->
    1              0.000003 func! s:Alien5()
                              "{{{
                              let curtext = getline(v:lnum)
                              if curtext =~ '^\s*\zs-->'
                                " current line starts with end of comment, line up with comment start.
                                call cursor(v:lnum, 0)
                                let lnum = search('<!--', 'b')
                                if lnum > 0
                                  " TODO: what if <!-- is not at the start of the line?
                                  return indent(lnum)
                                endif
                            
                                " Strange, can't find it.
                                return -1
                              endif
                            
                              let prevlnum = prevnonblank(v:lnum - 1)
                              let prevtext = getline(prevlnum)
                              let idx = match(prevtext, '^\s*\zs<!--')
                              if idx >= 0
                                " just below comment start, add a shiftwidth
                                return idx + s:ShiftWidth()
                              endif
                            
                              " Some files add 4 spaces just below a TODO line.  It's difficult to detect
                              " the end of the TODO, so let's not do that.
                            
                              " Align with the previous non-blank line.
                              return indent(prevlnum)
                            endfunc "}}}
                            
                            " Return the indent for conditional comment: <!--[ ![endif]-->
    1              0.000002 func! s:Alien6()
                              "{{{
                              let curtext = getline(v:lnum)
                              if curtext =~ '\s*\zs<!\[endif\]-->'
                                " current line starts with end of comment, line up with comment start.
                                let lnum = search('<!--', 'bn')
                                if lnum > 0
                                  return indent(lnum)
                                endif
                              endif
                              return b:hi_indent.baseindent + s:ShiftWidth()
                            endfunc "}}}
                            
                            " When the "lnum" line ends in ">" find the line containing the matching "<".
    1              0.000002 func! HtmlIndent_FindTagStart(lnum)
                              "{{{
                              " Avoids using the indent of a continuation line.
                              " Moves the cursor.
                              " Return two values:
                              " - the matching line number or "lnum".
                              " - a flag indicating whether we found the end of a tag.
                              " This method is global so that HTML-like indenters can use it.
                              " To avoid matching " > " or " < " inside a string require that the opening
                              " "<" is followed by a word character and the closing ">" comes after a
                              " non-white character.
                              let idx = match(getline(a:lnum), '\S>\s*$')
                              if idx > 0
                                call cursor(a:lnum, idx)
                                let lnum = searchpair('<\w', '' , '\S>', 'bW', '', max([a:lnum - b:html_indent_line_limit, 0]))
                                if lnum > 0
                                  return [lnum, 1]
                                endif
                              endif
                              return [a:lnum, 0]
                            endfunc "}}}
                            
                            " Find the unclosed start tag from the current cursor position.
    1              0.000002 func! HtmlIndent_FindStartTag()
                              "{{{
                              " The cursor must be on or before a closing tag.
                              " If found, positions the cursor at the match and returns the line number.
                              " Otherwise returns 0.
                              let tagname = matchstr(getline('.')[col('.') - 1:], '</\zs\w\+\ze')
                              let start_lnum = searchpair('<' . tagname . '\>', '', '</' . tagname . '\>', 'bW')
                              if start_lnum > 0
                                return start_lnum
                              endif
                              return 0
                            endfunc "}}}
                            
                            " Moves the cursor from a "<" to the matching ">".
    1              0.000002 func! HtmlIndent_FindTagEnd()
                              "{{{
                              " Call this with the cursor on the "<" of a start tag.
                              " This will move the cursor to the ">" of the matching end tag or, when it's
                              " a self-closing tag, to the matching ">".
                              " Limited to look up to b:html_indent_line_limit lines away.
                              let text = getline('.')
                              let tagname = matchstr(text, '\w\+\|!--', col('.'))
                              if tagname == '!--'
                                call search('--\zs>')
                              elseif s:get_tag('/' . tagname) != 0
                                " tag with a closing tag, find matching "</tag>"
                                call searchpair('<' . tagname, '', '</' . tagname . '\zs>', 'W', '', line('.') + b:html_indent_line_limit)
                              else
                                " self-closing tag, find the ">"
                                call search('\S\zs>')
                              endif
                            endfunc "}}}
                            
                            " Indenting inside a start tag. Return the correct indent or -1 if unknown.
    1              0.000002 func! s:InsideTag(foundHtmlString)
                              "{{{
                              if a:foundHtmlString
                                " Inside an attribute string.
                                " Align with the previous line or use an external function.
                                let lnum = v:lnum - 1
                                if lnum > 1
                                  if exists('b:html_indent_tag_string_func')
                                    return b:html_indent_tag_string_func(lnum)
                                  endif
                                  return indent(lnum)
                                endif
                              endif
                            
                              " Should be another attribute: " attr="val".  Align with the previous
                              " attribute start.
                              let lnum = v:lnum
                              while lnum > 1
                                let lnum -= 1
                                let text = getline(lnum)
                                " Find a match with one of these, align with "attr":
                                "       attr=
                                "  <tag attr=
                                "  text<tag attr=
                                "  <tag>text</tag>text<tag attr=
                                " For long lines search for the first match, finding the last match
                                " gets very slow.
                                if len(text) < 300
                                  let idx = match(text, '.*\s\zs[_a-zA-Z0-9-]\+="')
                                else
                                  let idx = match(text, '\s\zs[_a-zA-Z0-9-]\+="')
                                endif
                                if idx > 0
                                  " Found the attribute.  TODO: assumes spaces, no Tabs.
                                  return idx
                                endif
                              endwhile
                              return -1
                            endfunc "}}}
                            
                            " THE MAIN INDENT FUNCTION. Return the amount of indent for v:lnum.
    1              0.000002 func! HtmlIndent()
                              "{{{
                              if prevnonblank(v:lnum - 1) < 1
                                " First non-blank line has no indent.
                                return 0
                              endif
                            
                              let curtext = tolower(getline(v:lnum))
                              let indentunit = s:ShiftWidth()
                            
                              let b:hi_newstate = {}
                              let b:hi_newstate.lnum = v:lnum
                            
                              " When syntax HL is enabled, detect we are inside a tag.  Indenting inside
                              " a tag works very differently. Do not do this when the line starts with
                              " "<", it gets the "htmlTag" ID but we are not inside a tag then.
                              if curtext !~ '^\s*<'
                                normal! ^
                                let stack = synstack(v:lnum, col('.'))  " assumes there are no tabs
                                let foundHtmlString = 0
                                for synid in reverse(stack)
                                  let name = synIDattr(synid, "name")
                                  if index(b:hi_insideStringNames, name) >= 0
                                    let foundHtmlString = 1
                                  elseif index(b:hi_insideTagNames, name) >= 0
                                    " Yes, we are inside a tag.
                                    let indent = s:InsideTag(foundHtmlString)
                                    if indent >= 0
                                      " Do not keep the state. TODO: could keep the block type.
                                      let b:hi_indent.lnum = 0
                                      return indent
                                    endif
                                  endif
                                endfor
                              endif
                            
                              " does the line start with a closing tag?
                              let swendtag = match(curtext, '^\s*</') >= 0
                            
                              if prevnonblank(v:lnum - 1) == b:hi_indent.lnum && b:hi_lasttick == b:changedtick - 1
                                " use state (continue from previous line)
                              else
                                " start over (know nothing)
                                let b:hi_indent = s:FreshState(v:lnum)
                              endif
                            
                              if b:hi_indent.block >= 2
                                " within block
                                let endtag = s:endtags[b:hi_indent.block]
                                let blockend = stridx(curtext, endtag)
                                if blockend >= 0
                                  " block ends here
                                  let b:hi_newstate.block = 0
                                  " calc indent for REST OF LINE (may start more blocks):
                                  call s:CountTagsAndState(strpart(curtext, blockend + strlen(endtag)))
                                  if swendtag && b:hi_indent.block != 5
                                    let indent = b:hi_indent.blocktagind + s:curind * indentunit
                                    let b:hi_newstate.baseindent = indent + s:nextrel * indentunit
                                  else
                                    let indent = s:Alien{b:hi_indent.block}()
                                    let b:hi_newstate.baseindent = b:hi_indent.blocktagind + s:nextrel * indentunit
                                  endif
                                else
                                  " block continues
                                  " indent this line with alien method
                                  let indent = s:Alien{b:hi_indent.block}()
                                endif
                              else
                                " not within a block - within usual html
                                let b:hi_newstate.block = b:hi_indent.block
                                if swendtag
                                  " The current line starts with an end tag, align with its start tag.
                                  call cursor(v:lnum, 1)
                                  let start_lnum = HtmlIndent_FindStartTag()
                                  if start_lnum > 0
                                    " check for the line starting with something inside a tag:
                                    " <sometag               <- align here
                                    "    attr=val><open>     not here
                                    let text = getline(start_lnum)
                                    let angle = matchstr(text, '[<>]')
                                    if angle == '>'
                                      call cursor(start_lnum, 1)
                                      normal! f>%
                                      let start_lnum = line('.')
                                      let text = getline(start_lnum)
                                    endif
                            
                                    let indent = indent(start_lnum)
                                    if col('.') > 2
                                      let swendtag = match(text, '^\s*</') >= 0
                                      call s:CountITags(text[: col('.') - 2])
                                      let indent += s:nextrel * s:ShiftWidth()
                                      if !swendtag
                                        let indent += s:curind * s:ShiftWidth()
                                      endif
                                    endif
                                  else
                                    " not sure what to do
                                    let indent = b:hi_indent.baseindent
                                  endif
                                  let b:hi_newstate.baseindent = indent
                                else
                                  call s:CountTagsAndState(curtext)
                                  let indent = b:hi_indent.baseindent
                                  let b:hi_newstate.baseindent = indent + (s:curind + s:nextrel) * indentunit
                                endif
                              endif
                            
                              let b:hi_lasttick = b:changedtick
                              call extend(b:hi_indent, b:hi_newstate, "force")
                              return indent
                            endfunc "}}}
                            
                            " Check user settings when loading this script the first time.
    1   0.000148   0.000012 call HtmlIndent_CheckUserSettings()
                            
    1              0.000011 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " vim: fdm=marker ts=8 sw=2 tw=78

SCRIPT  /Users/Jack/.vim/plugged/vim-misc/autoload/xolox/misc/option.vim
Sourced 1 time
Total time:   0.054965
 Self time:   0.054965

count  total (s)   self (s)
                            " Vim and plug-in option handling.
                            "
                            " Author: Peter Odding <peter@peterodding.com>
                            " Last Change: April 1, 2015
                            " URL: http://peterodding.com/code/vim/misc/
                            
    1              0.054352 function! xolox#misc#option#get(name, ...) " {{{1
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
                              if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
                              elseif exists('g:' . a:name)
                                " Global variable.
                                return eval('g:' . a:name)
                              elseif exists('a:1')
                                " Default value.
                                return a:1
                              endif
                            endfunction
                            
    1              0.000021 function! xolox#misc#option#split(value) " {{{1
                              " Given a multi-value Vim option like ['runtimepath'] [rtp] this returns a
                              " list of strings. For example:
                              "
                              "     :echo xolox#misc#option#split(&runtimepath)
                              "     ['/home/peter/Projects/Vim/misc',
                              "      '/home/peter/Projects/Vim/colorscheme-switcher',
                              "      '/home/peter/Projects/Vim/easytags',
                              "      ...]
                              "
                              " [rtp]: http://vimdoc.sourceforge.net/htmldoc/options.html#'runtimepath'
                              let values = split(a:value, '[^\\]\zs,')
                              return map(values, 's:unescape(v:val)')
                            endfunction
                            
    1              0.000088 function! s:unescape(s)
                              return substitute(a:s, '\\\([\\,]\)', '\1', 'g')
                            endfunction
                            
    1              0.000020 function! xolox#misc#option#join(values) " {{{1
                              " Given a list of strings like the ones returned by
                              " `xolox#misc#option#split()`, this joins the strings together into a
                              " single value that can be used to set a Vim option.
                              let values = copy(a:values)
                              call map(values, 's:escape(v:val)')
                              return join(values, ',')
                            endfunction
                            
    1              0.000012 function! s:escape(s)
                              return escape(a:s, ',\')
                            endfunction
                            
    1              0.000015 function! xolox#misc#option#split_tags(value) " {{{1
                              " Customized version of `xolox#misc#option#split()` with specialized
                              " handling for Vim's ['tags' option] [tags].
                              "
                              " [tags]: http://vimdoc.sourceforge.net/htmldoc/options.html#'tags'
                              let values = split(a:value, '[^\\]\zs,')
                              return map(values, 's:unescape_tags(v:val)')
                            endfunction
                            
    1              0.000009 function! s:unescape_tags(s)
                              return substitute(a:s, '\\\([\\, ]\)', '\1', 'g')
                            endfunction
                            
    1              0.000008 function! xolox#misc#option#join_tags(values) " {{{1
                              " Customized version of `xolox#misc#option#join()` with specialized
                              " handling for Vim's ['tags' option] [tags].
                              let values = copy(a:values)
                              call map(values, 's:escape_tags(v:val)')
                              return join(values, ',')
                            endfunction
                            
    1              0.000006 function! s:escape_tags(s)
                              return escape(a:s, ', ')
                            endfunction
                            
    1              0.000007 function! xolox#misc#option#eval_tags(value, ...) " {{{1
                              " Evaluate Vim's ['tags' option] [tags] without looking at the file
                              " system, i.e. this will report tags files that don't exist yet. Expects
                              " the value of the ['tags' option] [tags] as the first argument. If the
                              " optional second argument is 1 (true) only the first match is returned,
                              " otherwise (so by default) a list with all matches is returned.
                              let pathnames = []
                              let first_only = exists('a:1') ? a:1 : 0
                              for pattern in xolox#misc#option#split_tags(a:value)
                                " Make buffer relative pathnames absolute.
                                if pattern =~ '^\./'
                                  let suffix = matchstr(pattern, '^./\zs.*$')
                                  let directory = (&cpoptions =~# 'd') ? getcwd() : expand('%:p:h')
                                  let pattern = xolox#misc#path#merge(directory, suffix)
                                endif
                                " Make working directory relative pathnames absolute.
                                if xolox#misc#path#is_relative(pattern)
                                  let pattern = xolox#misc#path#merge(getcwd(), pattern)
                                endif
                                " Ignore the trailing `;' for recursive upwards searching because we
                                " always want the most specific pathname available.
                                let pattern = substitute(pattern, ';$', '', '')
                                " Expand the pattern.
                                call extend(pathnames, split(expand(pattern), "\n"))
                                if first_only && !empty(pathnames)
                                  return pathnames[0]
                                endif
                              endfor
                              return first_only ? '' : pathnames
                            endfunction
                            
                            " vim: ts=2 sw=2 et

FUNCTION  <SNR>63_go()
Called 3 times
Total time:   0.007277
 Self time:   0.006058

count  total (s)   self (s)
    3              0.000018   if a:0
    2              0.000021     let [lnum1, lnum2] = [a:type, a:1]
    2              0.000005   else
    1              0.000013     let [lnum1, lnum2] = [line("'["), line("']")]
    1              0.000002   endif
                            
    3   0.000193   0.000054   let [l_, r_] = s:surroundings()
    3              0.000011   let uncomment = 2
   44              0.000087   for lnum in range(lnum1,lnum2)
   41              0.000974     let line = matchstr(getline(lnum),'\S.*\s\@<!')
   41   0.001567   0.000542     let [l, r] = s:strip_white_space(l_,r_,line)
   41              0.000288     if line != '' && (stridx(line,l) || line[strlen(line)-strlen(r) : -1] != r)
   39              0.000113       let uncomment = 0
   39              0.000043     endif
   41              0.000045   endfor
                            
   44              0.000110   for lnum in range(lnum1,lnum2)
   41              0.000175     let line = getline(lnum)
   41              0.000145     if strlen(r) > 2 && l.r !~# '\\'
                                  let line = substitute(line,'\M'.r[0:-2].'\zs\d\*\ze'.r[-1:-1].'\|'.l[0].'\zs\d\*\ze'.l[1:-1],'\=substitute(submatch(0)+1-uncomment,"^0$\\|^-\\d*$","","")','g')
                                endif
   41              0.000058     if uncomment
                                  let line = substitute(line,'\S.*\s\@<!','\=submatch(0)[strlen(l):-strlen(r)-1]','')
                                else
   41              0.001740       let line = substitute(line,'^\%('.matchstr(getline(lnum1),'^\s*').'\|\s*\)\zs.*\S\@<=','\=l.submatch(0).r','')
   41              0.000061     endif
   41              0.000389     call setline(lnum,line)
   41              0.000121   endfor
    3              0.000013   let modelines = &modelines
    3              0.000006   try
    3              0.000035     set modelines=0
    3   0.000274   0.000220     silent doautocmd User CommentaryPost
    3              0.000010   finally
    3              0.000030     let &modelines = modelines
    3              0.000006   endtry

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
Called 1799 times
Total time:   0.025660
 Self time:   0.025660

count  total (s)   self (s)
 1799              0.015919   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
                              endif

FUNCTION  emmet#lang#haml#findTokens()
Called 93 times
Total time:   0.090450
 Self time:   0.001001

count  total (s)   self (s)
   93   0.090360   0.000910   return emmet#lang#html#findTokens(a:str)

FUNCTION  <SNR>125_unmarksigns()
Called 1124 times
Total time:   0.017560
 Self time:   0.009288

count  total (s)   self (s)
 1124   0.016361   0.008089 	if !s:dosigns() | retu | en
                            	for key in keys(s:marked)
                            		exe 'sign unplace' key 'buffer='.s:bufnr
                            	endfo

FUNCTION  <SNR>97_update_untracked_in_buffer_config()
Called 1156 times
Total time:   0.017216
 Self time:   0.017216

count  total (s)   self (s)
 1156              0.010459   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
 1020              0.001777     return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  <SNR>125_autocmds()
Called 109 times
Total time:   0.003223
 Self time:   0.003223

count  total (s)   self (s)
  109              0.000757 	if !has('autocmd') | retu | en
  109              0.001125 	if exists('#CtrlPLazy')
                            		au! CtrlPLazy
                            	en
  109              0.000164 	if s:lazy
                            		aug CtrlPLazy
                            			au!
                            			au CursorHold ControlP cal s:ForceUpdate()
                            		aug END
                            	en

FUNCTION  <SNR>118_cache_needs()
Called 10098 times
Total time:   0.057967
 Self time:   0.057967

count  total (s)   self (s)
10098              0.052695   return !has_key(self.dict, a:key) || (a:0 && a:1 isnot# get(self.dict[a:key], 1, {}))

FUNCTION  1()
Called 545 times
Total time:   0.039196
 Self time:   0.026974

count  total (s)   self (s)
  545              0.001486     let prependCWD = 0
  545   0.007585   0.002329     if nerdtree#runningWindows()
                                    let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
                                else
  545              0.003044         let prependCWD = a:str !~# '^/'
  545              0.000618     endif
                            
  545              0.001259     let toReturn = a:str
  545              0.000804     if prependCWD
  478   0.019050   0.012084         let toReturn = getcwd() . s:Path.Slash() . a:str
  478              0.000541     endif
                            
  545              0.000857     return toReturn

FUNCTION  3()
Called 475 times
Total time:   0.025705
 Self time:   0.016281

count  total (s)   self (s)
  475   0.008310   0.002143     let self.cachedDisplayString = self.getLastPathComponent(1)
                            
  475              0.000603     if self.isExecutable
                                    let self.cachedDisplayString = self.cachedDisplayString . '*'
                                endif
                            
  475              0.000936     let self._bookmarkNames = []
  475   0.005280   0.002023     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
                                endfor
  475              0.001187     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
                                    let self.cachedDisplayString .= ' {' . join(self._bookmarkNames) . '}'
                                endif
                            
  475              0.000508     if self.isSymLink
                                    let self.cachedDisplayString .=  ' -> ' . self.symLinkDest
                                endif
                            
  475              0.000453     if self.isReadOnly
                                    let self.cachedDisplayString .=  ' ['.g:NERDTreeGlyphReadOnly.']'
                                endif

FUNCTION  5()
Called 2 times
Total time:   0.000813
 Self time:   0.000107

count  total (s)   self (s)
    2   0.000066   0.000017     let thisPath = self.getLastPathComponent(1)
    2   0.000060   0.000016     let thatPath = a:path.getLastPathComponent(1)
                            
                                "if the paths are the same then clearly we return 0
    2              0.000006     if thisPath ==# thatPath
    1              0.000001         return 0
                                endif
                            
    1   0.000338   0.000009     let thisSS = self.getSortOrderIndex()
    1   0.000292   0.000009     let thatSS = a:path.getSortOrderIndex()
                            
                                "compare the sort sequences, if they are different then the return
                                "value is easy
    1              0.000002     if thisSS < thatSS
                                    return -1
                                elseif thisSS > thatSS
                                    return 1
                                else
    1              0.000003         if !g:NERDTreeSortHiddenFirst
                                        let thisPath = substitute(thisPath, '^[._]', '', '')
                                        let thatPath = substitute(thatPath, '^[._]', '', '')
                                    endif
                                    "if the sort sequences are the same then compare the paths
                                    "alphabetically
    1              0.000008         let pathCompare = g:NERDTreeCaseSensitiveSort ? thisPath <# thatPath : thisPath <? thatPath
    1              0.000002         if pathCompare
                                        return -1
                                    else
    1              0.000002             return 1
                                    endif
                                endif

FUNCTION  <SNR>63_surroundings()
Called 3 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
    3              0.000134   return split(get(b:, 'commentary_format', substitute(substitute( &commentstring, '\S\zs%s',' %s','') ,'%s\ze\S', '%s ', '')), '%s', 1)

FUNCTION  emmet#getExpandos()
Called 26 times
Total time:   0.018789
 Self time:   0.000536

count  total (s)   self (s)
   26   0.018521   0.000268   let expandos = emmet#getResource(a:type, 'expandos', {})
   26              0.000091   if has_key(expandos, a:key)
                                return expandos[a:key]
                              endif
   26              0.000043   return a:key

FUNCTION  <SNR>125_openfile()
Called 75 times
Total time: 425.672705
 Self time:   4.080191

count  total (s)   self (s)
   75              0.000372 	let cmd = a:cmd
   75   0.002360   0.001802 	if a:chkmod && cmd =~ '^[eb]$' && ctrlp#modfilecond(!( cmd == 'b' && &aw ))
                            		let cmd = cmd == 'b' ? 'sb' : 'sp'
                            	en
   75              0.000908 	let cmd = cmd =~ '^tab' ? ctrlp#tabcount().cmd : cmd
   75              0.000726 	let j2l = a:0 && a:1[0] ? a:1[1] : 0
   75 425.643814   4.072694 	exe cmd.( a:0 && a:1[0] ? '' : a:tail ) s:fnesc(a:fid, 'f')
   75              0.000187 	if j2l
                            		cal ctrlp#j2l(j2l)
                            	en
   75              0.000230 	if !empty(a:tail)
                            		sil! norm! zvzz
                            	en
   75              0.000224 	if cmd != 'bad'
   75   0.021438   0.000601 		cal ctrlp#setlcdir()
   75              0.000069 	en

FUNCTION  <SNR>72_abbrev()
Called 106 times
Total time:   0.001824
 Self time:   0.001824

count  total (s)   self (s)
  106              0.000546   if exists('g:endwise_abbreviations')
                                for word in split(get(b:, 'endwise_words', ''), ',')
                                  execute 'iabbrev <buffer><script>' word word.'<CR><SID>DiscretionaryEnd<Space><C-U><BS>'
                                endfor
                              endif

FUNCTION  <SNR>125_Update()
Called 1019 times
Total time:   9.496480
 Self time:   0.081614

count  total (s)   self (s)
                            	" Get the previous string if existed
 1019              0.007141 	let oldstr = exists('s:savestr') ? s:savestr : ''
                            	" Get the new string sans tail
 1019   0.104942   0.009464 	let str = s:sanstail(a:str)
                            	" Stop if the string's unchanged
 1019              0.007850 	if str == oldstr && !empty(str) && !exists('s:force') | retu | en
 1015              0.013992 	let s:martcs = &scs && str =~ '\u' ? '\C' : ''
 1015   0.248067   0.014162 	let pat = s:matcher == {} ? s:SplitPattern(str) : str
 1015   0.756009   0.015930 	let lines = s:nolim == 1 && empty(str) ? copy(g:ctrlp_lines) : s:MatchedItems(g:ctrlp_lines, pat, s:mw_res)
 1015   8.353065   0.007660 	cal s:Render(lines, pat)

FUNCTION  airline#util#exec_funcrefs()
Called 2516 times
Total time:   1.658026
 Self time:   0.130732

count  total (s)   self (s)
 9952              0.019664     for Fn in a:list
 9943   1.593528   0.066234       let code = call(Fn, a:000)
 9943              0.014603       if code != 0
 2507              0.002983         return code
                                  endif
 7436              0.006597     endfor
    9              0.000007     return 0

FUNCTION  emmet#useFilter()
Called 54 times
Total time:   0.000930
 Self time:   0.000930

count  total (s)   self (s)
  108              0.000190   for f in a:filters
   54              0.000113     if a:filter ==# '/' && f =~# '^/'
                                  return 1
                                elseif f ==# a:filter
                                  return 1
                                endif
   54              0.000038   endfor
   54              0.000045   return 0

FUNCTION  airline#extensions#netrw#apply()
Called 708 times
Total time:   0.014132
 Self time:   0.014132

count  total (s)   self (s)
  708              0.002724   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  RailsDetect()
Called 298 times
Total time:   0.055963
 Self time:   0.055963

count  total (s)   self (s)
  298              0.001415   if exists('b:rails_root')
  262              0.000430     return 1
                              endif
   36              0.000413   let fn = fnamemodify(a:0 ? a:1 : expand('%'), ':p')
   36              0.000264   if fn =~# ':[\/]\{2\}'
                                return 0
                              endif
   36              0.000168   if !isdirectory(fn)
   36              0.000152     let fn = fnamemodify(fn, ':h')
   36              0.000033   endif
   36              0.050139   let file = findfile('config/environment.rb', escape(fn, ', ').';')
   36              0.001177   if !empty(file) && isdirectory(fnamemodify(file, ':p:h:h') . '/app')
   34              0.000902     let b:rails_root = fnamemodify(file, ':p:h:h')
   34              0.000058     return 1
                              endif

FUNCTION  AutoPairsSpace()
Called 338 times
Total time:   0.029761
 Self time:   0.029761

count  total (s)   self (s)
  338              0.007631   let line = getline('.')
  338              0.005313   let prev_char = line[col('.')-2]
  338              0.001316   let cmd = ''
  338              0.002689   let cur_char =line[col('.')-1]
  338              0.003513   if has_key(g:AutoPairsParens, prev_char) && g:AutoPairsParens[prev_char] == cur_char
                                let cmd = "\<SPACE>".s:Left
                              endif
  338              0.002348   return "\<SPACE>".cmd

FUNCTION  <SNR>118_getlist()
Called 43 times
Total time:   0.000364
 Self time:   0.000364

count  total (s)   self (s)
   43              0.000160   let value = get(a:arg, a:key, [])
   43              0.000172   return type(value) == type([]) ? copy(value) : [value]

FUNCTION  gitgutter#utility#highlight_name_for_change()
Called 129440 times
Total time:   0.485367
 Self time:   0.485367

count  total (s)   self (s)
129440              0.236621   if a:text ==# 'added'
129127              0.167726     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
    1              0.000001     return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
  312              0.000387     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              endif

FUNCTION  gitgutter#utility#command_in_directory_of_file()
Called 2113 times
Total time:   0.098888
 Self time:   0.031219

count  total (s)   self (s)
 2113   0.096481   0.028812   return 'cd '.gitgutter#utility#shellescape(gitgutter#utility#directory_of_file()).' && '.a:cmd

FUNCTION  gitgutter#async#handle_diff_job_nvim()
Called 4227 times
Total time:  23.434641
 Self time:   0.534270

count  total (s)   self (s)
 4227   0.343577   0.097096   call gitgutter#debug#log('job_id: '.a:job_id.', event: '.a:event.', buffer: '.self.buffer)
                            
 4227              0.019470   let job_bufnr = self.buffer
 4227              0.019227   if bufexists(job_bufnr)
 4227   0.058691   0.039067     let current_buffer = gitgutter#utility#bufnr()
 4227   0.157854   0.034761     call gitgutter#utility#set_buffer(job_bufnr)
                            
 4227              0.017355     if a:event == 'stdout'
                                  " a:data is a list
 1444   0.033277   0.012093       call s:job_finished(a:job_id)
 1444   0.187399   0.007037       if gitgutter#utility#is_active()
 1444  22.222832   0.071428         call gitgutter#handle_diff(gitgutter#utility#stringify(a:data))
 1444              0.001698       endif
                            
 1444              0.002088     elseif a:event == 'exit'
                                  " If the exit event is triggered without a preceding stdout event,
                                  " the diff was empty.
 2111   0.022357   0.011790       if s:is_job_started(a:job_id)
                                    if gitgutter#utility#is_active()
                                      call gitgutter#handle_diff("")
                                    endif
                                    call s:job_finished(a:job_id)
                                  endif
                            
 2111              0.002471     else  " a:event is stderr
  672   0.070316   0.004720       call gitgutter#hunk#reset()
  672   0.015513   0.006464       call s:job_finished(a:job_id)
                            
  672              0.000699     endif
                            
 4227   0.096249   0.023239     call gitgutter#utility#set_buffer(current_buffer)
 4227              0.004993   else
                                call s:job_finished(a:job_id)
                              endif

FUNCTION  <SNR>15_ExpandMap()
Called 48 times
Total time:   0.001863
 Self time:   0.001863

count  total (s)   self (s)
   48              0.000162   let map = a:map
   48              0.001477   let map = substitute(map, '\(<Plug>\w\+\)', '\=maparg(submatch(1), "i")', 'g')
   48              0.000118   return map

FUNCTION  <SNR>70_wrap()
Called 1 time
Total time:   0.000537
 Self time:   0.000537

count  total (s)   self (s)
    1              0.000005   let keeper = a:string
    1              0.000003   let newchar = a:char
    1              0.000003   let s:input = ""
    1              0.000003   let type = a:type
    1              0.000004   let linemode = type ==# 'V' ? 1 : 0
    1              0.000002   let before = ""
    1              0.000002   let after  = ""
    1              0.000002   if type ==# "V"
                                let initspaces = matchstr(keeper,'\%^\s*')
                              else
    1              0.000016     let initspaces = matchstr(getline('.'),'\%^\s*')
    1              0.000002   endif
    1              0.000003   let pairs = "b()B{}r[]a<>"
    1              0.000002   let extraspace = ""
    1              0.000005   if newchar =~ '^ '
                                let newchar = strpart(newchar,1)
                                let extraspace = ' '
                              endif
    1              0.000006   let idx = stridx(pairs,newchar)
    1              0.000003   if newchar == ' '
                                let before = ''
                                let after  = ''
                              elseif exists("b:surround_".char2nr(newchar))
                                let all    = s:process(b:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif exists("g:surround_".char2nr(newchar))
                                let all    = s:process(g:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif newchar ==# "p"
                                let before = "\n"
                                let after  = "\n\n"
                              elseif newchar ==# 's'
                                let before = ' '
                                let after  = ''
                              elseif newchar ==# ':'
                                let before = ':'
                                let after = ''
                              elseif newchar =~# "[tT\<C-T><]"
                                let dounmapp = 0
                                let dounmapb = 0
                                if !maparg(">","c")
                                  let dounmapb = 1
                                  " Hide from AsNeeded
                                  exe "cn"."oremap > ><CR>"
                                endif
                                let default = ""
                                if newchar ==# "T"
                                  if !exists("s:lastdel")
                                    let s:lastdel = ""
                                  endif
                                  let default = matchstr(s:lastdel,'<\zs.\{-\}\ze>')
                                endif
                                let tag = input("<",default)
                                if dounmapb
                                  silent! cunmap >
                                endif
                                let s:input = tag
                                if tag != ""
                                  let keepAttributes = ( match(tag, ">$") == -1 )
                                  let tag = substitute(tag,'>*$','','')
                                  let attributes = ""
                                  if keepAttributes
                                    let attributes = matchstr(a:removed, '<[^ \t\n]\+\zs\_.\{-\}\ze>')
                                  endif
                                  let s:input = tag . '>'
                                  if tag =~ '/$'
                                    let tag = substitute(tag, '/$', '', '')
                                    let before = '<'.tag.attributes.' />'
                                    let after = ''
                                  else
                                    let before = '<'.tag.attributes.'>'
                                    let after  = '</'.substitute(tag,' .*','','').'>'
                                  endif
                                  if newchar == "\<C-T>"
                                    if type ==# "v" || type ==# "V"
                                      let before .= "\n\t"
                                    endif
                                    if type ==# "v"
                                      let after  = "\n". after
                                    endif
                                  endif
                                endif
                              elseif newchar ==# 'l' || newchar == '\'
                                " LaTeX
                                let env = input('\begin{')
                                if env != ""
                                  let s:input = env."\<CR>"
                                  let env = '{' . env
                                  let env .= s:closematch(env)
                                  echo '\begin'.env
                                  let before = '\begin'.env
                                  let after  = '\end'.matchstr(env,'[^}]*').'}'
                                endif
                              elseif newchar ==# 'f' || newchar ==# 'F'
                                let fnc = input('function: ')
                                if fnc != ""
                                  let s:input = fnc."\<CR>"
                                  let before = substitute(fnc,'($','','').'('
                                  let after  = ')'
                                  if newchar ==# 'F'
                                    let before .= ' '
                                    let after = ' ' . after
                                  endif
                                endif
                              elseif newchar ==# "\<C-F>"
                                let fnc = input('function: ')
                                let s:input = fnc."\<CR>"
                                let before = '('.fnc.' '
                                let after = ')'
                              elseif idx >= 0
    1              0.000004     let spc = (idx % 3) == 1 ? " " : ""
    1              0.000003     let idx = idx / 3 * 3
    1              0.000009     let before = strpart(pairs,idx+1,1) . spc
    1              0.000006     let after  = spc . strpart(pairs,idx+2,1)
    1              0.000002   elseif newchar == "\<C-[>" || newchar == "\<C-]>"
                                let before = "{\n\t"
                                let after  = "\n}"
                              elseif newchar !~ '\a'
                                let before = newchar
                                let after  = newchar
                              else
                                let before = ''
                                let after  = ''
                              endif
    1              0.000008   let after  = substitute(after ,'\n','\n'.initspaces,'g')
    1              0.000004   if type ==# 'V' || (a:special && type ==# "v")
                                let before = substitute(before,' \+$','','')
                                let after  = substitute(after ,'^ \+','','')
                                if after !~ '^\n'
                                  let after  = initspaces.after
                                endif
                                if keeper !~ '\n$' && after !~ '^\n'
                                  let keeper .= "\n"
                                elseif keeper =~ '\n$' && after =~ '^\n'
                                  let after = strpart(after,1)
                                endif
                                if before !~ '\n\s*$'
                                  let before .= "\n"
                                  if a:special
                                    let before .= "\t"
                                  endif
                                endif
                              endif
    1              0.000002   if type ==# 'V'
                                let before = initspaces.before
                              endif
    1              0.000006   if before =~ '\n\s*\%$'
                                if type ==# 'v'
                                  let keeper = initspaces.keeper
                                endif
                                let padding = matchstr(before,'\n\zs\s\+\%$')
                                let before  = substitute(before,'\n\s\+\%$','\n','')
                                let keeper = s:fixindent(keeper,padding)
                              endif
    1              0.000009   if type ==# 'V'
                                let keeper = before.keeper.after
                              elseif type =~ "^\<C-V>"
                                " Really we should be iterating over the buffer
                                let repl = substitute(before,'[\\~]','\\&','g').'\1'.substitute(after,'[\\~]','\\&','g')
                                let repl = substitute(repl,'\n',' ','g')
                                let keeper = substitute(keeper."\n",'\(.\{-\}\)\(\n\)',repl.'\n','g')
                                let keeper = substitute(keeper,'\n\%$','','')
                              else
    1              0.000011     let keeper = before.extraspace.keeper.extraspace.after
    1              0.000002   endif
    1              0.000003   return keeper

FUNCTION  gitgutter#utility#system()
Called 2 times
Total time:   0.059410
 Self time:   0.059168

count  total (s)   self (s)
    2   0.000202   0.000031   call gitgutter#debug#log(a:cmd, a:000)
                            
    2   0.000087   0.000016   if gitgutter#utility#using_xolox_shell()
                                let options = {'command': a:cmd, 'check': 0}
                                if a:0 > 0
                                  let options['stdin'] = a:1
                                endif
                                let ret = xolox#misc#os#exec(options)
                                let output = join(ret.stdout, "\n")
                                let s:exit_code = ret.exit_code
                              else
    2              0.059009     silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
    2              0.000018   endif
    2              0.000019   return output

FUNCTION  <SNR>118_split()
Called 20941 times
Total time:   0.128573
 Self time:   0.128573

count  total (s)   self (s)
20941              0.116712   return type(a:arg) == type([]) ? copy(a:arg) : split(a:arg, a:0 ? a:1 : "\n")

FUNCTION  <SNR>111_should_change_group()
Called 22467 times
Total time:   5.204918
 Self time:   0.412873

count  total (s)   self (s)
22467              0.056564   if a:group1 == a:group2
 5039              0.005328     return 0
                              endif
17428   2.592471   0.094004   let color1 = airline#highlighter#get_highlight(a:group1)
17428   2.388141   0.094563   let color2 = airline#highlighter#get_highlight(a:group2)
17428              0.033624   if g:airline_gui_mode ==# 'gui'
17428              0.073960     return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>118_app_asset_path()
Called 40 times
Total time:   0.008587
 Self time:   0.002970

count  total (s)   self (s)
   40   0.002879   0.000347   let gems = self.gems()
   40   0.000477   0.000207   if self.cache.needs('gem_assets', gems)
   40              0.000080     let path = []
   40              0.000210     let gempath = escape(join(values(gems),','), ' ')
   40              0.000084     if !empty(gempath)
                                  call extend(path, finddir('app/assets/', gempath, -1))
                                  call extend(path, finddir('lib/assets/', gempath, -1))
                                  call extend(path, finddir('vendor/assets/', gempath, -1))
                                  call extend(path, finddir('assets/', gempath, -1))
                                  call map(path, 'v:val . "*"')
                                  call sort(path)
                                endif
   40   0.000453   0.000222     call self.cache.set('gem_assets', path, gems)
   40              0.000037   endif
   40   0.003386   0.000802   return extend([self.path('app/assets/*'), self.path('lib/assets/*'), self.path('vendor/assets/*'), self.path('node_modules')], self.cache.get('gem_assets'))

FUNCTION  <SNR>118_buffer_number()
Called 17321 times
Total time:   0.040715
 Self time:   0.040715

count  total (s)   self (s)
17321              0.032975   return self['#']

FUNCTION  airline#extensions#tabline#buflist#invalidate()
Called 631 times
Total time:   0.004572
 Self time:   0.004572

count  total (s)   self (s)
  631              0.003909   unlet! s:current_buffer_list

FUNCTION  <SNR>118_buffer_getvar()
Called 13521 times
Total time:   0.109758
 Self time:   0.078890

count  total (s)   self (s)
13521   0.104200   0.073332   return getbufvar(self.number(),a:varname)

FUNCTION  <SNR>65_cpath()
Called 244 times
Total time:   0.002706
 Self time:   0.002706

count  total (s)   self (s)
  244              0.001157   if exists('+fileignorecase') && &fileignorecase
                                return tolower(a:path)
                              else
  244              0.000410     return a:path
                              endif

FUNCTION  <SNR>125_mfunc()
Called 118 times
Total time:   0.003467
 Self time:   0.003056

count  total (s)   self (s)
  118              0.000360 	let mfunc = 'match'
  118   0.001009   0.000597 	if s:byfname()
                            		let mfunc = 's:matchfname'
                            	elsei s:itemtype > 2
                            		let matchtypes = { 'tabs': 's:matchtabs', 'tabe': 's:matchtabe' }
                            		if has_key(matchtypes, s:matchtype)
                            			let mfunc = matchtypes[s:matchtype]
                            		en
                            	en
  118              0.000200 	retu mfunc

FUNCTION  repeat#wrap()
Called 247 times
Total time:   0.065145
 Self time:   0.065145

count  total (s)   self (s)
  247              0.002999     let preserve = (g:repeat_tick == b:changedtick)
  247              0.058276     exe 'norm! '.(a:count ? a:count : '').a:command . (&foldopen =~# 'undo\|all' ? 'zv' : '')
  247              0.001259     if preserve
    1              0.000005         let g:repeat_tick = b:changedtick
    1              0.000002     endif

FUNCTION  <SNR>125_MatchIt()
Called 1015 times
Total time:   0.654742
 Self time:   0.635358

count  total (s)   self (s)
 1015              0.005539 	let [lines, id] = [[], 0]
 1015   0.015186   0.011443 	let pat = s:byfname() ? map(split(a:pat, '^[^;]\+\\\@<!\zs;', 1), 's:martcs.v:val') : s:martcs.a:pat
16588              0.030201 	for item in a:items
16022              0.032579 		let id += 1
31029              0.284694 		try | if !( s:ispath && item == a:exc ) && call(s:mfunc, [item, pat]) >= 0
 6538              0.024652 			cal add(lines, item)
22014              0.026810 		en | cat | brea | endt
16471              0.057940 		if a:limit > 0 && len(lines) >= a:limit | brea | en
15573              0.024160 	endfo
 1015   0.031865   0.016224 	let s:mdata = [s:dyncwd, s:itemtype, s:regexp, s:sublist(a:items, id, -1)]
 1015              0.002191 	retu lines

FUNCTION  <SNR>62__delete_dumb()
Called 1 time
Total time:   0.775383
 Self time:   0.000081

count  total (s)   self (s)
    1              0.000010     if !exists('s:rmrf')
    1              0.000019         let s:rmrf = has('unix') || has('mac') ? 'rm -rf' : has('win32') || has('win64') ? 'rmdir /S /Q' : has('win16') || has('win95') || has('dos16') || has('dos32') ? 'deltree /Y' : ''
    1              0.000002     endif
                            
    1              0.000004     if s:rmrf !=# ''
    1   0.775336   0.000034         silent! call syntastic#util#system(s:rmrf . ' ' . syntastic#util#shescape(a:what))
    1              0.000002     else
                                    call s:_rmrf(a:what)
                                endif

FUNCTION  gitgutter#utility#dedup()
Called 10 times
Total time:   0.000518
 Self time:   0.000518

count  total (s)   self (s)
   10              0.000453   return filter(sort(a:list), 'index(a:list, v:val, v:key + 1) == -1')

FUNCTION  emmet#lang#haml#toString()
Called 25 times
Total time:   0.011811
 Self time:   0.005438

count  total (s)   self (s)
   25              0.000062   let settings = a:settings
   25              0.000057   let current = a:current
   25              0.000047   let type = a:type
   25              0.000042   let inline = a:inline
   25              0.000039   let filters = a:filters
   25              0.000038   let itemno = a:itemno
   25   0.000881   0.000127   let indent = emmet#getIndentation(type)
   25   0.002679   0.000149   let dollar_expr = emmet#getResource(type, 'dollar_expr', 1)
   25   0.002298   0.000158   let attribute_style = emmet#getResource('haml', 'attribute_style', 'hash')
   25              0.000038   let str = ''
                            
   25              0.000053   let current_name = current.name
   25              0.000030   if dollar_expr
   25              0.000171     let current_name = substitute(current.name, '\$$', itemno+1, '')
   25              0.000022   endif
   25              0.000053   if len(current.name) > 0
   25              0.000070     let str .= '%' . current_name
   25              0.000034     let tmp = ''
   76   0.001381   0.000433     for attr in emmet#util#unique(current.attrs_order + keys(current.attr))
   51              0.000113       if !has_key(current.attr, attr)
   50              0.000054         continue
                                  endif
    1              0.000002       let Val = current.attr[attr]
    1              0.000003       if type(Val) == 2 && Val == function('emmet#types#true')
                                    if attribute_style ==# 'hash'
                                      let tmp .= ' :' . attr . ' => true'
                                    elseif attribute_style ==# 'html'
                                      let tmp .= attr . '=true'
                                    end
                                  else
    1              0.000001         if dollar_expr
    1              0.000006           while Val =~# '\$\([^#{]\|$\)'
                                        let Val = substitute(Val, '\(\$\+\)\([^{]\|$\)', '\=printf("%0".len(submatch(1))."d", itemno+1).submatch(2)', 'g')
                                      endwhile
    1              0.000005           let attr = substitute(attr, '\$$', itemno+1, '')
    1              0.000001         endif
    1              0.000005         let valtmp = substitute(Val, '\${cursor}', '', '')
    1              0.000002         if attr ==# 'id' && len(valtmp) > 0
                                      let str .= '#' . Val
                                    elseif attr ==# 'class' && len(valtmp) > 0
                                      let str .= '.' . substitute(Val, ' ', '.', 'g')
                                    else
    1              0.000002           if len(tmp) > 0 
                                        if attribute_style ==# 'hash'
                                          let tmp .= ',' 
                                        elseif attribute_style ==# 'html'
                                          let tmp .= ' ' 
                                        endif
                                      endif
    1              0.000001           if attribute_style ==# 'hash'
    1              0.000003             let tmp .= ' :' . attr . ' => "' . Val . '"'
    1              0.000001           elseif attribute_style ==# 'html'
                                        let tmp .= attr . '="' . Val . '"'
                                      end
    1              0.000000         endif
    1              0.000000       endif
    1              0.000001     endfor
   25              0.000052     if len(tmp)
    1              0.000001       if attribute_style ==# 'hash'
    1              0.000002         let str .= '{' . tmp . ' }'
    1              0.000001       elseif attribute_style ==# 'html'
                                    let str .= '(' . tmp . ')'
                                  end
    1              0.000000     endif
   25              0.000156     if stridx(','.settings.html.empty_elements.',', ','.current_name.',') != -1 && len(current.value) == 0
    1              0.000002       let str .= '/'
    1              0.000001     endif
                            
   25              0.000038     let inner = ''
   25              0.000054     if len(current.value) > 0
                                  let text = current.value[1:-2]
                                  if dollar_expr
                                    let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", itemno+1).submatch(2)', 'g')
                                    let text = substitute(text, '\${nr}', "\n", 'g')
                                    let text = substitute(text, '\\\$', '$', 'g')
                                    let str = substitute(str, '\$#', text, 'g')
                                  endif
                                  let lines = split(text, "\n")
                                  if len(lines) == 1
                                    let str .= ' ' . text
                                  else
                                    for line in lines
                                      let str .= "\n" . indent . line . ' |'
                                    endfor
                                  endif
                                elseif len(current.child) == 0
   25              0.000053       let str .= '${cursor}'
   25              0.000017     endif
   25              0.000069     if len(current.child) == 1 && len(current.child[0].name) == 0
                                  let text = current.child[0].value[1:-2]
                                  if dollar_expr
                                    let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", itemno+1).submatch(2)', 'g')
                                    let text = substitute(text, '\${nr}', "\n", 'g')
                                    let text = substitute(text, '\\\$', '$', 'g')
                                  endif
                                  let lines = split(text, "\n")
                                  if len(lines) == 1
                                    let str .= ' ' . text
                                  else
                                    for line in lines
                                      let str .= "\n" . indent . line . ' |'
                                    endfor
                                  endif
                                elseif len(current.child) > 0
                                  for child in current.child
                                    let inner .= emmet#toString(child, type, inline, filters, itemno, indent)
                                  endfor
                                  let inner = substitute(inner, "\n", "\n" . escape(indent, '\'), 'g')
                                  let inner = substitute(inner, "\n" . escape(indent, '\') . '$', '', 'g')
                                  let str .= "\n" . indent . inner
                                endif
   25              0.000017   else
                                let str = current.value[1:-2]
                                if dollar_expr
                                  let str = substitute(str, '\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", itemno+1).submatch(2)', 'g')
                                  let str = substitute(str, '\${nr}', "\n", 'g')
                                  let str = substitute(str, '\\\$', '$', 'g')
                                endif
                              endif
   25              0.000042   let str .= "\n"
   25              0.000031   return str

FUNCTION  ctrlp#acceptfile()
Called 77 times
Total time: 427.218193
 Self time:   0.108100

count  total (s)   self (s)
   77              0.000291 	let useb = 0
   77              0.000406 	if a:0 == 1 && type(a:1) == 4
   77              0.000664 		let [md, line] = [a:1['action'], a:1['line']]
   77              0.000519 		let atl = has_key(a:1, 'tail') ? a:1['tail'] : ''
   77              0.000103 	el
                            		let [md, line] = [a:1, a:2]
                            		let atl = a:0 > 2 ? a:3 : ''
                            	en
   77              0.000236 	if !type(line)
                            		let [filpath, bufnr, useb] = [line, line, 1]
                            	el
   77              0.007622 		let filpath = fnamemodify(line, ':p')
   77   0.003913   0.001044 		if s:nonamecond(line, filpath)
                            			let bufnr = str2nr(matchstr(line, '[\/]\?\[\zs\d\+\ze\*No Name\]$'))
                            			let [filpath, useb] = [bufnr, 1]
                            		el
   77              0.073563 			let bufnr = bufnr('^'.filpath.'$')
   77              0.000182 		en
   77              0.000076 	en
   77   1.337198   0.000994 	cal s:PrtExit()
   77   0.002982   0.001076 	let tail = s:tail()
   77              0.001983 	let j2l = atl != '' ? atl : matchstr(tail, '^ +\zs\d\+$')
   77              0.001603 	if ( s:jmptobuf =~ md || ( s:jmptobuf && md =~ '[et]' ) ) && bufnr > 0 && !( md == 'e' && bufnr == bufnr('%') )
   33              0.000448 		let [jmpb, bufwinnr] = [1, bufwinnr(bufnr)]
   33   0.004748   0.001053 		let buftab = ( s:jmptobuf =~# '[tTVH]' || s:jmptobuf > 1 ) ? s:buftab(bufnr, md) : [0, 0]
   33              0.000051 	en
                            	" Switch to existing buffer or open new one
   77              0.000828 	if exists('jmpb') && bufwinnr > 0 && !( md == 't' && ( s:jmptobuf !~# toupper(md) || buftab[0] ) )
    2   0.085567   0.000074 		exe bufwinnr.'winc w'
    2              0.000019 		if j2l | cal ctrlp#j2l(j2l) | en
    2              0.000015 	elsei exists('jmpb') && buftab[0] && !( md =~ '[evh]' && s:jmptobuf !~# toupper(md) )
                            		exe 'tabn' buftab[0]
                            		exe buftab[1].'winc w'
                            		if j2l | cal ctrlp#j2l(j2l) | en
                            	el
                            		" Determine the command to use
   75              0.000957 		let useb = bufnr > 0 && buflisted(bufnr) && ( empty(tail) || useb )
   75   0.009134   0.001912 		let cmd = md == 't' || s:splitwin == 1 ? ( useb ? 'tab sb' : 'tabe' ) : md == 'h' || s:splitwin == 2 ? ( useb ? 'sb' : 'new' ) : md == 'v' || s:splitwin == 3 ? ( useb ? 'vert sb' : 'vne' ) : call('ctrlp#normcmd', useb ? ['b', 'bo vert sb'] : ['e'])
                            		" Reset &switchbuf option
   75              0.001257 		let [swb, &swb] = [&swb, '']
                            		" Open new window/buffer
   75              0.000840 		let [fid, tail] = [( useb ? bufnr : filpath ), ( atl != '' ? ' +'.atl : tail )]
   75              0.000600 		let args = [cmd, fid, tail, 1, [useb, j2l]]
   75 425.674344   0.001639 		cal call('s:openfile', args)
   75              0.000968 		let &swb = swb
   75              0.000101 	en

FUNCTION  gitgutter#diff#process_hunk()
Called 2779 times
Total time:   1.740435
 Self time:   0.194584

count  total (s)   self (s)
 2779              0.009362   let modifications = []
 2779              0.009149   let from_line  = a:hunk[0]
 2779              0.007590   let from_count = a:hunk[1]
 2779              0.006780   let to_line    = a:hunk[2]
 2779              0.006637   let to_count   = a:hunk[3]
                            
 2779   0.022801   0.012986   if gitgutter#diff#is_added(from_count, to_count)
 2622   1.370378   0.016899     call gitgutter#diff#process_added(modifications, from_count, to_count, to_line)
 2622   0.152968   0.015414     call gitgutter#hunk#increment_lines_added(to_count)
                            
 2622              0.006464   elseif gitgutter#diff#is_removed(from_count, to_count)
    1   0.000027   0.000016     call gitgutter#diff#process_removed(modifications, from_count, to_count, to_line)
    1   0.000073   0.000013     call gitgutter#hunk#increment_lines_removed(from_count)
                            
    1              0.000003   elseif gitgutter#diff#is_modified(from_count, to_count)
                                call gitgutter#diff#process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                            
                              elseif gitgutter#diff#is_modified_and_added(from_count, to_count)
  156   0.024054   0.001231     call gitgutter#diff#process_modified_and_added(modifications, from_count, to_count, to_line)
  156   0.011411   0.000956     call gitgutter#hunk#increment_lines_added(to_count - from_count)
  156   0.009247   0.000873     call gitgutter#hunk#increment_lines_modified(from_count)
                            
  156              0.000462   elseif gitgutter#diff#is_modified_and_removed(from_count, to_count)
                                call gitgutter#diff#process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                                call gitgutter#hunk#increment_lines_removed(from_count - to_count)
                            
                              endif
 2779              0.003791   return modifications

FUNCTION  <SNR>118_app_has()
Called 7977 times
Total time:   0.354742
 Self time:   0.269258

count  total (s)   self (s)
 7977              0.077413   let map = {'test': 'test/','spec': 'spec/','bundler': 'Gemfile|gems.locked','rails2': 'script/about','rails3': 'config/application.rb','rails5': 'app/assets/config/manifest.js|config/initializers/application_controller_renderer.rb','cucumber': 'features/','turnip': 'spec/acceptance/','sass': 'public/stylesheets/sass/'}
 7977   0.077978   0.033355   if self.cache.needs('features')
                                call self.cache.set('features',{})
                              endif
 7977   0.082064   0.041203   let features = self.cache.get('features')
 7977              0.022247   if !has_key(features,a:feature)
                                let path = get(map,a:feature,a:feature.'/')
                                let features[a:feature] = !empty(filter(split(path, '|'), 'self.has_path(v:val)'))
                              endif
 7977              0.015392   return features[a:feature]

FUNCTION  emmet#getFileType()
Called 149 times
Total time:   0.016719
 Self time:   0.016719

count  total (s)   self (s)
  149              0.001268   let flg = get(a:000, 0, 0)
  149              0.000547   let type = ''
                            
  149              0.001261   if has_key(s:emmet_settings, &filetype)
  149              0.000517     let type = &filetype
  149              0.000250   else
                                let types = split(&filetype, '\.')
                                for part in types
                                  if emmet#lang#exists(part)
                                    let type = part
                                    break
                                  endif
                                  let base = emmet#getBaseType(part)
                                  if base !=# ''
                                    if flg
                                      let type = &filetype
                                    else
                                      let type = base
                                    endif
                                    unlet base
                                    break
                                  endif
                                endfor
                              endif
  149              0.000482   if type ==# 'html'
                                let pos = emmet#util#getcurpos()
                                let type = synIDattr(synID(pos[1], pos[2], 1), 'name')
                                if type =~# '^css\w'
                                  let type = 'css'
                                endif
                                if type =~# '^html\w'
                                  let type = 'html'
                                endif
                                if type =~# '^javaScript'
                                  let type = 'javascript'
                                endif
                                if len(type) ==# 0 && type =~# '^xml'
                                  let type = 'xml'
                                endif
                              endif
  149              0.000949   if len(type) ==# 0 | let type = 'html' | endif
  149              0.000376   return type

FUNCTION  <SNR>72_teardownMappings()
Called 2 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000037   inoremap <buffer> <C-X><CR> <C-X><CR>
    2              0.000020   inoremap <buffer> <CR> <CR>

FUNCTION  <SNR>118_buffer_name()
Called 2340 times
Total time:   0.499890
 Self time:   0.244513

count  total (s)   self (s)
 2340   0.153181   0.010862   let app = self.app()
 2340   0.160225   0.133727   let f = s:gsub(resolve(fnamemodify(bufname(self.number()),':p')),'\\ @!','/')
 2340   0.031417   0.012449   let f = s:sub(f,'/$','')
 2340              0.025121   let sep = matchstr(f,'^[^\\/]\{3,\}\zs[\\/]')
 2340              0.004888   if sep != ""
                                let f = getcwd().sep.f
                              endif
 2340   0.082102   0.032859   if s:startswith(tolower(f),s:gsub(tolower(app.path()),'\\ @!','/')) || f == ""
 2340   0.032333   0.013985     return strpart(f,strlen(app.path())+1)
                              else
                                if !exists("s:path_warn") && &verbose
                                  let s:path_warn = 1
                                  call s:warn("File ".f." does not appear to be under the Rails root ".self.app().path().". Please report to the rails.vim author!")
                                endif
                                return f
                              endif

FUNCTION  syntastic#log#debugShowOptions()
Called 503 times
Total time:   0.006167
 Self time:   0.003991

count  total (s)   self (s)
  503   0.005010   0.002833     if !s:_isDebugEnabled(a:level)
  503              0.000622         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                let add_shell = index(vlist, 'shell') >= 0 && &shell !=# syntastic#util#var('shell')
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    if add_shell
                                        call add(vlist, 'u:shell = ' . strtrans(string(syntastic#util#var('shell'))) . ' (!)')
                                    endif
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  258()
Called 122 times
Total time:   0.000397
 Self time:   0.000397

count  total (s)   self (s)
  122              0.000300     return '.. (up a dir)'

FUNCTION  airline#check_mode()
Called 46949 times
Total time: 326.246973
 Self time:   7.247238

count  total (s)   self (s)
46949              0.284042   if !exists("s:airline_run")
                                let s:airline_run = 0
                              endif
46949              0.202266   let s:airline_run += 1
                            
46949              0.263553   let context = s:contexts[a:winnr]
                            
46949              0.261104   if get(w:, 'airline_active', 1)
32153              0.152055     let l:m = mode()
32153              0.105487     if l:m ==# "i"
12394              0.055566       let l:mode = ['insert']
12394              0.029859     elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
  494              0.002071       let l:mode = ['visual']
  494              0.000972     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
19265              0.084628       let l:mode = ['normal']
19265              0.029494     endif
32153              0.283757     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
32153              0.049288   else
14796              0.053493     let l:mode = ['inactive']
14796              0.093136     let w:airline_current_mode = get(g:airline_mode_map, '__')
14796              0.017602   endif
                            
46949              0.199306   if g:airline_detect_modified && &modified
19064              0.101362     call add(l:mode, 'modified')
19064              0.025793   endif
                            
46949              0.120556   if g:airline_detect_paste && &paste
   44              0.000155     call add(l:mode, 'paste')
   44              0.000041   endif
                            
46949              0.360938   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
46949              0.115144   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
46949              0.097502   if &readonly || ! &modifiable
 6533              0.026158     call add(l:mode, 'readonly')
 6533              0.006310   endif
                            
46949              0.280027   let mode_string = join(l:mode)
46949              0.115931   if s:airline_run < 3
                                " skip this round.
                                " When this function is run too early after startup,
                                " it forces a redraw by vim which will remove the intro screen.
                                let w:airline_lastmode = mode_string
                                return ''
                              endif
46949              0.249888   if get(w:, 'airline_lastmode', '') != mode_string
 3141   1.191642   0.032299     call airline#highlighter#highlight_modified_inactive(context.bufnr)
 3141 317.885354   0.044962     call airline#highlighter#highlight(l:mode, context.bufnr)
 3141              0.011609     let w:airline_lastmode = mode_string
 3141              0.002419   endif
                            
46949              0.063061   return ''

FUNCTION  <SNR>61__skip_file()
Called 1006 times
Total time:   0.159214
 Self time:   0.071725

count  total (s)   self (s)
 1006              0.004781     let fname = bufname(a:buf)
 1006   0.143935   0.056446     let skip = s:_is_quitting(a:buf) || getbufvar(a:buf, 'syntastic_skip_checks') || (getbufvar(a:buf, '&buftype') !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
 1006              0.002191     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
 1006              0.001503     return skip

FUNCTION  GetRubyIndent()
Called 77 times
Total time:   0.254656
 Self time:   0.036100

count  total (s)   self (s)
                              " 3.1. Setup {{{2
                              " ----------
                            
                              " For the current line, use the first argument if given, else v:lnum
   77              0.000405   let clnum = a:0 ? a:1 : v:lnum
                            
                              " Set up variables for restoring position in file.  Could use clnum here.
   77              0.000295   let vcol = col('.')
                            
                              " 3.2. Work on the current line {{{2
                              " -----------------------------
                            
                              " Get the current line.
   77              0.000256   let line = getline(clnum)
   77              0.000142   let ind = -1
                            
                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
   77              0.000823   let col = matchend(line, '^\s*[]})]')
   77   0.007749   0.000401   if col > 0 && !s:IsInStringOrComment(clnum, col)
   16              0.000071     call cursor(clnum, col)
   16              0.000115     let bs = strpart('(){}[]', stridx(')}]', line[col - 1]) * 2, 2)
   16              0.011126     if searchpair(escape(bs[0], '\['), '', bs[1], 'bW', s:skip_expr) > 0
   16              0.000098       if line[col-1]==')' && col('.') != col('$') - 1
                                    let ind = virtcol('.') - 1
                                  else
   16   0.013139   0.000144         let ind = indent(s:GetMSL(line('.')))
   16              0.000015       endif
   16              0.000008     endif
   16              0.000015     return ind
                              endif
                            
                              " If we have a =begin or =end set indent to first column.
   61              0.000545   if match(line, '^\s*\%(=begin\|=end\)$') != -1
                                return 0
                              endif
                            
                              " If we have a deindenting keyword, find its match and indent to its level.
                              " TODO: this is messy
   61   0.003221   0.000450   if s:Match(clnum, s:ruby_deindent_keywords)
    6              0.000018     call cursor(clnum, 1)
    6              0.007678     if searchpair(s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'bW', s:end_skip_expr) > 0
    6   0.004222   0.000054       let msl  = s:GetMSL(line('.'))
    6              0.000017       let line = getline(line('.'))
                            
    6              0.000039       if strpart(line, 0, col('.') - 1) =~ '=\s*$' && strpart(line, col('.') - 1, 2) !~ 'do'
                                    let ind = virtcol('.') - 1
                                  elseif getline(msl) =~ '=\s*\(#.*\)\=$'
                                    let ind = indent(line('.'))
                                  else
    6              0.000011         let ind = indent(msl)
    6              0.000004       endif
    6              0.000003     endif
    6              0.000005     return ind
                              endif
                            
                              " If we are in a multi-line string or line-comment, don't do anything to it.
   55   0.039726   0.000768   if s:IsInStringOrDocumentation(clnum, matchend(line, '^\s*') + 1)
                                return indent('.')
                              endif
                            
                              " If we are at the closing delimiter of a "<<" heredoc-style string, set the
                              " indent to 0.
   55              0.000531   if line =~ '^\k\+\s*$' && s:IsInStringDelimiter(clnum, 1) && search('\V<<'.line, 'nbW') > 0
                                return 0
                              endif
                            
                              " 3.3. Work on the previous line. {{{2
                              " -------------------------------
                            
                              " Find a non-blank, non-multi-line string line above the current line.
   55   0.031981   0.000507   let lnum = s:PrevNonBlankNonString(clnum - 1)
                            
                              " If the line is empty and inside a string, use the previous line.
   55              0.000407   if line =~ '^\s*$' && lnum != prevnonblank(clnum - 1)
                                return indent(prevnonblank(clnum))
                              endif
                            
                              " At the start of the file use zero indent.
   55              0.000072   if lnum == 0
    3              0.000005     return 0
                              endif
                            
                              " Set up variables for the previous line.
   52              0.000143   let line = getline(lnum)
   52              0.000129   let ind = indent(lnum)
                            
                              " If the previous line ended with a block opening, add a level of indent.
   52   0.003341   0.000414   if s:Match(lnum, s:block_regex)
   16   0.015054   0.000193     return indent(s:GetMSL(lnum)) + &sw
                              endif
                            
                              " If the previous line ended with the "*" of a splat, add a level of indent
   36              0.000278   if line =~ s:splat_regex
                                return indent(lnum) + &sw
                              endif
                            
                              " If the previous line contained unclosed opening brackets and we are still
                              " in them, find the rightmost one and add indent depending on the bracket
                              " type.
                              "
                              " If it contained hanging closing brackets, find the rightmost one, find its
                              " match and indent according to that.
   36              0.000376   if line =~ '[[({]' || line =~ '[])}]\s*\%(#.*\)\=$'
    1   0.000474   0.000041     let [opening, closing] = s:ExtraBrackets(lnum)
                            
    1              0.000003     if opening.pos != -1
    1              0.000006       if opening.type == '(' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                    if col('.') + 1 == col('$')
                                      return ind + &sw
                                    else
                                      return virtcol('.')
                                    endif
                                  else
    1              0.000011         let nonspace = matchend(line, '\S', opening.pos + 1) - 1
    1              0.000009         return nonspace > 0 ? nonspace : ind + &sw
                                  endif
                                elseif closing.pos != -1
                                  call cursor(lnum, closing.pos + 1)
                                  normal! %
                            
                                  if s:Match(line('.'), s:ruby_indent_keywords)
                                    return indent('.') + &sw
                                  else
                                    return indent('.')
                                  endif
                                else
                                  call cursor(clnum, vcol)
                                end
                              endif
                            
                              " If the previous line ended with an "end", match that "end"s beginning's
                              " indent.
   35   0.000943   0.000242   let col = s:Match(lnum, '\%(^\|[^.:@$]\)\<end\>\s*\%(#.*\)\=$')
   35              0.000052   if col > 0
                                call cursor(lnum, col)
                                if searchpair(s:end_start_regex, '', s:end_end_regex, 'bW', s:end_skip_expr) > 0
                                  let n = line('.')
                                  let ind = indent('.')
                                  let msl = s:GetMSL(n)
                                  if msl != n
                                    let ind = indent(msl)
                                  end
                                  return ind
                                endif
                              end
                            
   35   0.006321   0.000224   let col = s:Match(lnum, s:ruby_indent_keywords)
   35              0.000057   if col > 0
    8              0.000035     call cursor(lnum, col)
    8              0.000068     let ind = virtcol('.') - 1 + &sw
                                " TODO: make this better (we need to count them) (or, if a searchpair
                                " fails, we know that something is lacking an end and thus we indent a
                                " level
    8   0.000265   0.000076     if s:Match(lnum, s:end_end_regex)
                                  let ind = indent('.')
                                endif
    8              0.000011     return ind
                              endif
                            
                              " 3.4. Work on the MSL line. {{{2
                              " --------------------------
                            
                              " Set up variables to use and search for MSL to the previous line.
   27              0.000045   let p_lnum = lnum
   27   0.077176   0.000168   let lnum = s:GetMSL(lnum)
                            
                              " If the previous line wasn't a MSL and is continuation return its indent.
                              " TODO: the || s:IsInString() thing worries me a bit.
   27              0.000049   if p_lnum != lnum
   17   0.011266   0.000172     if s:Match(p_lnum, s:non_bracket_continuation_regex) || s:IsInString(p_lnum,strlen(line))
   17              0.000037       return ind
                                endif
                              endif
                            
                              " Set up more variables, now that we know we wasn't continuation bound.
   10              0.000031   let line = getline(lnum)
   10              0.000031   let msl_ind = indent(lnum)
                            
                              " If the MSL line had an indenting keyword in it, add a level of indent.
                              " TODO: this does not take into account contrived things such as
                              " module Foo; class Bar; end
   10   0.000476   0.000092   if s:Match(lnum, s:ruby_indent_keywords)
                                let ind = msl_ind + &sw
                                if s:Match(lnum, s:end_end_regex)
                                  let ind = ind - &sw
                                endif
                                return ind
                              endif
                            
                              " If the previous line ended with [*+/.,-=], but wasn't a block ending or a
                              " closing bracket, indent one extra level.
   10   0.007298   0.000150   if s:Match(lnum, s:non_bracket_continuation_regex) && !s:Match(lnum, '^\s*\([\])}]\|end\)')
                                if lnum == p_lnum
                                  let ind = msl_ind + &sw
                                else
                                  let ind = msl_ind
                                endif
                                return ind
                              endif
                            
                              " }}}2
                            
   10              0.000014   return ind

FUNCTION  <SNR>118_BufProjectionCommands()
Called 137 times
Total time:   2.227693
 Self time:   0.031552

count  total (s)   self (s)
  137   0.056299   0.000773   call s:addfilecmds("view")
  137   0.052167   0.000687   call s:addfilecmds("migration")
  137   0.050988   0.000640   call s:addfilecmds("schema")
  137   0.050805   0.000643   call s:addfilecmds("layout")
  137   0.049332   0.000623   call s:addfilecmds("fixtures")
  137   0.049664   0.000608   call s:addfilecmds("locale")
  137   0.011647   0.001244   if rails#app().has('spec')
                                call s:addfilecmds("spec")
                              endif
  137   0.050425   0.000573   call s:addfilecmds("stylesheet")
  137   0.049009   0.000603   call s:addfilecmds("javascript")
 2055   0.976255   0.008693   for [name, command] in items(rails#app().commands())
 1918   0.827958   0.013320     call s:define_navcommand(name, command)
 1918              0.001291   endfor

FUNCTION  gitgutter#utility#use_known_shell()
Called 10791 times
Total time:   1.088135
 Self time:   1.088135

count  total (s)   self (s)
10791              0.157777   if has('unix')
10791              0.115662     if &shell !=# 'sh'
10791              0.130958       let s:shell = &shell
10791              0.095670       let s:shellcmdflag = &shellcmdflag
10791              0.072751       let s:shellredir = &shellredir
10791              0.150843       let &shell = 'sh'
10791              0.141833       set shellcmdflag=-c
10791              0.075426       set shellredir=>%s\ 2>&1
10791              0.027572     endif
10791              0.016489   endif

FUNCTION  <SNR>118_BufCommands()
Called 137 times
Total time:   0.163754
 Self time:   0.026197

count  total (s)   self (s)
  137   0.029285   0.001234   call s:BufNavCommands()
  137   0.018467   0.000679   call s:BufScriptWrappers()
  137              0.000898   command! -buffer -bar -nargs=* -bang Rabbrev :call s:Abbrev(<bang>0,<f-args>)
  137              0.001632   command! -buffer -bar -nargs=? -bang -count -complete=customlist,rails#complete_rake Rake    :call s:Rake(<bang>0,!<count> && <line1> ? -1 : <count>,<q-args>)
  137              0.001291   command! -buffer -bar -nargs=? -bang -range -complete=customlist,s:Complete_preview Rpreview :exe s:deprecate(':Rpreview', ':Preview', ':Preview<bang> '.<q-args>))
  137              0.001154   command! -buffer -bar -nargs=? -bang -range -complete=customlist,s:Complete_preview Rbrowse :call s:Preview(<bang>0,<line1>,<q-args>)
  137              0.001231   command! -buffer -bar -nargs=? -bang -range -complete=customlist,s:Complete_preview Preview :call s:Preview(<bang>0,<line1>,<q-args>)
  137              0.001562   command! -buffer -bar -nargs=? -bang -complete=customlist,s:Complete_log            Rlog     exe s:deprecate(':Rlog', ':Clog', <bang>0 ? 'Clog<bang> '.<q-args> : s:Plog(0, <q-args>))
  137              0.000893   command! -buffer -bar -nargs=? -bang -complete=customlist,s:Complete_log            Clog     exe s:Clog(1<bang>, '<mods>', <q-args>)
  137              0.000718   command! -buffer -bar -nargs=0 Rtags       :execute rails#app().tags_command()
  137              0.000505   command! -buffer -bar -nargs=0 Ctags       :execute rails#app().tags_command()
  137              0.001390   command! -buffer -bar -nargs=0 -bang Rrefresh :if <bang>0|unlet! g:autoloaded_rails|source `=s:file`|endif|call s:Refresh(<bang>0)
  137              0.000481   if exists("g:loaded_dbext")
                                command! -buffer -bar -nargs=? -complete=customlist,s:Complete_environments Rdbext  :call s:BufDatabase(2,<q-args>)|let b:dbext_buffer_defaulted = 1
                              endif
  137              0.000764   let ext = expand("%:e")
  137   0.033061   0.002025   if rails#buffer().name() =~# '^app/views/'
                                " TODO: complete controller names with trailing slashes here
   54              0.000651     command! -buffer -bar -bang -nargs=? -range -complete=customlist,s:controllerList Extract  :<line1>,<line2>call s:Extract(<bang>0,'<mods>',<f-args>)
   54              0.000141   elseif rails#buffer().name() =~# '^app/helpers/.*\.rb$'
                                command! -buffer -bar -bang -nargs=1 -range Extract  :<line1>,<line2>call s:RubyExtract(<bang>0, '<mods>', 'app/helpers', [], s:sub(<f-args>, '_helper$|Helper$|$', '_helper'))
                              elseif rails#buffer().name() =~# '^app/\w\+/.*\.rb$'
   11              0.000193     command! -buffer -bar -bang -nargs=1 -range Extract  :<line1>,<line2>call s:RubyExtract(<bang>0, '<mods>', matchstr(rails#buffer().name(), '^app/\w\+/').'concerns', ['  extend ActiveSupport::Concern', ''], <f-args>)
   11              0.000008   endif
  137              0.001244   if exists(':Extract') == 2
   65              0.000826     command! -buffer -bar -bang -nargs=? -range -complete=customlist,s:controllerList Rextract :exe s:deprecate(':Rextract', ':Extract', '<line1>,<line2>Extract<bang> '.<q-args>)
   65              0.000046   endif
  137   0.029594   0.001938   if rails#buffer().name() =~# '^db/migrate/.*\.rb$'
                                command! -buffer -bar                 Rinvert  :call s:Invert(<bang>0)
                              endif

FUNCTION  emmet#isExpandable()
Called 69 times
Total time:   0.426537
 Self time:   0.026850

count  total (s)   self (s)
   69              0.001456   let line = getline('.')
   69              0.000790   if col('.') < len(line)
    5              0.000180     let line = matchstr(line, '^\(.*\%'.col('.').'c\)')
    5              0.000016   endif
   69              0.001812   let part = matchstr(line, '\(\S.*\)$')
   69   0.008638   0.000841   let type = emmet#getFileType()
   69   0.295447   0.001169   let ftype = emmet#lang#exists(type) ? type : 'html'
   69   0.116148   0.018536   let part = emmet#lang#{ftype}#findTokens(part)
   69              0.000232   return len(part) > 0

FUNCTION  <SNR>111_get_accented_line()
Called 32157 times
Total time:   1.557761
 Self time:   1.557761

count  total (s)   self (s)
32157              0.062063   if a:self._context.active
25585              0.050870     let contents = []
25585              0.183025     let content_parts = split(a:contents, '__accent')
48778              0.088236     for cpart in content_parts
23193              0.197759       let accent = matchstr(cpart, '_\zs[^#]*\ze')
23193              0.070096       call add(contents, cpart)
23193              0.043871     endfor
25585              0.098735     let line = join(contents, a:group)
25585              0.164258     let line = substitute(line, '__restore__', a:group, 'g')
25585              0.023426   else
 6572              0.081760     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
 6572              0.044849     let line = substitute(line, '%#__restore__#', '', 'g')
 6572              0.006204   endif
32157              0.037806   return line

FUNCTION  <SNR>56__compare_error_items_by_columns()
Called 60 times
Total time:   0.000879
 Self time:   0.000879

count  total (s)   self (s)
   60              0.000155     if a:a['bufnr'] != a:b['bufnr']
                                    " group by file
                                    return a:a['bufnr'] - a:b['bufnr']
                                elseif a:a['lnum'] != a:b['lnum']
                                    " sort by line
                                    return a:a['lnum'] - a:b['lnum']
                                elseif a:a['scol'] != a:b['scol']
                                    " sort by screen column
   60              0.000140         return a:a['scol'] - a:b['scol']
                                elseif a:a['type'] !=? a:b['type']
                                    " errors take precedence over warnings
                                    return a:a['type'] ==? 'E' ? -1 : 1
                                else
                                    return 0
                                endif

FUNCTION  <SNR>65_buffer_spec()
Called 624 times
Total time:   0.044460
 Self time:   0.029352

count  total (s)   self (s)
  624              0.003303     let bufname = bufname(self['#'])
  624   0.040591   0.025482     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  ctrlp#init()
Called 109 times
Total time:   7.784741
 Self time:   0.025328

count  total (s)   self (s)
  109   0.018342   0.004349 	if exists('s:init') || s:iscmdwin() | retu | en
  109              0.001281 	let [s:ermsg, v:errmsg] = [v:errmsg, '']
  109              0.001128 	let [s:matches, s:init] = [1, 1]
  109   0.688187   0.002300 	cal s:Reset(a:0 ? a:1 : {})
  109   2.056494   0.001595 	noa cal s:Open()
  109   0.028764   0.004249 	cal s:SetWD(a:0 ? a:1 : {})
  109   0.003891   0.002490 	cal s:MapNorms()
  109   0.182636   0.000835 	cal s:MapSpecs()
  109   0.044902   0.001758 	cal ctrlp#syntax()
  109   0.510928   0.001526 	cal ctrlp#setlines(s:settype(a:type))
  109   0.001625   0.000827 	cal s:SetDefTxt()
  109   4.244632   0.001057 	cal s:BuildPrompt(1)
  109              0.000678 	if s:keyloop | cal s:KeyLoop() | en

FUNCTION  airline#util#append()
Called 188694 times
Total time:   2.826613
 Self time:   2.826613

count  total (s)   self (s)
188694              0.612369   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
188694              0.851353   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
188694              0.768868   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>65_repo_bare()
Called 35 times
Total time:   0.000646
 Self time:   0.000453

count  total (s)   self (s)
   35   0.000561   0.000369   if self.dir() =~# '/\.git$'
   35              0.000054     return 0
                              else
                                return s:configured_tree(self.git_dir) ==# ''
                              endif

FUNCTION  <SNR>116_reset_summary()
Called 9147 times
Total time:   0.409205
 Self time:   0.151850

count  total (s)   self (s)
 9147   0.399732   0.142376   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'summary', [0,0,0])

FUNCTION  airline#add_statusline_funcref()
Called 2 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    2              0.000017   if index(g:airline_statusline_funcrefs, a:function) >= 0
                                echohl WarningMsg
                                echo 'The airline statusline funcref '.string(a:function).' has already been added.'
                                echohl NONE
                                return
                              endif
    2              0.000009   call add(g:airline_statusline_funcrefs, a:function)

FUNCTION  htmlcomplete#DetectOmniFlavor()
Called 44 times
Total time:   0.010256
 Self time:   0.010256

count  total (s)   self (s)
   44              0.000294   if &filetype == 'xhtml'
                                let b:html_omni_flavor = 'xhtml10s'
                              else
   44              0.000244     let b:html_omni_flavor = 'html401t'
   44              0.000069   endif
   44              0.000125   let i = 1
   44              0.000156   let line = ""
  264              0.001196   while i < 10 && i < line("$")
  220              0.000992     let line = getline(i)
  220              0.001847     if line =~ '<!DOCTYPE.*\<DTD '
                                  break
                                endif
  220              0.000618     let i += 1
  220              0.000409   endwhile
   44              0.000420   if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
                                if line =~ ' HTML 3\.2'
                                  let b:html_omni_flavor = 'html32'
                                elseif line =~ ' XHTML 1\.1'
                                  let b:html_omni_flavor = 'xhtml11'
                                else    " two-step detection with strict/frameset/transitional
                                  if line =~ ' XHTML 1\.0'
                            	let b:html_omni_flavor = 'xhtml10'
                                  elseif line =~ ' HTML 4\.01'
                            	let b:html_omni_flavor = 'html401'
                                  elseif line =~ ' HTML 4.0\>'
                            	let b:html_omni_flavor = 'html40'
                                  endif
                                  if line =~ '\<Transitional\>'
                            	let b:html_omni_flavor .= 't'
                                  elseif line =~ '\<Frameset\>'
                            	let b:html_omni_flavor .= 'f'
                                  else
                            	let b:html_omni_flavor .= 's'
                                  endif
                                endif
                              endif

FUNCTION  <SNR>118_app_commands()
Called 137 times
Total time:   0.963460
 Self time:   0.189286

count  total (s)   self (s)
  137              0.000350   let commands = {}
  137   0.664875   0.000695   let all = self.projections()
 5206   0.123969   0.045474   for pattern in sort(keys(all), function('rails#lencmp'))
 5069              0.010817     let projection = all[pattern]
 8631   0.070704   0.039205     for name in s:split(get(projection, 'command', get(projection, 'type', get(projection, 'name', ''))))
 3562              0.016662       let command = { 'pattern': pattern, 'affinity': get(projection, 'affinity', '')}
 3562              0.007558       if !has_key(commands, name)
 1918              0.004287         let commands[name] = []
 1918              0.001350       endif
 3562              0.009624       call insert(commands[name], command)
 3562              0.002546     endfor
 5069              0.003067   endfor
  137              0.002117   call filter(commands, '!empty(v:val)')
  137              0.000173   return commands

FUNCTION  <SNR>129_SetNamedColor()
Called 147 times
Total time:   3.710180
 Self time:   0.030936

count  total (s)   self (s)
  147              0.003176   let group = 'cssColor'.substitute(a:clr,'^#','','')
  147              0.003802   exe 'syn keyword '.group.' '.a:name.' contained'
  147              0.003920   exe 'syn cluster cssColors add='.group
  147              0.000789   if has('gui_running')
                                exe 'hi '.group.' guifg='.s:FGforBG(a:clr)
                                exe 'hi '.group.' guibg='.a:clr
                              elseif &t_Co == 256
  147   1.857051   0.008508     exe 'hi '.group.' ctermfg='.s:Rgb2xterm(s:FGforBG(a:clr))
  147   1.838310   0.007609     exe 'hi '.group.' ctermbg='.s:Rgb2xterm(a:clr)
  147              0.000167   endif
  147              0.000184   return 23

FUNCTION  <SNR>125_getextvar()
Called 236 times
Total time:   0.002729
 Self time:   0.002729

count  total (s)   self (s)
  236              0.000561 	if s:itemtype > 2
                            		let vars = g:ctrlp_ext_vars[s:itemtype - 3]
                            		retu has_key(vars, a:key) ? vars[a:key] : -1
                            	en
  236              0.000292 	retu -1

FUNCTION  <SNR>125_mixedsort()
Called 15154 times
Total time:   7.615621
 Self time:   1.324374

count  total (s)   self (s)
15154              0.033254 	if s:itemtype == 1
                            		let pat = '[\/]\?\[\d\+\*No Name\]$'
                            		if a:1 =~# pat && a:2 =~# pat | retu 0
                            		elsei a:1 =~# pat | retu 1
                            		elsei a:2 =~# pat | retu -1 | en
                            	en
15154   3.432649   0.161586 	let [cln, cml] = [ctrlp#complen(a:1, a:2), s:compmatlen(a:1, a:2)]
15154              0.021139 	if s:ispath
15154              0.024205 		let ms = []
15154              0.023769 		if s:res_count < 21
15154   0.374534   0.093726 			let ms += [s:compfnlen(a:1, a:2)]
15154   0.845594   0.195831 			if s:itemtype !~ '^[12]$' | let ms += [s:comptime(a:1, a:2)] | en
15154   1.971642   0.135578 			if !s:itemtype | let ms += [s:comparent(a:1, a:2)] | en
15154              0.009560 		en
15154              0.069757 		if s:itemtype =~ '^[12]$'
                            			let ms += [s:compmref(a:1, a:2)]
                            			let cln = cml ? cln : 0
                            		en
15154              0.043316 		let ms += [cml, 0, 0, 0]
15154   0.400337   0.146788 		let mp = call('s:multipliers', ms[:3])
15154              0.097514 		retu cln + ms[0] * mp[0] + ms[1] * mp[1] + ms[2] * mp[2] + ms[3] * mp[3]
                            	en
                            	retu cln + cml * 2

FUNCTION  <SNR>61__is_quitting()
Called 1006 times
Total time:   0.025143
 Self time:   0.025143

count  total (s)   self (s)
 1006              0.002899     let quitting = 0
 1006              0.004247     if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
 1006              0.001812     return quitting

FUNCTION  gitgutter#utility#exists_file()
Called 11386 times
Total time:   0.353070
 Self time:   0.353070

count  total (s)   self (s)
11386              0.339385   return filereadable(s:file)

FUNCTION  <SNR>118_RefreshBuffer()
Called 442 times
Total time:   0.067426
 Self time:   0.067426

count  total (s)   self (s)
  442              0.003242   if exists("b:rails_refresh") && b:rails_refresh
                                let b:rails_refresh = 0
                                let &filetype = &filetype
                                unlet! b:rails_refresh
                              endif

FUNCTION  <SNR>125_PrtExit()
Called 108 times
Total time:   1.691914
 Self time:   0.007595

count  total (s)   self (s)
  108              0.001494 	if bufnr('%') == s:bufnr && bufname('%') == 'ControlP'
  108   1.686896   0.002578 		noa cal s:Close()
  108              0.002752 		noa winc p
  108              0.000370 	en

FUNCTION  <SNR>111_get_transitioned_seperator()
Called 20771 times
Total time:  12.182964
 Self time:   0.446587

count  total (s)   self (s)
20771              0.041085   let line = ''
20771  11.857513   0.121135   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
20771              0.092830   let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
20771              0.084444   let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
20771              0.053296   let line .= '%#'.a:group.'#'
20771              0.026625   return line

FUNCTION  emmet#lang#scss#findTokens()
Called 3 times
Total time:   0.016292
 Self time:   0.014798

count  total (s)   self (s)
    3   0.016288   0.014795   return emmet#lang#css#findTokens(a:str)

FUNCTION  <SNR>125_Render()
Called 1015 times
Total time:   8.345404
 Self time:   0.362342

count  total (s)   self (s)
 1015              0.015206 	let [&ma, lines, s:res_count] = [1, a:lines, len(a:lines)]
 1015              0.008163 	let height = min([max([s:mw_min, s:res_count]), s:winmaxh])
 1015   0.012592   0.008999 	let pat = s:byfname() ? split(a:pat, '^[^;]\+\\\@<!\zs;', 1)[0] : a:pat
 1015              0.006503 	let cur_cmd = 'keepj norm! '.( s:mw_order == 'btt' ? 'G' : 'gg' ).'1|'
                            	" Setup the match window
 1015              0.059535 	sil! exe '%d _ | res' height
                            	" Print the new items
 1015              0.004979 	if empty(lines)
   35              0.000264 		let [s:matched, s:lines] = [[], []]
   35              0.000141 		let lines = [' == NO ENTRIES ==']
   35   0.001194   0.000637 		cal setline(1, s:offset(lines, height - 1))
   35              0.000581 		setl noma nocul
   35              0.001263 		exe cur_cmd
   35   0.001265   0.000440 		cal s:unmarksigns()
   35   0.001189   0.000427 		if s:dohighlight() | cal clearmatches() | en
   35              0.000036 		retu
                            	en
  980              0.007613 	let s:matched = copy(lines)
                            	" Sorting
  980   0.027782   0.007602 	if !s:nosort()
  980              0.006203 		let s:compat = s:martcs.pat
  980   7.683521   0.067900 		cal sort(lines, 's:mixedsort')
  980              0.002232 		unl s:compat
  980              0.000893 	en
  980              0.006403 	if s:mw_order == 'btt' | cal reverse(lines) | en
  980              0.005029 	let s:lines = copy(lines)
  980   0.226315   0.025201 	cal map(lines, 's:formatline(v:val)')
  980   0.026506   0.016835 	cal setline(1, s:offset(lines, height))
  980              0.012707 	setl noma cul
  980              0.025327 	exe cur_cmd
  980   0.023951   0.009751 	cal s:unmarksigns()
  980   0.015924   0.005147 	cal s:remarksigns()
  980              0.002912 	if exists('s:cline') && s:nolim != 1
                            		cal cursor(s:cline, 1)
                            	en
                            	" Highlighting
  980   0.018458   0.003882 	if s:dohighlight()
  980   0.098798   0.007612 		cal s:highlight(pat, s:mathi[1])
  980              0.000710 	en

FUNCTION  <SNR>118_define_navcommand()
Called 1918 times
Total time:   0.814638
 Self time:   0.797918

count  total (s)   self (s)
 1918              0.004794   if empty(a:projection)
                                return
                              endif
 1918   0.027051   0.010331   let name = s:gsub(a:name, '[[:punct:][:space:]]', '')
 1918              0.009746   if name !~# '^[a-z]\+$'
                                return s:error("E182: Invalid command name ".name)
                              endif
23016              0.031450   for prefix in ['E', 'S', 'V', 'T', 'D', 'R', 'RE', 'RS', 'RV', 'RT', 'RD']
21098              0.690998     exe 'command! -buffer -bar -bang -nargs=* ' . (prefix =~# 'D' ? '-range=0 ' : '') . '-complete=customlist,'.s:sid.'CommandList ' . prefix . name . ' :execute s:CommandEdit(' . string('<mods> '.(prefix =~# 'D' ? '<line1>' : '') . prefix . "<bang>") . ',' . string(a:name) . ',' . string(a:projection) . ',<f-args>)' . (a:0 ? '|' . a:1 : '')
21098              0.020004   endfor

FUNCTION  <SNR>125_execextvar()
Called 327 times
Total time:   0.004686
 Self time:   0.004686

count  total (s)   self (s)
  327              0.001930 	if !empty(g:ctrlp_ext_vars)
                            		cal map(filter(copy(g:ctrlp_ext_vars), 'has_key(v:val, a:key)'), 'eval(v:val[a:key])')
                            	en

FUNCTION  airline#themes#get_highlight()
Called 483960 times
Total time:  64.774468
 Self time:   3.064854

count  total (s)   self (s)
483960  64.577251   2.867637   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>118_buffer_setvar()
Called 161 times
Total time:   0.002030
 Self time:   0.001655

count  total (s)   self (s)
  161   0.001939   0.001564   return setbufvar(self.number(),a:varname,a:val)

FUNCTION  <SNR>125_getinput()
Called 1131 times
Total time:   0.095769
 Self time:   0.095769

count  total (s)   self (s)
 1131              0.009698 	let [prt, spi] = [s:prompt, ( a:0 ? a:1 : '' )]
 1131              0.004857 	if s:abbrev != {}
                            		let gmd = has_key(s:abbrev, 'gmode') ? s:abbrev['gmode'] : ''
                            		let str = ( gmd =~ 't' && !a:0 ) || spi == 'c' ? prt[0] : join(prt, '')
                            		if gmd =~ 't' && gmd =~ 'k' && !a:0 && matchstr(str, '.$') =~ '\k'
                            			retu join(prt, '')
                            		en
                            		let [pf, rz] = [( s:byfname() ? 'f' : 'p' ), ( s:regexp ? 'r' : 'z' )]
                            		for dict in s:abbrev['abbrevs']
                            			let dmd = has_key(dict, 'mode') ? dict['mode'] : ''
                            			let pat = escape(dict['pattern'], '~')
                            			if ( dmd == '' || ( dmd =~ pf && dmd =~ rz && !a:0 ) || dmd =~ '['.spi.']' ) && str =~ pat
                            				let [str, s:did_exp] = [join(split(str, pat, 1), dict['expanded']), 1]
                            			en
                            		endfo
                            		if gmd =~ 't' && !a:0
                            			let prt[0] = str
                            		el
                            			retu str
                            		en
                            	en
 1131              0.011623 	retu spi == 'c' ? prt[0] : join(prt, '')

FUNCTION  <SNR>222_job_finished()
Called 2116 times
Total time:   0.030234
 Self time:   0.030234

count  total (s)   self (s)
 2116              0.011053   if has_key(s:jobs, a:id)
 2111              0.009613     unlet s:jobs[a:id]
 2111              0.002608   endif

FUNCTION  <SNR>222_is_job_started()
Called 2111 times
Total time:   0.010567
 Self time:   0.010567

count  total (s)   self (s)
 2111              0.008988   return has_key(s:jobs, a:id)

FUNCTION  xolox#session#auto_unlock()
Called 1 time
Total time:   0.593364
 Self time:   0.000111

count  total (s)   self (s)
                              " Automatically unlock all sessions when Vim quits. Normally called by the
                              " [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1   0.593284   0.000031   if xolox#session#locking_enabled()
    1              0.000008     let i = 0
    1              0.000015     while i < len(s:lock_files)
                                  let lock_file = s:lock_files[i]
                                  if delete(lock_file) == 0
                                    call remove(s:lock_files, i)
                                  else
                                    let i += 1
                                  endif
                                endwhile
    1              0.000002   endif

FUNCTION  <SNR>125_opts()
Called 109 times
Total time:   0.113610
 Self time:   0.101028

count  total (s)   self (s)
  109              0.000891 	unl! s:usrign s:usrcmd s:urprtmaps
  654              0.003509 	for each in ['byfname', 'regexp', 'extensions'] | if exists('s:'.each)
  327              0.002229 		let {each} = s:{each}
  545              0.000977 	en | endfo
 4033              0.013682 	for [ke, va] in items(s:opts)
 3924              0.037354 		let {va[0]} = exists(s:pref.ke) ? {s:pref.ke} : va[1]
 3924              0.006018 	endfo
  109              0.000340 	unl va
  654              0.002124 	for [ke, va] in items(s:new_opts)
  545              0.005801 		let {va} = {exists(s:pref.ke) ? s:pref.ke : va}
  545              0.000668 	endfo
  109              0.000175 	unl va
  436              0.001264 	for [ke, va] in items(s:lc_opts)
  327              0.001539 		if exists(s:bpref.ke)
                            			unl {va}
                            			let {va} = {s:bpref.ke}
                            		en
  327              0.000300 	endfo
                            	" Match window options
  109   0.012733   0.001154 	cal s:match_window_opts()
                            	" One-time values
  109              0.000305 	if a:0 && a:1 != {}
                            		unl va
                            		for [ke, va] in items(a:1)
                            			let opke = substitute(ke, '\(\w:\)\?ctrlp_', '', '')
                            			if has_key(s:lc_opts, opke)
                            				let sva = s:lc_opts[opke]
                            				unl {sva}
                            				let {sva} = va
                            			en
                            		endfo
                            	en
  436              0.001572 	for each in ['byfname', 'regexp'] | if exists(each)
  218              0.001307 		let s:{each} = {each}
  327              0.000722 	en | endfo
  109              0.000748 	if !exists('g:ctrlp_newcache') | let g:ctrlp_newcache = 0 | en
  109              0.000558 	let s:maxdepth = min([s:maxdepth, 100])
  109              0.000396 	let s:glob = s:showhidden ? '.*\|*' : '*'
  109              0.000689 	let s:igntype = empty(s:usrign) ? -1 : type(s:usrign)
  109   0.001904   0.000902 	let s:lash = ctrlp#utils#lash()
  109              0.000235 	if s:keyloop
                            		let [s:lazy, s:glbs['imd']] = [0, 0]
                            	en
  109              0.000153 	if s:lazy
                            		cal extend(s:glbs, { 'ut': ( s:lazy > 1 ? s:lazy : 250 ) })
                            	en
                            	" Extensions
  109              0.000573 	if !( exists('extensions') && extensions == s:extensions )
                            		for each in s:extensions
                            			exe 'ru autoload/ctrlp/'.each.'.vim'
                            		endfo
                            	en
                            	" Keymaps
  109              0.000346 	if type(s:urprtmaps) == 4
                            		cal extend(s:prtmaps, s:urprtmaps)
                            	en

FUNCTION  <SNR>125_lash()
Called 30758 times
Total time:   0.291739
 Self time:   0.291739

count  total (s)   self (s)
30758              0.274285 	retu ( a:0 ? a:1 : s:dyncwd ) !~ '[\/]$' ? s:lash : ''

FUNCTION  gitgutter#sign#update_signs()
Called 1444 times
Total time:  19.547651
 Self time:   0.158364

count  total (s)   self (s)
 1444  11.718751   0.010085   call gitgutter#sign#find_current_signs()
                            
 1444              0.091878   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
 1444   1.382574   0.010648   let obsolete_signs = gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers)
                            
 1444              0.005188   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
 1444              0.001903   if flicker_possible
    4   0.004074   0.000018     call gitgutter#sign#add_dummy_sign()
    4              0.000002   endif
                            
 1444   1.366712   0.009793   call gitgutter#sign#remove_signs(obsolete_signs, s:remove_all_old_signs)
 1444   4.956651   0.009122   call gitgutter#sign#upsert_new_gitgutter_signs(a:modified_lines)
                            
 1444              0.002034   if flicker_possible
    4   0.000214   0.000024     call gitgutter#sign#remove_dummy_sign(0)
    4              0.000002   endif

FUNCTION  <SNR>72_crend()
Called 84 times
Total time:   0.016697
 Self time:   0.016697

count  total (s)   self (s)
   84              0.000663   let n = ""
   84              0.000759   if !exists("b:endwise_addition") || !exists("b:endwise_words") || !exists("b:endwise_syngroups")
   82              0.000199     return n
                              end
    2              0.014172   let synids = join(map(split(b:endwise_syngroups, ','), 'hlID(v:val)'), ',')
    2              0.000045   let wordchoice = '\%('.substitute(b:endwise_words,',','\\|','g').'\)'
    2              0.000011   if exists("b:endwise_pattern")
    2              0.000041     let beginpat = substitute(b:endwise_pattern,'&',substitute(wordchoice,'\\','\\&','g'),'g')
    2              0.000004   else
                                let beginpat = '\<'.wordchoice.'\>'
                              endif
    2              0.000010   let lnum = line('.') - 1
    2              0.000024   let space = matchstr(getline(lnum),'^\s*')
    2              0.000132   let col  = match(getline(lnum),beginpat) + 1
    2              0.000075   let word  = matchstr(getline(lnum),beginpat)
    2              0.000019   let endword = substitute(word,'.*',b:endwise_addition,'')
    2              0.000012   let y = n.endword."\<C-O>O"
    2              0.000010   if b:endwise_addition[0:1] ==# '\='
                                let endpat = '\w\@<!'.endword.'\w\@!'
                              else
    2              0.000018     let endpat = '\w\@<!'.substitute('\w\+', '.*', b:endwise_addition, '').'\w\@!'
    2              0.000002   endif
    2              0.000016   let synidpat  = '\%('.substitute(synids,',','\\|','g').'\)'
    2              0.000004   if a:always
                                return y
                              elseif col <= 0 || synID(lnum,col,1) !~ '^'.synidpat.'$'
    2              0.000003     return n
                              elseif getline('.') !~ '^\s*#\=$'
                                return n
                              endif
                              let line = s:mysearchpair(beginpat,endpat,synidpat)
                              " even is false if no end was found, or if the end found was less
                              " indented than the current line
                              let even = strlen(matchstr(getline(line),'^\s*')) >= strlen(space)
                              if line == 0
                                let even = 0
                              endif
                              if !even && line == line('.') + 1
                                return y
                              endif
                              if even
                                return n
                              endif
                              return y

FUNCTION  <SNR>61_QuitPreHook()
Called 53 times
Total time:   0.032323
 Self time:   0.005340

count  total (s)   self (s)
   53   0.025210   0.001559     let buf = syntastic#util#fname2buf(a:fname)
   53   0.003363   0.001464     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: QuitPre, buffer ' . buf . ' = ' . string(a:fname))
                            
   53   0.001949   0.000517     if !syntastic#util#var('check_on_wq')
                                    call syntastic#util#setWids()
                                    call add(s:_quit_pre, buf . '_' . getbufvar(buf, 'changetick') . '_' . w:syntastic_wid)
                                endif
                            
   53              0.000382     if !empty(get(w:, 'syntastic_loclist_set', []))
                                    call SyntasticLoclistHide()
                                endif

FUNCTION  ctrlp#complen()
Called 19472 times
Total time:   0.170953
 Self time:   0.170953

count  total (s)   self (s)
                            	" By length
19472              0.094993 	let [len1, len2] = [strlen(a:1), strlen(a:2)]
19472              0.053175 	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1

FUNCTION  syntastic#util#shescape()
Called 1007 times
Total time:   0.018346
 Self time:   0.018346

count  total (s)   self (s)
 1007              0.017662     return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)

FUNCTION  <SNR>125_remarksigns()
Called 980 times
Total time:   0.010777
 Self time:   0.005996

count  total (s)   self (s)
  980   0.009873   0.005092 	if !s:dosigns() | retu | en
                            	for ic in range(1, len(s:lines))
                            		let line = s:ispath ? fnamemodify(s:lines[ic - 1], ':p') : s:lines[ic - 1]
                            		let key = s:dictindex(s:marked, line)
                            		if key > 0
                            			exe 'sign place' key 'line='.ic.' name=ctrlpmark buffer='.s:bufnr
                            		en
                            	endfo

FUNCTION  syntastic#log#debug()
Called 16012 times
Total time:   0.195812
 Self time:   0.129838

count  total (s)   self (s)
16012   0.158391   0.092417     if !s:_isDebugEnabled(a:level)
16012              0.017903         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>56__remove_shadowed_items()
Called 172 times
Total time:   0.006583
 Self time:   0.006583

count  total (s)   self (s)
                                " keep only the first message at a given column
  172              0.000326     let i = 0
  202              0.000529     while i < len(a:errors) - 1
   30              0.000064         let j = i + 1
   30              0.000045         let dupes = 0
   30              0.000136         while j < len(a:errors) && a:errors[j].scol == a:errors[i].scol
                                        let dupes = 1
                                        let j += 1
                                    endwhile
   30              0.000029         if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
   30              0.000053         let i += 1
   30              0.000022     endwhile
                            
                                " merge messages with the same text
  172              0.000185     let i = 0
  202              0.000451     while i < len(a:errors) - 1
   30              0.000052         let j = i + 1
   30              0.000036         let dupes = 0
   30              0.000138         while j < len(a:errors) && a:errors[j].text == a:errors[i].text
                                        let dupes = 1
                                        let j += 1
                                    endwhile
   30              0.000026         if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
   30              0.000043         let i += 1
   30              0.000023     endwhile

FUNCTION  ctrlp#dirnfile()
Called 55 times
Total time:   0.138323
 Self time:   0.070195

count  total (s)   self (s)
   55   0.001973   0.000882 	let [items, cwd] = [[[], []], s:dyncwd.s:lash()]
 1276              0.002755 	for each in a:entries
 1221              0.012038 		let etype = getftype(each)
 1267   0.077152   0.010114 		if s:igntype >= 0 && s:usrign(each, etype) | con | en
 1153              0.002963 		if etype == 'dir'
  441              0.000771 			if s:showhidden | if each !~ '[\/]\.\{1,2}$'
                            				cal add(items[0], each)
                            			en | el
  441              0.002007 				cal add(items[0], each)
  441              0.000456 			en
  441              0.000555 		elsei etype == 'link'
                            			if s:folsym
                            				let isfile = !isdirectory(each)
                            				if s:folsym == 2 || !s:samerootsyml(each, isfile, cwd)
                            					cal add(items[isfile], each)
                            				en
                            			en
                            		elsei etype == 'file'
  712              0.002988 			cal add(items[1], each)
  712              0.000697 		en
 1153              0.003379 	endfo
   55              0.000084 	retu items

FUNCTION  <SNR>70_getchar()
Called 1 time
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
    1              0.000055   let c = getchar()
    1              0.000039   if c =~ '^\d\+$'
    1              0.000011     let c = nr2char(c)
    1              0.000003   endif
    1              0.000004   return c

FUNCTION  <SNR>125_sublist()
Called 1015 times
Total time:   0.015641
 Self time:   0.015641

count  total (s)   self (s)
 1015              0.014457 	retu v:version > 701 ? a:l[(a:s):(a:e)] : s:sublist7071(a:l, a:s, a:e)

FUNCTION  airline#extensions#tabline#buffers#get()
Called 6596 times
Total time:  16.424527
 Self time:   1.017369

count  total (s)   self (s)
 6596   0.231398   0.063521   call <sid>map_keys()
 6596              0.038722   let cur = bufnr('%')
 6596              0.017885   if cur == s:current_bufnr
 6026              0.047920     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
 4875              0.020695       return s:current_tabline
                                endif
 1151              0.001288   endif
                            
 1721              0.004571   let l:index = 1
 1721   0.186550   0.013576   let b = airline#extensions#tabline#new_builder()
 1721              0.010537   let tab_bufs = tabpagebuflist(tabpagenr())
12968   2.542811   0.029353   for nr in s:get_visible_buffers()
11247              0.015693     if nr < 0
 1741   0.019189   0.008754       call b.add_raw('%#airline_tabhid#...')
 1741              0.002847       continue
                                endif
                            
 9506   0.335740   0.057479     let group = airline#extensions#tabline#group_of_bufnr(tab_bufs, nr)
                            
 9506              0.014582     if nr == cur
 1557              0.007358       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
 1557              0.001713     endif
                            
                                " Neovim feature: Have clickable buffers
 9506              0.027583     if has("tablineat")
 9506   0.109655   0.059936       call b.add_raw('%'.nr.'@airline#extensions#tabline#buffers#clickbuf@')
 9506              0.009470     endif
 9506              0.017154     if s:buffer_idx_mode
                                  if len(s:number_map) > 0
                                    call b.add_section(group, s:spc . get(s:number_map, l:index, '') . '%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)' . s:spc)
                                  else
                                    call b.add_section(group, '['.l:index.s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)'.']')
                                  endif
                                  let l:index = l:index + 1
                                else
 9506   0.135447   0.074909       call b.add_section(group, s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)'.s:spc)
 9506              0.009767     endif
 9506              0.029758     if has("tablineat")
 9506   0.094305   0.036261       call b.add_raw('%X')
 9506              0.009562     endif
 9506              0.008849   endfor
                            
 1721   0.016782   0.007793   call b.add_section('airline_tabfill', '')
 1721   0.015900   0.006262   call b.split()
 1721   0.016412   0.007342   call b.add_section('airline_tabfill', '')
 1721              0.003279   if s:show_tab_type
 1721   0.048337   0.010350     call b.add_section_spaced('airline_tabtype', s:buffers_label)
 1721              0.001841   endif
 1721              0.004904   if tabpagenr('$') > 1
                                call b.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
                              endif
                            
 1721              0.004092   let s:current_bufnr = cur
 1721  12.042625   0.012457   let s:current_tabline = b.build()
 1721              0.004067   return s:current_tabline

FUNCTION  <SNR>125_BuildPrompt()
Called 1054 times
Total time:  28.056125
 Self time:  12.419345

count  total (s)   self (s)
 1054   0.020912   0.014698 	let base = ( s:regexp ? 'r' : '>' ).( s:byfname() ? 'd' : '>' ).'> '
 1054   0.099777   0.011136 	let str = escape(s:getinput(), '\')
 1054              0.011497 	let lazy = str == '' || exists('s:force') || !has('autocmd') ? 0 : s:lazy
 1054              0.008351 	if a:upd && !lazy && ( s:matches || s:regexp || exists('s:did_exp') || str =~ '\(\\\(<\|>\)\|[*|]\)\|\(\\\:\([^:]\|\\:\)*$\)' )
 1019   9.507496   0.011017 		sil! cal s:Update(str)
 1019              0.000716 	en
 1054   6.052654   0.007208 	sil! cal ctrlp#statusline()
                            	" Toggling
 1054              0.007129 	let [hiactive, hicursor, base] = s:focus ? ['CtrlPPrtText', 'CtrlPPrtCursor', base] : ['CtrlPPrtBase', 'CtrlPPrtBase', tr(base, '>', '-')]
 1054              0.001890 	let hibase = 'CtrlPPrtBase'
                            	" Build it
 1054             12.161798 	redr
 1054              0.010048 	let prt = copy(s:prompt)
 1054              0.012413 	cal map(prt, 'escape(v:val, ''"\'')')
 1054              0.114256 	exe 'echoh' hibase '| echon "'.base.'" | echoh' hiactive '| echon "'.prt[0].'" | echoh' hicursor '| echon "'.prt[1].'" | echoh' hiactive '| echon "'.prt[2].'" | echoh None'
                            	" Append the cursor at the end
 1054              0.006482 	if empty(prt[1]) && s:focus
 1054              0.030891 		exe 'echoh' hibase '| echon "_" | echoh None'
 1054              0.001312 	en

FUNCTION  fugitive#buffer()
Called 156 times
Total time:   0.007960
 Self time:   0.001466

count  total (s)   self (s)
  156   0.007806   0.001311   return s:buffer(a:0 ? a:1 : '%')

FUNCTION  <SNR>65_buffer_getline()
Called 363 times
Total time:   0.003030
 Self time:   0.003030

count  total (s)   self (s)
  363              0.002745   return get(getbufline(self['#'], a:lnum), 0, '')

FUNCTION  ctrlp#normcmd()
Called 34 times
Total time:   0.007222
 Self time:   0.005868

count  total (s)   self (s)
   34   0.002098   0.000745 	if a:0 < 2 && s:nosplit() | retu a:cmd | en
   34              0.001812 	let norwins = filter(range(1, winnr('$')), 'empty(getbufvar(winbufnr(v:val), "&bt"))')
  101              0.000343 	for each in norwins
   67              0.000332 		let bufnr = winbufnr(each)
   67              0.000597 		if empty(bufname(bufnr)) && empty(getbufvar(bufnr, '&ft'))
                            			let fstemp = each | brea
                            		en
   67              0.000099 	endfo
   34              0.000288 	let norwin = empty(norwins) ? 0 : norwins[0]
   34              0.000081 	if norwin
   34              0.000173 		if index(norwins, winnr()) < 0
                            			exe ( exists('fstemp') ? fstemp : norwin ).'winc w'
                            		en
   34              0.000100 		retu a:cmd
                            	en
                            	retu a:0 ? a:1 : 'bo vne'

FUNCTION  emmet#expandCursorExpr()
Called 27 times
Total time:   0.001420
 Self time:   0.001420

count  total (s)   self (s)
   27              0.000057   let expand = a:expand
   27              0.000115   if expand !~# '\${cursor}'
    2              0.000004     if a:mode ==# 2
                                  let expand = '${cursor}' . expand
                                else
    2              0.000006       let expand .= '${cursor}'
    2              0.000002     endif
    2              0.000001   endif
   27              0.000279   let expand = substitute(expand, '\${\d\+:\?\([^}]\+\)}', '$select$$cursor$\1$select$', 'g')
   27              0.000237   let expand = substitute(expand, '\${\d\+}', '$select$$cursor$$select$', 'g')
   27              0.000166   let expand = substitute(expand, '\${cursor}', '$cursor$', '')
   27              0.000129   let expand = substitute(expand, '\${cursor}', '', 'g')
   27              0.000125   let expand = substitute(expand, '\${cursor}', '', 'g')
   27              0.000035   return expand

FUNCTION  airline#extensions#default#apply()
Called 2400 times
Total time:   1.119242
 Self time:   0.137153

count  total (s)   self (s)
 2400              0.007230   let winnr = a:context.winnr
 2400              0.005476   let active = a:context.active
                            
 2400   0.028145   0.016753   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
 1225   0.357491   0.010202     call s:build_sections(a:builder, a:context, s:layout[0])
 1225              0.001092   else
 1175   0.053419   0.005935     let text = s:get_section(winnr, 'c')
 1175              0.002207     if empty(text)
                                  let text = ' %f%m '
                                endif
 1175   0.013253   0.007464     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
 1175              0.001073   endif
                            
 2400   0.130668   0.021709   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
 2400   0.020823   0.011443   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
 1740   0.462629   0.010833     call s:build_sections(a:builder, a:context, s:layout[1])
 1740              0.001160   endif
                            
 2400              0.002324   return 1

FUNCTION  emmet#lang#html#findTokens()
Called 93 times
Total time:   0.089450
 Self time:   0.089450

count  total (s)   self (s)
   93              0.000569   let str = a:str
   93              0.000552   let [pos, last_pos] = [0, 0]
   93              0.000220   while 1
   93              0.001273     let tag = matchstr(str, '<[a-zA-Z].\{-}>', pos)
   93              0.000347     if len(tag) == 0
   93              0.000168       break
                                endif
                                let pos = stridx(str, tag, pos) + len(tag)
                              endwhile
   93              0.000160   while 1
   93              0.000911     let tag = matchstr(str, '{%[^%]\{-}%}', pos)
   93              0.000294     if len(tag) == 0
   93              0.000135       break
                                endif
                                let pos = stridx(str, tag, pos) + len(tag)
                              endwhile
   93              0.000263   let last_pos = pos
  137              0.000476   while len(str) > 0
   88              0.075485     let token = matchstr(str, s:mx, pos)
   88              0.000532     if token ==# ''
   44              0.000076       break
                                endif
   44              0.000316     if token =~# '^\s'
                                  let token = matchstr(token, '^\s*\zs.*')
                                  let last_pos = stridx(str, token, pos)
                                endif
   44              0.000392     let pos = stridx(str, token, pos) + len(token)
   44              0.000176   endwhile
   93              0.000593   let str = a:str[last_pos :-1]
   93              0.001017   if str =~# '^\w\+="[^"]*$'
                                return ''
                              endif
   93              0.000183   return str

FUNCTION  gitgutter#sign#find_current_signs()
Called 1444 times
Total time:  11.708666
 Self time:  11.558001

count  total (s)   self (s)
 1444   0.011166   0.008210   let bufnr = gitgutter#utility#bufnr()
 1444              0.003516   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
 1444              0.002809   let other_signs = []      " [<line_number (number),...]
 1444              0.002654   let dummy_sign_placed = 0
                            
 1444              0.004874   redir => signs
 1444              0.403818     silent execute "sign place buffer=" . bufnr
 1444              0.008508   redir END
                            
132294              0.454221   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
130850              1.217684     let components  = split(sign_line)
130850              0.717614     let name        = split(components[2], '=')[1]
130850              0.480318     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
130850              0.728573       let line_number = str2nr(split(components[0], '=')[1])
130850              0.396859       if name =~# 'GitGutter'
130136              0.699156         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
130136              0.338293         if has_key(gitgutter_signs, line_number)
  558              3.920524           execute "sign unplace" gitgutter_signs[line_number].id
  558              0.001979         endif
130136              0.579403         let gitgutter_signs[line_number] = {'id': id, 'name': name}
130136              0.106300       else
  714              0.001886         call add(other_signs, line_number)
  714              0.000507       endif
130850              0.065447     end
130850              0.247277   endfor
                            
 1444   0.035435   0.012673   call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', dummy_sign_placed)
 1444   0.117695   0.008079   call gitgutter#utility#setbufvar(bufnr, 'gitgutter_signs', gitgutter_signs)
 1444   0.023046   0.007714   call gitgutter#utility#setbufvar(bufnr, 'other_signs', other_signs)

FUNCTION  airline#extensions#ctrlp#ctrlp_airline()
Called 1054 times
Total time:   5.929166
 Self time:   0.070941

count  total (s)   self (s)
 1054   0.039075   0.007234   let b = airline#builder#new({'active': 1})
 1054              0.002255   if a:2 == 'file'
                                call b.add_section_spaced('CtrlPlight', 'by fname')
                              endif
 1054              0.001192   if a:3
                                call b.add_section_spaced('CtrlPlight', 'regex')
                              endif
 1054              0.003647   if get(g:, 'airline#extensions#ctrlp#show_adjacent_modes', 1)
 1054   0.025168   0.005694     call b.add_section_spaced('CtrlPlight', a:4)
 1054   0.020631   0.004977     call b.add_section_spaced('CtrlPwhite', a:5)
 1054   0.019615   0.004731     call b.add_section_spaced('CtrlPlight', a:6)
 1054              0.001161   else
                                call b.add_section_spaced('CtrlPwhite', a:5)
                              endif
 1054   0.019401   0.004407   call b.add_section_spaced('CtrlPdark', a:7)
 1054   0.008899   0.003759   call b.split()
 1054   0.020092   0.004435   call b.add_section_spaced('CtrlPdark', a:1)
 1054   0.019099   0.004424   call b.add_section_spaced('CtrlPdark', a:2)
 1054   0.019395   0.004402   call b.add_section_spaced('CtrlPlight', '%{getcwd()}')
 1054   5.716246   0.005333   return b.build()

FUNCTION  syntastic#util#unique()
Called 2545 times
Total time:   0.119686
 Self time:   0.119686

count  total (s)   self (s)
 2545              0.007386     let seen = {}
 2545              0.006121     let uniques = []
 6369              0.012745     for e in a:list
 3824              0.015583         let k = string(e)
 3824              0.012025         if !has_key(seen, k)
 2847              0.009096             let seen[k] = 1
 2847              0.009888             call add(uniques, e)
 2847              0.002826         endif
 3824              0.004739     endfor
 2545              0.004040     return uniques

FUNCTION  <SNR>125_fnesc()
Called 603 times
Total time:   0.043146
 Self time:   0.005465

count  total (s)   self (s)
  603   0.042697   0.005015 	retu call('ctrlp#utils#fnesc', a:000)

FUNCTION  <SNR>125_MatchedItems()
Called 1015 times
Total time:   0.740079
 Self time:   0.066067

count  total (s)   self (s)
 1015              0.006631 	let exc = exists('s:crfilerel') ? s:crfilerel : ''
 1015   0.036253   0.016983 	let items = s:narrowable() ? s:matched + s:mdata[3] : a:items
 1015              0.002688 	if s:matcher != {}
                            		let argms = has_key(s:matcher, 'arg_type') && s:matcher['arg_type'] == 'dict' ? [{ 'items':  items, 'str':    a:pat, 'limit':  a:limit, 'mmode':  s:mmode(), 'ispath': s:ispath, 'crfile': exc, 'regex':  s:regexp, }] : [items, a:pat, a:limit, s:mmode(), s:ispath, exc, s:regexp]
                            		let lines = call(s:matcher['match'], argms, s:matcher)
                            	el
 1015   0.664382   0.009639 		let lines = s:MatchIt(items, a:pat, a:limit, exc)
 1015              0.001275 	en
 1015              0.003629 	let s:matches = len(lines)
 1015              0.002077 	unl! s:did_exp
 1015              0.001501 	retu lines

FUNCTION  SyntaxCheckers_sass_sass_GetLocList()
Called 296 times
Total time: 1099.762701
 Self time:   0.025120

count  total (s)   self (s)
  296              0.001289     let buf = bufnr('')
  296   0.009929   0.003746     if !syntastic#util#bufVar(buf, 'sass_check_partials') && fnamemodify(bufname(buf), ':t')[0] ==# '_'
                                    return []
                                endif
                            
  296   0.180066   0.004068     let makeprg = self.makeprgBuild({ 'args_before': '--cache-location ' . s:sass_cache_location . ' ' . s:imports . ' --check' })
                            
  296              0.006314     let errorformat = '%E%\m%\%%(Syntax %\)%\?%trror: %m,' . '%+C              %.%#,' . '%C        on line %l of %f\, %.%#,' . '%C        on line %l of %f,' . '%-G %\+from line %.%#,' . '%-G %\+Use --trace for backtrace.,' . '%W%>DEPRECATION WARNING on line %l of %f:,' . '%+C%>  %.%#,' . '%W%>WARNING: on line %l of %f:,' . '%+C%>  %.%#,' . '%W%>WARNING on line %l of %f: %m,' . '%+C%>  %.%#,' . '%W%>WARNING on line %l of %f:,' . '%Z%m,' . '%W%>WARNING: %m,' . '%C         on line %l of %f\, %.%#,' . '%C         on line %l of %f,' . '%-G %\+from line %.%#,' . 'Syntax %trror on line %l: %m,' . '%-G%.%#'
                            
  296 1099.562428   0.007027     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'postprocess': ['compressWhitespace'] })

FUNCTION  <SNR>91_sync_active_winnr()
Called 7214 times
Total time:   1.719226
 Self time:   0.122219

count  total (s)   self (s)
 7214              0.072223   if exists('#airline') && winnr() != s:active_winnr
  137   1.598320   0.001313     call airline#update_statusline()
  137              0.000083   endif

FUNCTION  airline#parts#filetype()
Called 40416 times
Total time:   0.694551
 Self time:   0.694551

count  total (s)   self (s)
40416              0.653213   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? 'â¦' : '>') : &filetype

FUNCTION  <SNR>125_offset()
Called 1015 times
Total time:   0.010228
 Self time:   0.010228

count  total (s)   self (s)
 1015              0.005469 	let s:offset = s:mw_order == 'btt' ? ( a:height - s:res_count ) : 0
 1015              0.003890 	retu s:offset > 0 ? ( repeat([''], s:offset) + a:lines ) : a:lines

FUNCTION  ctrlp#utils#globpath()
Called 1 time
Total time:   0.080626
 Self time:   0.080626

count  total (s)   self (s)
    1              0.080624 	retu call('globpath', s:wig_cond ? a:000 : a:000[:1])

FUNCTION  airline#parts#iminsert()
Called 31449 times
Total time:   0.299091
 Self time:   0.299091

count  total (s)   self (s)
31449              0.116813   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
31449              0.036205   return ''

FUNCTION  GetCSSIndent()
Called 1606 times
Total time:   0.740021
 Self time:   0.126390

count  total (s)   self (s)
 1606              0.011323   let line = getline(v:lnum)
 1606              0.014699   if line =~ '^\s*\*'
   99              0.039610     return cindent(v:lnum)
                              endif
                            
 1507   0.071337   0.014877   let pnum = s:prevnonblanknoncomment(v:lnum - 1)
 1507              0.002642   if pnum == 0
   18              0.000036     return 0
                              endif
                            
 1489   0.585992   0.028821   return indent(pnum) + s:count_braces(pnum, 1) * &sw - s:count_braces(v:lnum, 0) * &sw

FUNCTION  gitgutter#sign#remove_signs()
Called 1444 times
Total time:   1.356919
 Self time:   1.353897

count  total (s)   self (s)
 1444   0.009009   0.006093   let bufnr = gitgutter#utility#bufnr()
 1444   0.005182   0.005122   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(bufnr, 'other_signs'))
    6   0.000079   0.000034     let dummy_sign_present = gitgutter#utility#getbufvar(bufnr, 'dummy_sign')
    6              0.000028     execute "sign unplace * buffer=" . bufnr
    6              0.000007     if dummy_sign_present
    4              0.008056       execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
    4              0.000009     endif
    6              0.000004   else
 1711              0.004634     for id in a:sign_ids
  273              1.309482       execute "sign unplace" id
  273              0.001289     endfor
 1438              0.000901   endif

FUNCTION  emmet#getBaseType()
Called 2 times
Total time:   0.000413
 Self time:   0.000380

count  total (s)   self (s)
    2              0.000023   if !has_key(s:emmet_settings, a:type)
                                return ''
                              endif
    2              0.000021   if !has_key(s:emmet_settings[a:type], 'extends')
    1              0.000005     return a:type
                              endif
    1              0.000003   let extends = s:emmet_settings[a:type].extends
    1              0.000012   if type(extends) ==# 1
    1              0.000268     let tmp = split(extends, '\s*,\s*')
    1              0.000015     let ext = tmp[0]
    1              0.000002   else
                                let ext = extends[0]
                              endif
    1              0.000003   if a:type !=# ext
    1              0.000008     return emmet#getBaseType(ext)
                              endif
                              return ''

FUNCTION  <SNR>125_tail()
Called 77 times
Total time:   0.001905
 Self time:   0.001905

count  total (s)   self (s)
   77              0.000725 	if exists('s:optail') && !empty('s:optail')
                            		let tailpref = s:optail !~ '^\s*+' ? ' +' : ' '
                            		retu tailpref.s:optail
                            	en
   77              0.000218 	retu ''

FUNCTION  <SNR>78_Match_wrapper()
Called 6 times
Total time:   0.049945
 Self time:   0.046243

count  total (s)   self (s)
                              " In s:CleanUp(), :execute "set" restore_options .
    6              0.000187   let restore_options = (&ic ? " " : " no") . "ignorecase"
    6              0.000071   if exists("b:match_ignorecase")
    1              0.000023     let &ignorecase = b:match_ignorecase
    1              0.000004   endif
    6              0.000045   let restore_options = " ve=" . &ve . restore_options
    6              0.000096   set ve=
                              " If this function was called from Visual mode, make sure that the cursor
                              " is at the correct end of the Visual range:
    6              0.000032   if a:mode == "v"
    4              0.000165     execute "normal! gv\<Esc>"
    4              0.000009   endif
                              " In s:CleanUp(), we may need to check whether the cursor moved forward.
    6              0.000040   let startline = line(".")
    6              0.000038   let startcol = col(".")
                              " Use default behavior if called with a count.
    6              0.000017   if v:count
                                exe "normal! " . v:count . "%"
                                return s:CleanUp(restore_options, a:mode, startline, startcol)
                              end
                            
                              " First step:  if not already done, set the script variables
                              "   s:do_BR	flag for whether there are backrefs
                              "   s:pat	parsed version of b:match_words
                              "   s:all	regexp based on s:pat and the default groups
                              "
    6              0.000045   if !exists("b:match_words") || b:match_words == ""
    5              0.000017     let match_words = ""
                                " Allow b:match_words = "GetVimMatchWords()" .
    5              0.000010   elseif b:match_words =~ ":"
    1              0.000006     let match_words = b:match_words
    1              0.000002   else
                                execute "let match_words =" b:match_words
                              endif
                            " Thanks to Preben "Peppe" Guldberg and Bram Moolenaar for this suggestion!
    6              0.000058   if (match_words != s:last_words) || (&mps != s:last_mps) || exists("b:match_debug")
    2              0.000011     let s:last_words = match_words
    2              0.000012     let s:last_mps = &mps
                                " The next several lines were here before
                                " BF started messing with this script.
                                " quote the special chars in 'matchpairs', replace [,:] with \| and then
                                " append the builtin pairs (/*, */, #if, #ifdef, #else, #elif, #endif)
                                " let default = substitute(escape(&mps, '[$^.*~\\/?]'), '[,:]\+',
                                "  \ '\\|', 'g').'\|\/\*\|\*\/\|#if\>\|#ifdef\>\|#else\>\|#elif\>\|#endif\>'
    2              0.000039     let default = escape(&mps, '[$^.*~\\/?]') . (strlen(&mps) ? "," : "") . '\/\*:\*\/,#\s*if\%(def\)\=:#\s*else\>:#\s*elif\>:#\s*endif\>'
                                " s:all = pattern with all the keywords
    2              0.000017     let match_words = match_words . (strlen(match_words) ? "," : "") . default
    2              0.000177     if match_words !~ s:notslash . '\\\d'
    2              0.000016       let s:do_BR = 0
    2              0.000010       let s:pat = match_words
    2              0.000003     else
                                  let s:do_BR = 1
                                  let s:pat = s:ParseWords(match_words)
                                endif
    2              0.000303     let s:all = substitute(s:pat, s:notslash . '\zs[,:]\+', '\\|', 'g')
    2              0.000011     let s:all = '\%(' . s:all . '\)'
                                " let s:all = '\%(' . substitute(s:all, '\\\ze[,:]', '', 'g') . '\)'
    2              0.000009     if exists("b:match_debug")
                                  let b:match_pat = s:pat
                                endif
    2              0.000002   endif
                            
                              " Second step:  set the following local variables:
                              "     matchline = line on which the cursor started
                              "     curcol    = number of characters before match
                              "     prefix    = regexp for start of line to start of match
                              "     suffix    = regexp for end of match to end of line
                              " Require match to end on or after the cursor and prefer it to
                              " start on or before the cursor.
    6              0.000050   let matchline = getline(startline)
    6              0.000022   if a:word != ''
                                " word given
                                if a:word !~ s:all
                                  echohl WarningMsg|echo 'Missing rule for word:"'.a:word.'"'|echohl NONE
                                  return s:CleanUp(restore_options, a:mode, startline, startcol)
                                endif
                                let matchline = a:word
                                let curcol = 0
                                let prefix = '^\%('
                                let suffix = '\)$'
                              " Now the case when "word" is not given
                              else	" Find the match that ends on or after the cursor and set curcol.
    6   0.001105   0.000112     let regexp = s:Wholematch(matchline, s:all, startcol-1)
    6              0.000493     let curcol = match(matchline, regexp)
                                " If there is no match, give up.
    6              0.000022     if curcol == -1
                                  return s:CleanUp(restore_options, a:mode, startline, startcol)
                                endif
    6              0.000415     let endcol = matchend(matchline, regexp)
    6              0.000044     let suf = strlen(matchline) - endcol
    6              0.000045     let prefix = (curcol ? '^.*\%'  . (curcol + 1) . 'c\%(' : '^\%(')
    6              0.000030     let suffix = (suf ? '\)\%' . (endcol + 1) . 'c.*$'  : '\)$')
    6              0.000009   endif
    6              0.000028   if exists("b:match_debug")
                                let b:match_match = matchstr(matchline, regexp)
                                let b:match_col = curcol+1
                              endif
                            
                              " Third step:  Find the group and single word that match, and the original
                              " (backref) versions of these.  Then, resolve the backrefs.
                              " Set the following local variable:
                              " group = colon-separated list of patterns, one of which matches
                              "       = ini:mid:fin or ini:fin
                              "
                              " Reconstruct the version with unresolved backrefs.
    6              0.000356   let patBR = substitute(match_words.',', s:notslash.'\zs[,:]*,[,:]*', ',', 'g')
    6              0.000382   let patBR = substitute(patBR, s:notslash.'\zs:\{2,}', ':', 'g')
                              " Now, set group and groupBR to the matching group: 'if:endif' or
                              " 'while:endwhile' or whatever.  A bit of a kluge:  s:Choose() returns
                              " group . "," . groupBR, and we pick it apart.
    6   0.001958   0.000150   let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, patBR)
    6              0.000076   let i = matchend(group, s:notslash . ",")
    6              0.000034   let groupBR = strpart(group, i)
    6              0.000034   let group = strpart(group, 0, i-1)
                              " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
    6              0.000013   if s:do_BR " Do the hard part:  resolve those backrefs!
                                let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                              endif
    6              0.000025   if exists("b:match_debug")
                                let b:match_wholeBR = groupBR
                                let i = matchend(groupBR, s:notslash . ":")
                                let b:match_iniBR = strpart(groupBR, 0, i-1)
                              endif
                            
                              " Fourth step:  Set the arguments for searchpair().
    6              0.000060   let i = matchend(group, s:notslash . ":")
    6              0.000145   let j = matchend(group, '.*' . s:notslash . ":")
    6              0.000042   let ini = strpart(group, 0, i-1)
    6              0.000095   let mid = substitute(strpart(group, i,j-i-1), s:notslash.'\zs:', '\\|', 'g')
    6              0.000032   let fin = strpart(group, j)
                              "Un-escape the remaining , and : characters.
    6              0.000081   let ini = substitute(ini, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
    6              0.000067   let mid = substitute(mid, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
    6              0.000068   let fin = substitute(fin, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              " searchpair() requires that these patterns avoid \(\) groups.
    6              0.000065   let ini = substitute(ini, s:notslash . '\zs\\(', '\\%(', 'g')
    6              0.000061   let mid = substitute(mid, s:notslash . '\zs\\(', '\\%(', 'g')
    6              0.000062   let fin = substitute(fin, s:notslash . '\zs\\(', '\\%(', 'g')
                              " Set mid.  This is optimized for readability, not micro-efficiency!
    6              0.000092   if a:forward && matchline =~ prefix . fin . suffix || !a:forward && matchline =~ prefix . ini . suffix
                                let mid = ""
                              endif
                              " Set flag.  This is optimized for readability, not micro-efficiency!
    6              0.000072   if a:forward && matchline =~ prefix . fin . suffix || !a:forward && matchline !~ prefix . ini . suffix
                                let flag = "bW"
                              else
    6              0.000015     let flag = "W"
    6              0.000008   endif
                              " Set skip.
    6              0.000024   if exists("b:match_skip")
    1              0.000003     let skip = b:match_skip
    1              0.000002   elseif exists("b:match_comment") " backwards compatibility and testing!
                                let skip = "r:" . b:match_comment
                              else
    5              0.000014     let skip = 's:comment\|string'
    5              0.000006   endif
    6   0.000366   0.000085   let skip = s:ParseSkip(skip)
    6              0.000024   if exists("b:match_debug")
                                let b:match_ini = ini
                                let b:match_tail = (strlen(mid) ? mid.'\|' : '') . fin
                              endif
                            
                              " Fifth step:  actually start moving the cursor and call searchpair().
                              " Later, :execute restore_cursor to get to the original screen.
    6              0.000044   let restore_cursor = virtcol(".") . "|"
    6              0.000134   normal! g0
    6              0.000074   let restore_cursor = line(".") . "G" .  virtcol(".") . "|zs" . restore_cursor
    6              0.000082   normal! H
    6              0.000062   let restore_cursor = "normal!" . line(".") . "Gzt" . restore_cursor
    6              0.000173   execute restore_cursor
    6              0.000050   call cursor(0, curcol + 1)
                              " normal! 0
                              " if curcol
                              "   execute "normal!" . curcol . "l"
                              " endif
    6              0.000098   if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
                                let skip = "0"
                              else
    6              0.003246     execute "if " . skip . "| let skip = '0' | endif"
    6              0.000007   endif
    6              0.012035   let sp_return = searchpair(ini, mid, fin, flag, skip)
    6              0.000071   let final_position = "call cursor(" . line(".") . "," . col(".") . ")"
                              " Restore cursor position and original screen.
    6              0.000245   execute restore_cursor
    6              0.000045   normal! m'
    6              0.000026   if sp_return > 0
    6              0.000055     execute final_position
    6              0.000011   endif
    6   0.000746   0.000126   return s:CleanUp(restore_options, a:mode, startline, startcol, mid.'\|'.fin)

FUNCTION  SyntasticRefreshCursor()
Called 1173 times
Total time:   3.573657
 Self time:   0.050083

count  total (s)   self (s)
 1173              0.008602     if !exists('b:syntastic_private_messages') || empty(b:syntastic_private_messages)
                                    " file not checked
  765              0.000947         return
                                endif
                            
  408              0.001490     if !exists('b:syntastic_private_line')
                                    let b:syntastic_private_line = -1
                                endif
  408              0.001104     let l = line('.')
  408              0.002787     let current_messages = get(b:syntastic_private_messages, l, {})
                            
  408              0.001470     if !exists('b:syntastic_cursor_columns')
                                    let b:syntastic_cursor_columns = g:syntastic_cursor_columns
                                endif
                            
  408              0.000713     if b:syntastic_cursor_columns
  408              0.001519         let c = virtcol('.')
  408              0.001418         if !exists('b:syntastic_private_idx')
    4              0.000018             let b:syntastic_private_idx = -1
    4              0.000004         endif
                            
  408   0.012973   0.004208         if s:_is_same_index(l, b:syntastic_private_line, c, b:syntastic_private_idx, current_messages)
   85              0.000079             return
                                    else
  323              0.001060             let b:syntastic_private_line = l
  323              0.000298         endif
                            
  323              0.000750         if !empty(current_messages)
  132   0.003051   0.000963             let b:syntastic_private_idx = s:_find_index(c, current_messages)
  132   3.514156   0.001436             call syntastic#util#wideMsg(current_messages[b:syntastic_private_idx].text)
  132              0.000212         else
  191              0.000507             let b:syntastic_private_idx = -1
  191              0.002326             echo
  191              0.000317         endif
  323              0.000329     else
                                    if l == b:syntastic_private_line
                                        return
                                    endif
                                    let b:syntastic_private_line = l
                            
                                    if !empty(current_messages)
                                        call syntastic#util#wideMsg(current_messages[0].text)
                                    else
                                        echo
                                    endif
                                endif

FUNCTION  <SNR>269_IsInStringOrDocumentation()
Called 55 times
Total time:   0.038958
 Self time:   0.038958

count  total (s)   self (s)
   55              0.038895   return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_stringdoc

FUNCTION  ctrlp#setlcdir()
Called 75 times
Total time:   0.020837
 Self time:   0.003121

count  total (s)   self (s)
   75              0.000358 	if exists('*haslocaldir')
   75   0.020048   0.002332 		cal ctrlp#setdir(getcwd(), haslocaldir() ? 'lc!' : 'cd!')
   75              0.000146 	en

FUNCTION  gitgutter#process_buffer()
Called 10791 times
Total time:  48.699069
 Self time:   2.903977

count  total (s)   self (s)
10791   1.348380   0.260245   call gitgutter#utility#use_known_shell()
                            
10791   0.890441   0.161453   call gitgutter#utility#set_buffer(a:bufnr)
10791   3.297534   0.115758   if gitgutter#utility#is_active()
 9725              0.061459     if g:gitgutter_sign_column_always
                                  call gitgutter#sign#add_dummy_sign()
                                endif
 9725              0.025124     try
 9725   0.634018   0.153230       if !a:realtime || gitgutter#utility#has_fresh_changes()
 8076  38.497049   0.165785         let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(), 0)
 2111              0.013637         if diff != 'async'
                                      call gitgutter#handle_diff(diff)
                                    endif
 2111              0.002967       endif
 3760              0.010010     catch /diff failed/
 5965   0.563582   0.067721       call gitgutter#debug#log('diff failed')
 5965   0.697331   0.045571       call gitgutter#hunk#reset()
 5965              0.021684     endtry
 9725   1.143835   1.006240     execute "silent doautocmd" s:nomodeline "User GitGutter"
 9725              0.037770   else
 1066   0.142388   0.009816     call gitgutter#hunk#reset()
 1066              0.002233   endif
                            
10791   0.706173   0.139821   call gitgutter#utility#restore_shell()

FUNCTION  <SNR>125_shortest()
Called 30308 times
Total time:   0.200724
 Self time:   0.200724

count  total (s)   self (s)
30308              0.183783 	retu min(map(values(a:lens), 'v:val[0]'))

FUNCTION  <SNR>118_AddBracketExpand()
Called 455 times
Total time:   0.030487
 Self time:   0.002599

count  total (s)   self (s)
  455   0.030288   0.002399   call s:AddSelectiveExpand(a:abbr,'[[.]',a:expn)

FUNCTION  <SNR>118_app_gems()
Called 1363 times
Total time:   0.085962
 Self time:   0.023128

count  total (s)   self (s)
 1363   0.073124   0.010290   if self.has('bundler') && exists('*bundler#project')
                                let project = bundler#project()
                                if has_key(project, 'gems')
                                  return bundler#project(self.path()).gems()
                                endif
                              endif
 1363              0.001219   return {}

FUNCTION  emmet#newNode()
Called 52 times
Total time:   0.000950
 Self time:   0.000950

count  total (s)   self (s)
   52              0.000769   return { 'name': '', 'attr': {}, 'child': [], 'snippet': '', 'basevalue': 0, 'basedirect': 1, 'multiplier': 1, 'parent': {}, 'value': '', 'pos': 0, 'important': 0, 'attrs_order': ['id', 'class'], 'block': 0, 'empty': 0 }

FUNCTION  <SNR>125_settype()
Called 109 times
Total time:   0.000705
 Self time:   0.000705

count  total (s)   self (s)
  109              0.000596 	retu a:type < 0 ? exists('s:itemtype') ? s:itemtype : 0 : a:type

FUNCTION  <SNR>118_app_rake_command()
Called 137 times
Total time:   0.045316
 Self time:   0.007699

count  total (s)   self (s)
  137              0.000814   let cmd = 'rake'
  137   0.029684   0.001417   if self.has_rails5() && get(a:, 1, '') !=# 'norails' && get(g:, 'rails_make', '') !=# 'rake'
                                let cmd = 'rails'
                              endif
  137              0.001013   if get(a:, 1, '') !=# 'static' && self.has_path('.zeus.sock') && executable('zeus')
                                return 'zeus ' . cmd
                              elseif self.has_path('bin/' . cmd)
  137   0.003309   0.001439     return self.ruby_script_command('bin/' . cmd)
                              elseif self.has('bundler')
                                return 'bundle exec ' . cmd
                              else
                                return cmd
                              endif

FUNCTION  <SNR>65_define_commands()
Called 121 times
Total time:   0.116144
 Self time:   0.116144

count  total (s)   self (s)
 3388              0.007441   for command in s:commands
 3267              0.102893     exe 'command! -buffer '.command
 3267              0.004121   endfor

FUNCTION  <SNR>74_InTmuxSession()
Called 262 times
Total time:   0.003559
 Self time:   0.003559

count  total (s)   self (s)
  262              0.003081   return $TMUX != ''

FUNCTION  <SNR>74_NeedsVitalityRedraw()
Called 5 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    5              0.000066   return exists('g:loaded_vitality') && v:version < 704 && !has("patch481")

FUNCTION  300()
Called 1443 times
Total time:   0.021680
 Self time:   0.021680

count  total (s)   self (s)
 1706              0.007215     for match in getmatches()
  263              0.001057         if stridx(match['group'], 'Syntastic') == 0
  169              0.000799             call matchdelete(match['id'])
  169              0.000163         endif
  263              0.000216     endfor

FUNCTION  301()
Called 1208 times
Total time:   0.074329
 Self time:   0.074329

count  total (s)   self (s)
 1208              0.027111     let newObj = copy(self)
                            
 1208              0.009171     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
 1410              0.003661     for e in llist
  202              0.000519         if get(e, 'type', '') ==# ''
    3              0.000009             let e['type'] = 'E'
    3              0.000009         endif
  202              0.000153     endfor
                            
 1208              0.003559     let newObj._rawLoclist = llist
 1208              0.003102     let newObj._name = ''
 1208              0.004518     let newObj._owner = bufnr('')
 1208              0.002803     let newObj._sorted = 0
 1208              0.003619     let newObj._columns = g:syntastic_cursor_columns
                            
 1208              0.001843     return newObj

FUNCTION  302()
Called 1579 times
Total time:   0.069123
 Self time:   0.046803

count  total (s)   self (s)
 1579              0.007240     let buf = a:0 ? a:1 : bufnr('')
 1579   0.026962   0.014713     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
 1579              0.007307     if type(loclist) != type({}) || empty(loclist)
  202              0.000400         unlet! loclist
  202   0.011449   0.001378         let loclist = g:SyntasticLoclist.New([])
  202              0.000217     endif
 1579              0.002120     return loclist

FUNCTION  303()
Called 30 times
Total time:   0.000496
 Self time:   0.000315

count  total (s)   self (s)
   30   0.000477   0.000295     call extend(self._rawLoclist, a:other.copyRaw())

FUNCTION  305()
Called 4670 times
Total time:   0.015248
 Self time:   0.015248

count  total (s)   self (s)
 4670              0.012935     return empty(self._rawLoclist)

FUNCTION  306()
Called 1000 times
Total time:   0.037843
 Self time:   0.014023

count  total (s)   self (s)
 1000              0.003006     if !exists('self._stamp')
   48              0.000142         let self._stamp = []
   48              0.000109         return 0
                                endif
  952   0.029073   0.005253     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  307()
Called 970 times
Total time:   0.003579
 Self time:   0.003579

count  total (s)   self (s)
  970              0.003044     return copy(self._rawLoclist)

FUNCTION  309()
Called 1006 times
Total time:   0.065579
 Self time:   0.015519

count  total (s)   self (s)
 1006   0.064437   0.014376     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  airline#extensions#csv#apply()
Called 601 times
Total time:   0.004565
 Self time:   0.004565

count  total (s)   self (s)
  601              0.001851   if &ft ==# "csv"
                                call airline#extensions#prepend_to_section('gutter', g:airline_left_alt_sep.' %{airline#extensions#csv#get_column()}')
                              endif

FUNCTION  ctrlp#mrufiles#bufs()
Called 109 times
Total time:   0.000550
 Self time:   0.000550

count  total (s)   self (s)
  109              0.000397 	retu s:mrbs

FUNCTION  fugitive#detect()
Called 121 times
Total time:   1.140126
 Self time:   0.707425

count  total (s)   self (s)
  121              0.001673   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
  121              0.000375   if !exists('b:git_dir')
   35   0.182779   0.000303     let dir = fugitive#extract_git_dir(a:path)
   35              0.000068     if dir !=# ''
   35              0.000091       let b:git_dir = dir
   35   0.033143   0.000854       if empty(fugitive#buffer().path())
                                    silent! exe haslocaldir() ? 'lcd .' : 'cd .'
                                  endif
   35              0.000023     endif
   35              0.000021   endif
  121              0.000341   if exists('b:git_dir')
  121              0.000850     if exists('#User#FugitiveBoot')
                                  try
                                    let [save_mls, &modelines] = [&mls, 0]
                                    doautocmd User FugitiveBoot
                                  finally
                                    let &mls = save_mls
                                  endtry
                                endif
  121              0.000413     if !exists('g:fugitive_no_maps')
  121              0.004602       cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
  121              0.001984       nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
  121              0.000151     endif
  121   0.007428   0.001304     let buffer = fugitive#buffer()
  121              0.004911     if expand('%:p') =~# '://'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
  121   0.002805   0.001664     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
  121              0.430545       if filereadable(b:git_dir.'/tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  endif
  121              0.239031       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
  121              0.000131     endif
  121              0.000210     try
  121              0.002524       let [save_mls, &modelines] = [&mls, 0]
  121   0.117431   0.001287       call s:define_commands()
  121   0.098345   0.003817       doautocmd User Fugitive
  121              0.000211     finally
  121              0.001208       let &mls = save_mls
  121              0.000239     endtry
  121              0.000111   endif

FUNCTION  airline#extensions#apply()
Called 2400 times
Total time:   0.290057
 Self time:   0.125955

count  total (s)   self (s)
 2400              0.009772   let s:active_winnr = winnr()
                            
 2400   0.150394   0.012276   if s:is_excluded_window()
                                return -1
                              endif
                            
 2400              0.005535   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
 2400              0.003464   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
 2400              0.011740   if has_key(s:filetype_overrides, &ft)
  113              0.000521     let args = s:filetype_overrides[&ft]
  113   0.026898   0.000913     call airline#extensions#apply_left_override(args[0], args[1])
  113              0.000094   endif
                            
 2400              0.008566   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  gitgutter#diff#is_added()
Called 2779 times
Total time:   0.009816
 Self time:   0.009816

count  total (s)   self (s)
 2779              0.008239   return a:from_count == 0 && a:to_count > 0

FUNCTION  airline#extensions#tabline#buflist#list()
Called 62691 times
Total time:   0.602078
 Self time:   0.602078

count  total (s)   self (s)
62691              0.244864   if exists('s:current_buffer_list')
62263              0.121917     return s:current_buffer_list
                              endif
                            
  428              0.001977   let excludes = get(g:, 'airline#extensions#tabline#excludes', [])
  428              0.001750   let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
  428              0.005503   let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
  428              0.000957   let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
 9853              0.009710   for nr in list
 9425              0.015744     if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) buffername matches exclude pattern
                                  " 2) buffer is a quickfix buffer
                                  " 3) exclude preview windows (if 'bufhidden' == wipe
                                  "    and 'buftype' == nofile
 5137              0.047709       if (!empty(excludes) && match(bufname(nr), join(excludes, '\|')) > -1) || (getbufvar(nr, 'current_syntax') == 'qf') ||  (exclude_preview && getbufvar(nr, '&bufhidden') == 'wipe'  && getbufvar(nr, '&buftype') == 'nofile')
                                    continue
                                  endif
 5137              0.012347       call add(buffers, nr)
 5137              0.003551     endif
 9425              0.006673   endfor
                            
  428              0.002006   let s:current_buffer_list = buffers
  428              0.000682   return buffers

FUNCTION  12()
Called 1709 times
Total time:   0.036812
 Self time:   0.011107

count  total (s)   self (s)
 1709              0.003191     if self.cachedDisplayString ==# ""
  475   0.027247   0.001542         call self.cacheDisplayString()
  475              0.000299     endif
                            
 1709              0.002030     return self.cachedDisplayString

FUNCTION  14()
Called 545 times
Total time:   0.017311
 Self time:   0.012647

count  total (s)   self (s)
  545   0.006874   0.002209     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
  545              0.001700         let self.drive = ''
  545              0.000479     endif
                            

FUNCTION  16()
Called 84 times
Total time:   0.001401
 Self time:   0.000742

count  total (s)   self (s)
   84   0.001006   0.000346     if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>$"
                                endif
                            
   84              0.000131     return " \\`\|\"#%&,?()\*^<>[]$"

FUNCTION  19()
Called 7146 times
Total time:   0.084144
 Self time:   0.084144

count  total (s)   self (s)
 7146              0.015234     if empty(self.pathSegments)
                                    return ''
                                endif
 7146              0.018654     let toReturn = self.pathSegments[-1]
 7146              0.011224     if a:dirSlash && self.isDirectory
  912              0.001839         let toReturn = toReturn . '/'
  912              0.000615     endif
 7146              0.007710     return toReturn

FUNCTION  syntastic#util#stamp()
Called 1414 times
Total time:   0.030436
 Self time:   0.030436

count  total (s)   self (s)
 1414              0.028780     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  <SNR>118_BufNavCommands()
Called 137 times
Total time:   0.028051
 Self time:   0.028051

count  total (s)   self (s)
  137              0.001119   command! -buffer -bar -nargs=? -complete=customlist,s:Complete_cd Cd    :cd `=rails#app().path(<q-args>)`
  137              0.000970   command! -buffer -bar -nargs=? -complete=customlist,s:Complete_cd Lcd  :lcd `=rails#app().path(<q-args>)`
  137              0.001796   command! -buffer -bar -nargs=? -complete=customlist,s:Complete_cd Rcd   :cd `=rails#app().path(<q-args>)`
  137              0.000918   command! -buffer -bar -nargs=? -complete=customlist,s:Complete_cd Rlcd :lcd `=rails#app().path(<q-args>)`
  137              0.001773   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_alternate A   exe s:Alternate('<mods> E<bang>',<line1>,<line2>,<count>,<f-args>)
  137              0.001723   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_alternate AE  exe s:Alternate('<mods> E<bang>',<line1>,<line2>,<count>,<f-args>)
  137              0.001755   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_alternate AS  exe s:Alternate('<mods> S<bang>',<line1>,<line2>,<count>,<f-args>)
  137              0.001725   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_alternate AV  exe s:Alternate('<mods> V<bang>',<line1>,<line2>,<count>,<f-args>)
  137              0.001684   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_alternate AT  exe s:Alternate('<mods> T<bang>',<line1>,<line2>,<count>,<f-args>)
  137              0.001661   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_edit      AD  exe s:Alternate('<mods> D<bang>',<line1>,<line2>,<count>,<f-args>)
  137              0.001627   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_edit      AR  exe s:Alternate('<mods> D<bang>',<line1>,<line2>,<count>,<f-args>)
  137              0.001718   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related   R   exe   s:Related('<mods> E<bang>',<line1>,<line2>,<count>,<f-args>)
  137              0.001752   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related   RE  exe   s:Related('<mods> E<bang>',<line1>,<line2>,<count>,<f-args>)
  137              0.001853   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related   RS  exe   s:Related('<mods> S<bang>',<line1>,<line2>,<count>,<f-args>)
  137              0.001786   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related   RV  exe   s:Related('<mods> V<bang>',<line1>,<line2>,<count>,<f-args>)
  137              0.001834   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_related   RT  exe   s:Related('<mods> T<bang>',<line1>,<line2>,<count>,<f-args>)
  137              0.001712   command! -buffer -bar -nargs=* -range=0 -complete=customlist,s:Complete_edit      RD  exe   s:Related('<mods> D<bang>',<line1>,<line2>,<count>,<f-args>)

FUNCTION  ctrlp#setlines()
Called 118 times
Total time:   1.794693
 Self time:   0.005464

count  total (s)   self (s)
  118              0.000868 	if a:0 | let s:itemtype = a:1 | en
  118   0.013586   0.000726 	cal s:modevar()
  118              0.000603 	let types = ['ctrlp#files()', 'ctrlp#buffers()', 'ctrlp#mrufiles#list()']
  118              0.000424 	if !empty(g:ctrlp_ext_vars)
                            		cal map(copy(g:ctrlp_ext_vars), 'add(types, v:val["init"])')
                            	en
  118   1.778171   0.001802 	let g:ctrlp_lines = eval(types[s:itemtype])

FUNCTION  108()
Called 503 times
Total time:   0.022722
 Self time:   0.003682

count  total (s)   self (s)
  503   0.022480   0.003439     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  109()
Called 108 times
Total time:   0.025468
 Self time:   0.001015

count  total (s)   self (s)
  108   0.025400   0.000946     return self.path.str() ==# a:treenode.path.str()

FUNCTION  gitgutter#utility#shellescape()
Called 7004 times
Total time:   0.335517
 Self time:   0.262311

count  total (s)   self (s)
 7004              0.163329   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
 4893              0.014993     return a:arg
                              elseif &shell =~# 'cmd' || gitgutter#utility#using_xolox_shell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
 2111              0.011373     return shellescape(a:arg)
                              endif

FUNCTION  <SNR>118_BufDatabase()
Called 442 times
Total time:   0.006775
 Self time:   0.006775

count  total (s)   self (s)
  442              0.003440   if exists("s:lock_database") || !exists('g:loaded_dbext') || !exists('b:rails_root')
  442              0.000754     return
                              endif
                              let self = rails#app()
                              if a:level > 1
                                call self.cache.clear('db_config')
                              elseif exists('g:rails_no_dbext')
                                return
                              endif
                              if (a:0 && !empty(a:1))
                                let env = a:1
                              else
                                let env = s:environment()
                              endif
                              if self.cache.needs('db_config') && a:level <= 0
                                return
                              endif
                              let dict = self.dbext_settings(env)
                              if empty(dict)
                                return
                              endif
                              for key in ['type', 'profile', 'bin', 'user', 'passwd', 'dbname', 'srvname', 'host', 'port', 'dsnname', 'extra', 'integratedlogin']
                                let b:dbext_{key} = get(dict,key,'')
                              endfor
                              if b:dbext_type == 'SQLITE'
                                " dbext seems to have overlooked the release of sqlite3 a decade ago
                                let g:dbext_default_SQLITE_bin = "sqlite3"
                              endif
                              if b:dbext_type == 'PGSQL'
                                let $PGPASSWORD = b:dbext_passwd
                              elseif exists('$PGPASSWORD')
                                let $PGPASSWORD = ''
                              endif

FUNCTION  310()
Called 60 times
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
   60              0.000178     return self._columns

FUNCTION  311()
Called 136 times
Total time:   0.010457
 Self time:   0.010457

count  total (s)   self (s)
  136              0.000493     if !exists('self._stl_format')
  136              0.000340         let self._stl_format = ''
  136              0.000112     endif
  136              0.000335     if !exists('self._stl_flag')
  136              0.000276         let self._stl_flag = ''
  136              0.000122     endif
                            
  136              0.000343     if g:syntastic_stl_format !=# self._stl_format
  136              0.000355         let self._stl_format = g:syntastic_stl_format
                            
  136              0.000324         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
  136              0.000252             let self._stl_flag = ''
  136              0.000114         endif
  136              0.000088     endif
                            
  136              0.000221     return self._stl_flag

FUNCTION  314()
Called 30 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
   30              0.000101     let self._name = a:name

FUNCTION  316()
Called 503 times
Total time:   0.004535
 Self time:   0.004535

count  total (s)   self (s)
  503              0.004073     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  317()
Called 503 times
Total time:   0.135077
 Self time:   0.093342

count  total (s)   self (s)
  503   0.015201   0.003671     let self._stamp = syntastic#util#stamp()
 1009   0.035104   0.004899     for buf in self.getBuffers()
  506              0.081608         call setbufvar(buf, 'syntastic_loclist', self)
  506              0.000568     endfor

FUNCTION  318()
Called 503 times
Total time:   0.046869
 Self time:   0.011495

count  total (s)   self (s)
 1009   0.039457   0.004083     for buf in self.getBuffers()
  506              0.004139         call setbufvar(buf, 'syntastic_loclist', {})
  506              0.000647     endfor

FUNCTION  <SNR>125_PrtFocusMap()
Called 868 times
Total time:  22.021821
 Self time:   0.027129

count  total (s)   self (s)
  868  22.019673   0.024981 	cal call(( s:focus ? 's:PrtAdd' : 's:PrtSelectJump' ), [a:char])

FUNCTION  SyntaxCheckers_ruby_mri_GetLocList()
Called 24 times
Total time:   7.010475
 Self time:   0.002092

count  total (s)   self (s)
   24   0.016137   0.000295     let makeprg = self.makeprgBuild({ 'args': '-w -T1', 'args_after': '-c' })
                            
                                "this is a hack to filter out a repeated useless warning in rspec files
                                "containing lines like
                                "
                                "  foo.should == 'bar'
                                "
                                "Which always generate the warning below. Note that ruby >= 1.9.3 includes
                                "the word "possibly" in the warning
   24              0.000126     let errorformat = '%-G%\m%.%#warning: %\%%(possibly %\)%\?useless use of == in void context,'
                            
                                " filter out lines starting with ...
                                " long lines are truncated and wrapped in ... %p then returns the wrong
                                " column offset
   24              0.000138     let errorformat .= '%-G%\%.%\%.%\%.%.%#,'
                            
   24              0.000182     let errorformat .= '%-GSyntax OK,'. '%E%f:%l: syntax error\, %m,'. '%Z%p^,'. '%W%f:%l: warning: %m,'. '%Z%p^,'. '%W%f:%l: %m,'. '%-C%.%#'
                            
   24   0.000633   0.000249     let env = syntastic#util#isRunningWindows() ? {} : { 'RUBYOPT': '' }
                            
   24   6.992744   0.000587     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'env': env })

FUNCTION  emmet#expandAbbrIntelligent()
Called 69 times
Total time:   0.429125
 Self time:   0.002588

count  total (s)   self (s)
   69   0.428555   0.002017   if !emmet#isExpandable()
   50              0.000134     return a:feedkey
                              endif
   19              0.000095   return "\<plug>(emmet-expand-abbr)"

FUNCTION  xolox#session#auto_save()
Called 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
                              " Automatically save the current editing session when Vim is closed.
                              " Normally called by the [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1              0.000017   if v:dying
                                " We won't save the session if Vim is not terminating normally.
                                return
                              endif
    1              0.000009   if g:session_autosave == 'no'
                                " We won't save the session if auto-save is explicitly disabled.
    1              0.000003     return
                              endif
                              " Get the name of the session for automatic saving.
                              let name = xolox#misc#option#get('session_autosave_to')
                              if empty(name)
                                " Get the name of the active session (if any).
                                let name = xolox#session#find_current_session()
                                " If no session is active and the user doesn't have any sessions yet,
                                " help them get started by suggesting to create the default session.
                                if empty(name) && (empty(xolox#session#get_names(0)) || g:session_default_overwrite)
                                  let name = g:session_default_name
                                endif
                              endif
                              " Prompt the user to save the active/first/default session?
                              if !empty(name)
                                let is_tab_scoped = xolox#session#is_tab_scoped()
                                let msg = "Do you want to save your %s before quitting Vim?"
                                if s:prompt(printf(msg, xolox#session#get_label(name, is_tab_scoped)), ["&Save", "&Don't Save"], 'g:session_autosave') == 1
                                  if g:session_default_overwrite && (name == g:session_default_name)
                                    let bang = '!'
                                  else
                                    let bang = ''
                                  endif
                                  if is_tab_scoped
                                    call xolox#session#save_tab_cmd(name, bang, 'SaveTabSession')
                                  else
                                    call xolox#session#save_cmd(name, bang, 'SaveSession')
                                  endif
                                endif
                              endif

FUNCTION  ctrlp#modfilecond()
Called 34 times
Total time:   0.000557
 Self time:   0.000557

count  total (s)   self (s)
   34              0.000508 	retu &mod && !&hid && &bh != 'hide' && s:bufwins(bufnr('%')) == 1 && !&cf && ( ( !&awa && a:w ) || filewritable(fnamemodify(bufname('%'), ':p')) != 1 )

FUNCTION  20()
Called 475 times
Total time:   0.030070
 Self time:   0.016939

count  total (s)   self (s)
  475              0.000813     let i = 0
 1330              0.002810     while i < len(g:NERDTreeSortOrder)
 1159   0.020666   0.007535         if  self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
  304              0.000422             return i
                                    endif
  855              0.001425         let i = i + 1
  855              0.000752     endwhile
  171              0.000237     return s:NERDTreeSortStarIndex

FUNCTION  22()
Called 2460 times
Total time:   0.084940
 Self time:   0.049565

count  total (s)   self (s)
 2460              0.005794     if !exists("self._sortKey")
  473   0.007847   0.001930         let path = self.getLastPathComponent(1)
  473              0.000758         if !g:NERDTreeSortHiddenFirst
                                        let path = substitute(path, '^[._]', '', '')
                                    endif
  473              0.000650         if !g:NERDTreeCaseSensitiveSort
  473              0.001154             let path = tolower(path)
  473              0.000321         endif
  473              0.000574         if !g:NERDTreeNaturalSort
  473   0.031743   0.002286             let self._sortKey = [self.getSortOrderIndex(), path]
  473              0.000394         else
                                        let self._sortKey = [self.getSortOrderIndex()] + self._splitChunks(path)
                                    endif
  473              0.000270     endif
                            
 2460              0.002606     return self._sortKey

FUNCTION  <SNR>32_jumpToPrevSibling()
Called 2 times
Total time:   0.015130
 Self time:   0.000043

count  total (s)   self (s)
    2   0.015127   0.000040     call s:jumpToSibling(a:node, 0)

FUNCTION  25()
Called 4493 times
Total time:   0.382796
 Self time:   0.169793

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
 4493   0.023278   0.014246     if a:nerdtree.ui.isIgnoreFilterEnabled()
 8986              0.012445         for i in g:NERDTreeIgnore
 4493   0.173290   0.015307             if self._ignorePatternMatches(i)
                                            return 1
                                        endif
 4493              0.003105         endfor
                            
 4493   0.046252   0.016816         for callback in g:NERDTree.PathFilters()
                                        if {callback}({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
                                    endfor
 4493              0.002510     endif
                            
                                "dont show hidden files unless instructed to
 4493   0.025470   0.017215     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
                                    return 1
                                endif
                            
 4493   0.024691   0.016396     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
 4493              0.003131     return 0

FUNCTION  26()
Called 4493 times
Total time:   0.157983
 Self time:   0.107979

count  total (s)   self (s)
 4493              0.008723     let pat = a:pattern
 4493              0.016196     if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
 4493   0.072770   0.022766     return self.getLastPathComponent(0) =~# pat

FUNCTION  ctrlp#statusline()
Called 1054 times
Total time:   6.045446
 Self time:   0.105925

count  total (s)   self (s)
 1054              0.004003 	if !exists('s:statypes')
  109              0.000674 		let s:statypes = [ ['files', 'fil'], ['buffers', 'buf'], ['mru files', 'mru'], ]
  109              0.000271 		if !empty(g:ctrlp_ext_vars)
                            			cal map(copy(g:ctrlp_ext_vars), 'add(s:statypes, [ v:val["lname"], v:val["sname"] ])')
                            		en
  109              0.000058 	en
 1054              0.002307 	let tps = s:statypes
 1054              0.003651 	let max = len(tps) - 1
 1054   0.014439   0.008503 	let nxt = tps[s:walker(max, s:itemtype,  1)][1]
 1054   0.011680   0.007262 	let prv = tps[s:walker(max, s:itemtype, -1)][1]
 1054              0.004175 	let s:ctype = tps[s:itemtype][0]
 1054              0.002883 	let focus   = s:focus ? 'prt'  : 'win'
 1054              0.003264 	let byfname = s:ispath ? s:byfname ? 'file' : 'path' : 'line'
 1054              0.006384 	let marked  = s:opmul != '0' ? exists('s:marked') ? ' <'.s:dismrk().'>' : ' <->' : ''
 1054              0.002192 	if s:status != {}
 1054              0.011773 		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{ 'focus':   focus, 'byfname': byfname, 'regex':   s:regexp, 'prev':    prv, 'item':    s:ctype, 'next':    nxt, 'marked':  marked, }] : [focus, byfname, s:regexp, prv, s:ctype, nxt, marked]
 1054   5.952851   0.023685 		let &l:stl = call(s:status['main'], argms, s:status)
 1054              0.001083 	el
                            		let item    = '%#CtrlPMode1# '.s:ctype.' %*'
                            		let focus   = '%#CtrlPMode2# '.focus.' %*'
                            		let byfname = '%#CtrlPMode1# '.byfname.' %*'
                            		let regex   = s:regexp  ? '%#CtrlPMode2# regex %*' : ''
                            		let slider  = ' <'.prv.'>={'.item.'}=<'.nxt.'>'
                            		let dir     = ' %=%<%#CtrlPMode2# %{getcwd()} %*'
                            		let &l:stl  = focus.byfname.regex.slider.marked.dir
                            	en

FUNCTION  <SNR>125_AcceptSelection()
Called 77 times
Total time: 427.250969
 Self time:   0.017802

count  total (s)   self (s)
   77              0.003737 	let [md, icr] = [a:action[0], match(a:action, 'r') >= 0]
   77              0.000925 	let subm = icr || ( !icr && md == 'e' )
   77   0.003239   0.001484 	if !subm && s:OpenMulti(md) != -1 | retu | en
   77   0.007952   0.000824 	let str = s:getinput()
   77   0.004910   0.001002 	if subm | if s:SpecInputs(str) | retu | en | en
                            	" Get the selected line
   77   0.002839   0.000655 	let line = ctrlp#getcline()
   77              0.000515 	if !subm && !s:itemtype && line == '' && line('.') > s:offset && str !~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*|/|\\|\?|\@.+)$'
                            		cal s:CreateNewFile(md) | retu
                            	en
   77              0.000392 	if empty(line) | retu | en
                            	" Do something with it
   77              0.000364 	if s:openfunc != {} && has_key(s:openfunc, s:ctype)
                            		let actfunc = s:openfunc[s:ctype]
                            		let type = has_key(s:openfunc, 'arg_type') ? s:openfunc['arg_type'] : 'list'
                            	el
   77              0.000176 		if s:itemtype < 3
   77              0.000460 			let [actfunc, type] = ['ctrlp#acceptfile', 'dict']
   77              0.000102 		el
                            			let [actfunc, exttype] = [s:getextvar('accept'), s:getextvar('act_farg')]
                            			let type = exttype == 'dict' ? exttype : 'list'
                            		en
   77              0.000087 	en
   77              0.000801 	let actargs = type == 'dict' ? [{ 'action': md, 'line': line, 'icr': icr }] : [md, line]
   77 427.220670   0.002477 	cal call(actfunc, actargs)

FUNCTION  <SNR>118_app_path()
Called 10949 times
Total time:   0.126927
 Self time:   0.126927

count  total (s)   self (s)
10949              0.055754   if a:0 && a:1 =~# '\%(^\|^\w*:\)[\/]'
 2100              0.003222     return a:1
                              else
 8849              0.042107     return join([self.root]+a:000,'/')
                              endif

FUNCTION  112()
Called 2 times
Total time:   0.001691
 Self time:   0.000113

count  total (s)   self (s)
                                "if we have no parent then we can have no siblings
    2              0.000016     if self.parent != {}
                            
                                    "get the index of this node in its parents children
    1   0.001415   0.000017         let siblingIndx = self.parent.getChildIndex(self.path)
                            
    1              0.000002         if siblingIndx != -1
                                        "move a long to the next potential sibling node
    1              0.000006             let siblingIndx = a:direction ==# 1 ? siblingIndx+1 : siblingIndx-1
                            
                                        "keep moving along to the next sibling till we find one that is valid
    1   0.000011   0.000007             let numSiblings = self.parent.getChildCount()
    1              0.000004             while siblingIndx >= 0 && siblingIndx < numSiblings
                            
                                            "if the next node is not an ignored node (i.e. wont show up in the
                                            "view) then return it
    1   0.000187   0.000012                 if self.parent.children[siblingIndx].path.ignore(self.getNerdtree()) ==# 0
    1              0.000004                     return self.parent.children[siblingIndx]
                                            endif
                            
                                            "go to next node
                                            let siblingIndx = a:direction ==# 1 ? siblingIndx+1 : siblingIndx-1
                                        endwhile
                                    endif
                                endif
                            
    1              0.000001     return {}

FUNCTION  113()
Called 5667 times
Total time:   0.011152
 Self time:   0.011152

count  total (s)   self (s)
 5667              0.008819     return self._nerdtree

FUNCTION  115()
Called 56 times
Total time:   0.363775
 Self time:   0.002296

count  total (s)   self (s)
   56              0.000186     try
   56   0.154058   0.000899         let path = b:NERDTree.ui.getPath(line("."))
   53              0.000143         if path ==# {}
                                        return {}
                                    endif
   53   0.208778   0.000458         return b:NERDTree.root.findNode(path)
                                catch /^NERDTree/
    3              0.000008         return {}
                                endtry

FUNCTION  117()
Called 108 times
Total time:   0.028063
 Self time:   0.001813

count  total (s)   self (s)
  108   0.001069   0.000557     if !g:NERDTree.ExistsForBuf()
                                    throw "NERDTree.NoTreeError: No tree exists for the current buffer"
                                endif
                            
  108   0.026506   0.000768     return self.equals(self.getNerdtree().root)

FUNCTION  118()
Called 475 times
Total time:   0.023446
 Self time:   0.007384

count  total (s)   self (s)
  475              0.000973     if a:path.isDirectory
  304   0.017679   0.001616         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
                                else
  171              0.002039         let newTreeNode = copy(self)
  171              0.000515         let newTreeNode.path = a:path
  171              0.000404         let newTreeNode.parent = {}
  171              0.000457         let newTreeNode._nerdtree = a:nerdtree
  171              0.000266         return newTreeNode
                                endif

FUNCTION  322()
Called 61 times
Total time:   0.001852
 Self time:   0.000649

count  total (s)   self (s)
   61              0.000186     if !exists('self._cachedWarnings')
   30   0.001394   0.000191         let self._cachedWarnings = self.filter({'type': 'W'})
   30              0.000030     endif
   61              0.000084     return self._cachedWarnings

FUNCTION  324()
Called 60 times
Total time:   0.034114
 Self time:   0.024582

count  total (s)   self (s)
   60              0.000404     if !exists('self._cachedMessages')
   30              0.000093         let self._cachedMessages = {}
                            
   30   0.000755   0.000256         let errors = self.errors() + self.warnings()
  232              0.000231         for e in errors
  202              0.000336             let b = e['bufnr']
  202              0.000293             let l = e['lnum']
                            
  202              0.000456             if !has_key(self._cachedMessages, b)
   30              0.000099                 let self._cachedMessages[b] = {}
   30              0.000025             endif
                            
  202              0.000509             if !has_key(self._cachedMessages[b], l)
  172              0.000575                 let self._cachedMessages[b][l] = [e]
  172              0.000203             elseif self._columns
   30              0.000105                 call add(self._cachedMessages[b][l], e)
   30              0.000025             endif
  202              0.000133         endfor
                            
   30              0.000055         if self._columns
   30              0.000038             if !self._sorted
   60              0.000146                 for b in keys(self._cachedMessages)
  202              0.000287                     for l in keys(self._cachedMessages[b])
  172              0.003014                         if len(self._cachedMessages[b][l]) > 1
   90              0.000145                             for e in self._cachedMessages[b][l]
   60   0.001879   0.000308                                 call s:_set_screen_column(e)
   60              0.000055                             endfor
   30   0.001158   0.000278                             call sort(self._cachedMessages[b][l], 's:_compare_error_items_by_columns')
   30              0.000027                         endif
  172              0.000114                     endfor
   30              0.000027                 endfor
   30              0.000022             endif
                            
   60              0.000112             for b in keys(self._cachedMessages)
  202              0.000249                 for l in keys(self._cachedMessages[b])
  172   0.007474   0.000891                     call s:_remove_shadowed_items(self._cachedMessages[b][l])
  172              0.000116                 endfor
   30              0.000020             endfor
   30              0.000020         endif
   30              0.000018     endif
                            
   60              0.000284     return get(self._cachedMessages, a:buf, {})

FUNCTION  325()
Called 60 times
Total time:   0.002583
 Self time:   0.002180

count  total (s)   self (s)
   60   0.001162   0.000760     let conditions = values(map(copy(a:filters), 's:_translate(v:key, v:val)'))
   60              0.000378     let filter = len(conditions) == 1 ? conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')
   60              0.000957     return filter(copy(self._rawLoclist), filter)

FUNCTION  329()
Called 503 times
Total time:   0.018377
 Self time:   0.018377

count  total (s)   self (s)
  503              0.002560     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
  503              0.001696         let self._mode = 'active'
  503              0.001700         let self._activeFiletypes = []
  503              0.001324         let self._passiveFiletypes = []
  503              0.000580     endif

FUNCTION  <SNR>54__is_same_index()
Called 408 times
Total time:   0.008765
 Self time:   0.008765

count  total (s)   self (s)
  408              0.001781     if a:old_line >= 0 && a:line == a:old_line && a:idx >= 0
   85              0.000227         if len(a:messages) <= 1
   84              0.000104             return 1
                                    endif
                            
    1              0.000004         if a:messages[a:idx].scol <= a:column || a:idx == 0
    1              0.000005             if a:idx == len(a:messages) - 1 || a:column < a:messages[a:idx + 1].scol
    1              0.000001                 return 1
                                        else
                                            return 0
                                        endif
                                    else
                                        return 0
                                    endif
                                else
  323              0.000364         return 0
                                endif

FUNCTION  <SNR>125_SpecInputs()
Called 36 times
Total time:   0.003908
 Self time:   0.003908

count  total (s)   self (s)
   36              0.000901 	if a:str =~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*)$' && s:spi
                            		let cwd = s:dyncwd
                            		cal ctrlp#setdir(a:str =~ '^\.\.\.*$' ? '../'.repeat('../', strlen(a:str) - 2) : a:str)
                            		if cwd != s:dyncwd | cal ctrlp#setlines() | en
                            		cal s:PrtClear()
                            		retu 1
                            	elsei a:str == s:lash && s:spi
                            		cal s:SetWD({ 'mode': 'rd' })
                            		cal ctrlp#setlines()
                            		cal s:PrtClear()
                            		retu 1
                            	elsei a:str =~ '^@.\+' && s:spi
                            		retu s:at(a:str)
                            	elsei a:str == '?'
                            		cal s:PrtExit()
                            		let hlpwin = &columns > 159 ? '| vert res 80' : ''
                            		sil! exe 'bo vert h ctrlp-mappings' hlpwin '| norm! 0'
                            		retu 1
                            	en
   36              0.000061 	retu 0

FUNCTION  <SNR>56__translate()
Called 60 times
Total time:   0.000403
 Self time:   0.000403

count  total (s)   self (s)
   60              0.000344     return 'get(v:val, ' . string(a:key) . ', "") ==? ' . string(a:val)

FUNCTION  gitgutter#sign#next_sign_id()
Called 813 times
Total time:   0.005717
 Self time:   0.005717

count  total (s)   self (s)
  813              0.002081   let next_id = s:next_sign_id
  813              0.001826   let s:next_sign_id += 1
  813              0.001011   return next_id

FUNCTION  rails#buffer()
Called 1086 times
Total time:   0.023002
 Self time:   0.023002

count  total (s)   self (s)
 1086              0.022198   return extend(extend({'#': bufnr(a:0 ? a:1 : '%')},s:buffer_prototype,'keep'),s:readable_prototype,'keep')

FUNCTION  <SNR>118_readable_controller_name()
Called 162 times
Total time:   1.105413
 Self time:   0.014882

count  total (s)   self (s)
  162   0.036212   0.000796   let f = self.name()
  162   0.002303   0.000989   if has_key(self,'getvar') && self.getvar('rails_controller') != ''
                                return self.getvar('rails_controller')
                              endif
  162   1.055372   0.004479   let [affinity, root] = self.find_affinity()
  162              0.000339   if affinity ==# 'controller'
   22              0.000028     return root
                              elseif affinity ==# 'resource'
                                return rails#pluralize(root)
                              endif
  140              0.001200   if f =~ '\<app/views/layouts/'
   78   0.002675   0.000639     return s:sub(f,'.*<app/views/layouts/(.{-})\..*','\1')
                              elseif f =~ '\<app/views/'
   30   0.001097   0.000226     return s:sub(f,'.*<app/views/(.{-})/\w+%(\.[[:alnum:]_+]+)=\.\w+$','\1')
                              elseif f =~ '\<app/helpers/.*_helper\.rb$'
                                return s:sub(f,'.*<app/helpers/(.{-})_helper\.rb$','\1')
                              elseif f =~ '\<app/controllers/.*\.rb$'
                                return s:sub(f,'.*<app/controllers/(.{-})%(_controller)=\.rb$','\1')
                              elseif f =~ '\<app/mailers/.*\.rb$'
                                return s:sub(f,'.*<app/mailers/(.{-})\.rb$','\1')
                              elseif f =~ '\<app/jobs/.*\.rb$'
                                return s:sub(f,'.*<app/jobs/(.{-})%(_job)=\.rb$','\1')
                              elseif f =~ '\<test/\%(functional\|controllers\)/.*_test\.rb$'
                                return s:sub(f,'.*<test/%(functional|controllers)/(.{-})%(_controller)=_test\.rb$','\1')
                              elseif f =~ '\<test/\%(unit/\)\?helpers/.*_helper_test\.rb$'
                                return s:sub(f,'.*<test/%(unit/)?helpers/(.{-})_helper_test\.rb$','\1')
                              elseif f =~ '\<spec/controllers/.*_spec\.rb$'
                                return s:sub(f,'.*<spec/controllers/(.{-})%(_controller)=_spec\.rb$','\1')
                              elseif f =~ '\<spec/jobs/.*_spec\.rb$'
                                return s:sub(f,'.*<spec/jobs/(.{-})%(_job)=_spec\.rb$','\1')
                              elseif f =~ '\<spec/helpers/.*_helper_spec\.rb$'
                                return s:sub(f,'.*<spec/helpers/(.{-})_helper_spec\.rb$','\1')
                              elseif f =~ '\<spec/views/.*/\w\+_view_spec\.rb$'
                                return s:sub(f,'.*<spec/views/(.{-})/\w+_view_spec\.rb$','\1')
                              elseif f =~ '\<app/models/.*\.rb$' && self.type_name('mailer')
                                return s:sub(f,'.*<app/models/(.{-})\.rb$','\1')
                              elseif f =~ '\<\%(public\|app/assets\)/stylesheets/[^.]\+\.'
                                return s:sub(f,'.*<%(public|app/assets)/stylesheets/(.{-})\..*$','\1')
                              elseif f =~ '\<\%(public\|app/assets\)/javascripts/.[^.]\+\.'
                                return s:sub(f,'.*<%(public|app/assets)/javascripts/(.{-})\..*$','\1')
                              elseif a:0 && a:1
                                return rails#pluralize(self.model_name())
                              endif
   32              0.000032   return ""

FUNCTION  30()
Called 442 times
Total time:   0.106992
 Self time:   0.003826

count  total (s)   self (s)
  442   0.106779   0.003614     return self.str() ==# a:path.str()

FUNCTION  31()
Called 545 times
Total time:   0.216250
 Self time:   0.028556

count  total (s)   self (s)
  545              0.015402     let newPath = copy(self)
                            
  545   0.370140   0.188334     call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))
                            
  542              0.001399     let newPath.cachedDisplayString = ""
  542   0.010204   0.004316     let newPath.flagSet = g:NERDTreeFlagSet.New()
                            
  542              0.000798     return newPath

FUNCTION  32()
Called 4632 times
Total time:   0.063324
 Self time:   0.022526

count  total (s)   self (s)
 4632   0.061209   0.020411     return nerdtree#runningWindows() ? '\' : '/'

FUNCTION  33()
Called 1099 times
Total time:   0.029440
 Self time:   0.029440

count  total (s)   self (s)
 1099              0.015070     let tmp = resolve(a:path)
 1099              0.013413     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  34()
Called 545 times
Total time:   0.142610
 Self time:   0.072601

count  total (s)   self (s)
  545   0.020401   0.003090     call self.extractDriveLetter(a:fullpath)
                            
  545   0.011498   0.003210     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
  545              0.005649     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
  545              0.011310     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                            
  545              0.001679     let self.isReadOnly = 0
  545              0.003848     if isdirectory(a:fullpath)
  369              0.001454         let self.isDirectory = 1
  369              0.000894     elseif filereadable(a:fullpath)
  173              0.000658         let self.isDirectory = 0
  173              0.002130         let self.isReadOnly = filewritable(a:fullpath) ==# 0
  173              0.000221     else
    3              0.183499         throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
  542              0.001591     let self.isExecutable = 0
  542              0.000927     if !self.isDirectory
  173              0.001599         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
  173              0.000206     endif
                            
                                "grab the last part of the path (minus the trailing slash)
  542   0.012347   0.003516     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
  542   0.026794   0.005388     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
  542   0.019263   0.005090     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
  542              0.001024     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  38()
Called 2298 times
Total time:   0.266508
 Self time:   0.127788

count  total (s)   self (s)
 2298              0.007407     let options = a:0 ? a:1 : {}
 2298              0.004537     let toReturn = ""
                            
 2298              0.006067     if has_key(options, 'format')
  305              0.000898         let format = options['format']
  305              0.001060         if has_key(self, '_strFor' . format)
  305   0.015105   0.002739             exec 'let toReturn = self._strFor' . format . '()'
  305              0.000308         else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
  305              0.000203     else
 1993   0.124847   0.009852         let toReturn = self._str()
 1993              0.002358     endif
                            
 2298   0.022468   0.011110     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
 2298              0.005767     if has_key(options, 'truncateTo')
   67              0.000168         let limit = options['truncateTo']
   67              0.000202         if len(toReturn) > limit-1
                                        let toReturn = toReturn[(len(toReturn)-limit+1):]
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
                                    endif
   67              0.000036     endif
                            
 2298              0.003202     return toReturn

FUNCTION  39()
Called 221 times
Total time:   0.003681
 Self time:   0.003681

count  total (s)   self (s)
  221              0.001617     let toReturn = '/' . join(self.pathSegments, '/')
  221              0.000707     if self.isDirectory && toReturn != '/'
  220              0.000564         let toReturn  = toReturn . '/'
  220              0.000205     endif
  221              0.000300     return toReturn

FUNCTION  <SNR>65_winshell()
Called 694 times
Total time:   0.007148
 Self time:   0.007148

count  total (s)   self (s)
  694              0.006530   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>118_app_internal_load_path()
Called 97 times
Total time:   1.120330
 Self time:   0.063994

count  total (s)   self (s)
   97              0.000291   let path = ['lib', 'vendor']
   97              0.000380   let path += get(g:, 'rails_path_additions', [])
   97              0.000363   let path += get(g:, 'rails_path', [])
   97              0.000498   let path += ['app/models/concerns', 'app/controllers/concerns', 'app/controllers', 'app/helpers', 'app/mailers', 'app/models', 'app/jobs']
                            
   97              0.000280   let true = get(v:, 'true', 1)
 3686   0.500143   0.009164   for [key, projection] in items(self.projections())
 3589              0.021084     if get(projection, 'path', 0) is true || get(projection, 'autoload', 0) is true || get(projection, 'path', 0) is 1 || get(projection, 'autoload', 0) is 1 && key =~# '\.rb$'
                                  let path += split(key, '*')[0]
                                endif
 3589              0.002399   endfor
   97   0.481341   0.002660   let projected = get(get(self.projections(), '*.rb', {}), 'path', [])
   97              0.000640   let path += filter(type(projected) == type([]) ? projected : [projected], 'type(v:val) == type("")')
                            
   97              0.000223   let path += ['app/*']
                            
   97   0.004416   0.000457   if self.has('test')
   97              0.000557     let path += ['test', 'test/unit', 'test/functional', 'test/integration', 'test/controllers', 'test/helpers', 'test/mailers', 'test/models', 'test/jobs']
   97              0.000068   endif
   97   0.004296   0.000380   if self.has('spec')
                                let path += ['spec', 'spec/controllers', 'spec/helpers', 'spec/mailers', 'spec/models', 'spec/views', 'spec/lib', 'spec/features', 'spec/requests', 'spec/integration', 'spec/jobs']
                              endif
   97   0.003896   0.000368   if self.has('cucumber')
                                let path += ['features']
                              endif
   97   0.088555   0.013282   call map(path, 'rails#app().path(v:val)')
   97              0.000130   return path

FUNCTION  ctrlp#mrufiles#cachefile()
Called 18 times
Total time:   0.000488
 Self time:   0.000488

count  total (s)   self (s)
   18              0.000156 	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
                            	en
   18              0.000048 	retu s:cafile

FUNCTION  123()
Called 66 times
Total time:   0.097101
 Self time:   0.012233

count  total (s)   self (s)
   66   0.085657   0.000790     let ln = self.getNerdtree().ui.getLineNum(self)
   66              0.000103     if ln != -1
   66              0.000086         if a:isJump
    1              0.009650             mark '
    1              0.000010         endif
   66              0.000276         call cursor(ln, col("."))
   66              0.000056     else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call self._nerdtree.render()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
                                endif

FUNCTION  127()
Called 67 times
Total time:   0.605793
 Self time:   0.000410

count  total (s)   self (s)
   67   0.605753   0.000370     return self._renderToString(0, 0)

FUNCTION  128()
Called 1776 times
Total time:   1.159633
 Self time:   0.846933

count  total (s)   self (s)
 1776              0.003012     let output = ""
 1776              0.002404     if a:drawText ==# 1
                            
 1709              0.005263         let treeParts = repeat('  ', a:depth - 1)
                            
 1709              0.002493         if !self.path.isDirectory
  503              0.001011             let treeParts = treeParts . '  '
  503              0.000373         endif
                            
 1709   0.202530   0.007276         let line = treeParts . self.displayString()
                            
 1709              0.003817         let output = output . line . "\n"
 1709              0.001117     endif
                            
                                "if the node is an open dir, draw its children
 1776              0.003100     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
  166   0.169978   0.000734         let childNodesToDraw = self.getVisibleChildren()
                            
  166   0.163439   0.000644         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
                                    elseif len(childNodesToDraw) > 0
 1874              0.001769             for i in childNodesToDraw
 1709              0.007550                 let output = output . i._renderToString(a:depth + 1, 1)
 1709              0.001447             endfor
  165              0.000098         endif
  166              0.000083     endif
                            
 1776              0.001819     return output

FUNCTION  emmet#util#getcurpos()
Called 27 times
Total time:   0.000343
 Self time:   0.000343

count  total (s)   self (s)
   27              0.000107   let pos = getpos('.')
   27              0.000095   if mode(0) ==# 'i' && pos[2] > 0
   19              0.000045     let pos[2] -=1
   19              0.000015   endif
   27              0.000030   return pos

FUNCTION  330()
Called 503 times
Total time:   0.064809
 Self time:   0.020065

count  total (s)   self (s)
  503   0.015408   0.006811     let registry = g:SyntasticRegistry.Instance()
  503   0.031290   0.004158     let fts = registry.resolveFiletypes(a:filetype)
                            
  503   0.005153   0.002900     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
  503   0.009584   0.002823         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  331()
Called 503 times
Total time:   0.076856
 Self time:   0.012047

count  total (s)   self (s)
  503              0.002996     let local_mode = getbufvar(a:buf, 'syntastic_mode')
  503              0.001990     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
  503   0.069381   0.004572     return self.allowsAutoChecking(getbufvar(a:buf, '&filetype'))

FUNCTION  332()
Called 503 times
Total time:   0.002253
 Self time:   0.002253

count  total (s)   self (s)
  503              0.001741     return self._mode ==# 'passive'

FUNCTION  337()
Called 503 times
Total time:   0.006761
 Self time:   0.006761

count  total (s)   self (s)
  503              0.006347     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  nerdtree#checkForBrowse()
Called 458 times
Total time:   0.114407
 Self time:   0.114407

count  total (s)   self (s)
  458              0.112984     if !isdirectory(a:dir)
  458              0.000681         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  <SNR>125_PrtBS()
Called 68 times
Total time:   1.680304
 Self time:   0.006296

count  total (s)   self (s)
   68              0.001264 	if !s:focus | retu | en
   68              0.000342 	unl! s:hstgot
   68              0.003150 	let [s:prompt[0], s:matches] = [substitute(s:prompt[0], '.$', '', ''), 1]
   68   1.675231   0.001222 	cal s:BuildPrompt(1)

FUNCTION  <SNR>125_modevar()
Called 118 times
Total time:   0.012860
 Self time:   0.004695

count  total (s)   self (s)
  118   0.001542   0.000823 	let s:matchtype = s:mtype()
  118   0.002026   0.000776 	let s:ispath = s:ispathitem()
  118   0.004201   0.000734 	let s:mfunc = s:mfunc()
  118   0.002298   0.000836 	let s:nolim = s:getextvar('nolim')
  118   0.001994   0.000726 	let s:dosort = s:getextvar('sort')
  118              0.000560 	let s:spi = !s:itemtype || s:getextvar('specinput') > 0

FUNCTION  <SNR>125_log()
Called 218 times
Total time:   0.006010
 Self time:   0.006010

count  total (s)   self (s)
  218              0.001590 	if exists('g:ctrlp_log') && g:ctrlp_log | if a:m
                            		let cadir = ctrlp#utils#cachedir()
                            		let apd = g:ctrlp_log > 1 ? '>' : ''
                            		sil! exe 'redi! >'.apd cadir.s:lash(cadir).'ctrlp.log'
                            	el
                            		sil! redi END
                            	en | en

FUNCTION  42()
Called 84 times
Total time:   0.008685
 Self time:   0.003798

count  total (s)   self (s)
   84   0.001521   0.000426     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
   84   0.000976   0.000311     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
   84   0.001923   0.000872     let toReturn = lead . join(self.pathSegments, s:Path.Slash())
                            
   84   0.001012   0.000337     if !nerdtree#runningWindows()
   84   0.002491   0.001089         let toReturn = escape(toReturn, self._escChars())
   84              0.000076     endif
   84              0.000108     return toReturn

FUNCTION  43()
Called 1993 times
Total time:   0.114995
 Self time:   0.043606

count  total (s)   self (s)
 1993   0.037370   0.009449     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
 1993   0.024876   0.007699     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
 1993   0.043170   0.016880     return lead . join(self.pathSegments, s:Path.Slash())

FUNCTION  44()
Called 542 times
Total time:   0.006841
 Self time:   0.006841

count  total (s)   self (s)
  542              0.006492     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  46()
Called 545 times
Total time:   0.008287
 Self time:   0.003664

count  total (s)   self (s)
  545   0.006691   0.002067     if !nerdtree#runningWindows()
  545              0.001034         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  emmet#getFilters()
Called 27 times
Total time:   0.008633
 Self time:   0.000543

count  total (s)   self (s)
   27   0.008389   0.000299   let filterstr = emmet#getResource(a:type, 'filters', '')
   27              0.000203   return split(filterstr, '\s*,\s*')

FUNCTION  AutoPairsDelete()
Called 478 times
Total time:   0.119550
 Self time:   0.119550

count  total (s)   self (s)
  478              0.008552   if !b:autopairs_enabled
                                return "\<BS>"
                              end
                            
  478              0.006626   let line = getline('.')
  478              0.005189   let pos = col('.') - 1
  478              0.013721   let current_char = get(split(strpart(line, pos), '\zs'), 0, '')
  478              0.014692   let prev_chars = split(strpart(line, 0, pos), '\zs')
  478              0.002952   let prev_char = get(prev_chars, -1, '')
  478              0.002420   let pprev_char = get(prev_chars, -2, '')
                            
  478              0.002414   if pprev_char == '\'
                                return "\<BS>"
                              end
                            
                              " Delete last two spaces in parens, work with MapSpace
  478              0.003649   if has_key(b:AutoPairs, pprev_char) && prev_char == ' ' && current_char == ' '
                                return "\<BS>\<DEL>"
                              endif
                            
                              " Delete Repeated Pair eg: '''|''' [[|]] {{|}}
  478              0.001965   if has_key(b:AutoPairs, prev_char)
    3              0.000010     let times = 0
    3              0.000008     let p = -1
    6              0.000042     while get(prev_chars, p, '') == prev_char
    3              0.000017       let p = p - 1
    3              0.000013       let times = times + 1
    3              0.000015     endwhile
                            
    3              0.000017     let close = b:AutoPairs[prev_char]
    3              0.000019     let left = repeat(prev_char, times)
    3              0.000015     let right = repeat(close, times)
                            
    3              0.000023     let before = strpart(line, pos-times, times)
    3              0.000018     let after  = strpart(line, pos, times)
    3              0.000016     if left == before && right == after
    3              0.000021       return repeat("\<BS>\<DEL>", times)
                                end
                              end
                            
                            
  475              0.001902   if has_key(b:AutoPairs, prev_char)
                                let close = b:AutoPairs[prev_char]
                                if match(line,'^\s*'.close, col('.')-1) != -1
                                  " Delete (|___)
                                  let space = matchstr(line, '^\s*', col('.')-1)
                                  return "\<BS>". repeat("\<DEL>", len(space)+1)
                                elseif match(line, '^\s*$', col('.')-1) != -1
                                  " Delete (|__\n___)
                                  let nline = getline(line('.')+1)
                                  if nline =~ '^\s*'.close
                                    if &filetype == 'vim' && prev_char == '"'
                                      " Keep next line's comment
                                      return "\<BS>"
                                    end
                            
                                    let space = matchstr(nline, '^\s*')
                                    return "\<BS>\<DEL>". repeat("\<DEL>", len(space)+1)
                                  end
                                end
                              end
                            
  475              0.001615   return "\<BS>"

FUNCTION  <SNR>125_PrtClearCache()
Called 9 times
Total time:   1.468373
 Self time:   0.001036

count  total (s)   self (s)
    9              0.000225 	if s:itemtype == 0
    9   0.000344   0.000147 		cal ctrlp#clr()
    9              0.000031 	elsei s:itemtype > 2
                            		cal ctrlp#clr(s:statypes[s:itemtype][1])
                            	en
    9              0.000024 	if s:itemtype == 2
                            		let g:ctrlp_lines = ctrlp#mrufiles#refresh()
                            	el
    9   1.286079   0.000083 		cal ctrlp#setlines()
    9              0.000017 	en
    9              0.000034 	let s:force = 1
    9   0.181310   0.000166 	cal s:BuildPrompt(1)
    9              0.000033 	unl s:force

FUNCTION  nerdtree#version()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001     return '5.0.0'

FUNCTION  <SNR>7_LoadIndent()
Called 106 times
Total time:  14.868497
 Self time:   9.018612

count  total (s)   self (s)
  106              0.000719     if exists("b:undo_indent")
   30              0.000519       exe b:undo_indent
   30              0.000180       unlet! b:undo_indent b:did_indent
   30              0.000038     endif
  106              0.000651     let s = expand("<amatch>")
  106              0.000294     if s != ""
  106              0.000339       if exists("b:did_indent")
   41              0.000161 	unlet b:did_indent
   41              0.000045       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
  212              0.001500       for name in split(s, '\.')
  106  14.859586   9.009701 	exe 'runtime! indent/' . name . '.vim'
  106              0.000483       endfor
  106              0.000192     endif

FUNCTION  <SNR>65_buffer_type()
Called 121 times
Total time:   0.049898
 Self time:   0.020148

count  total (s)   self (s)
  121   0.001439   0.000826   if self.getvar('fugitive_type') != ''
                                let type = self.getvar('fugitive_type')
                              elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
                                let type = 'directory'
                              elseif self.spec() == ''
                                let type = 'null'
                              else
  121              0.000294     let type = 'file'
  121              0.000148   endif
  121              0.000182   if a:0
  121              0.001445     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  130()
Called 50 times
Total time:   0.893439
 Self time:   0.001274

count  total (s)   self (s)
   50              0.000161     let opts = a:0 ? a:1 : {}
   50   0.286120   0.000296     call self.toggleOpen(opts)
   50   0.529205   0.000356     call self.getNerdtree().render()
   50   0.077882   0.000391     call self.putCursorHere(0, 0)

FUNCTION  131()
Called 475 times
Total time:   0.005547
 Self time:   0.005547

count  total (s)   self (s)
  475              0.001745     call add(self.children, a:treenode)
  475              0.001231     let a:treenode.parent = self
                            
  475              0.000637     if a:inOrder
                                    call self.sortChildren()
                                endif

FUNCTION  132()
Called 8 times
Total time:   0.005198
 Self time:   0.000118

count  total (s)   self (s)
                            
                                " Close all directories in this directory node's cascade. This is
                                " necessary to ensure consistency when cascades are rendered.
   16   0.005132   0.000052     for l:dirNode in self.getCascade()
    8              0.000022         let l:dirNode.isOpen = 0
    8              0.000007     endfor

FUNCTION  134()
Called 475 times
Total time:   0.037555
 Self time:   0.007465

count  total (s)   self (s)
  475   0.028421   0.003878     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
  475   0.008018   0.002471     call self.addChild(newTreeNode, a:inOrder)
  475              0.000691     return newTreeNode

FUNCTION  135()
Called 1206 times
Total time:   0.172532
 Self time:   0.043420

count  total (s)   self (s)
 1206              0.002079     let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
 1206              0.001587     let l:label = ''
 1206   0.097835   0.004322     let l:cascade = self.getCascade()
 2412              0.003280     for l:dirNode in l:cascade
 1206   0.028895   0.005518         let l:label .= l:dirNode.path.displayString()
 1206              0.000941     endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
 1206              0.002277     if l:cascade[-1].isOpen
   99              0.000223         let l:symbol = g:NERDTreeDirArrowCollapsible
   99              0.000067     else
 1107              0.002138         let l:symbol = g:NERDTreeDirArrowExpandable
 1107              0.000723     endif
                            
 1206   0.017749   0.005527     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
 1206              0.003849     let l:result = l:symbol . ' ' . l:flags . l:label
 1206              0.001424     return l:result

FUNCTION  137()
Called 1243 times
Total time:   0.118293
 Self time:   0.006150

count  total (s)   self (s)
 1243   0.115982   0.003838     if !self.isCascadable()
 1243              0.001664         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  138()
Called 59 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
   59              0.000136     return len(self.children)

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 60970 times
Total time:   5.846458
 Self time:   0.898371

count  total (s)   self (s)
60970   0.793806   0.387545   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
60970   5.002065   0.460239   return airline#extensions#tabline#formatters#{s:formatter}#format(a:nr, buffers)

FUNCTION  ctrlp#utils#readfile()
Called 18 times
Total time:   0.740918
 Self time:   0.740918

count  total (s)   self (s)
   18              0.278265 	if filereadable(a:file)
   18              0.461960 		let data = readfile(a:file)
   18              0.000318 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
   18              0.000060 		retu data
                            	en
                            	retu []

FUNCTION  <SNR>118_BufAbbreviations()
Called 137 times
Total time:   1.381092
 Self time:   0.042506

count  total (s)   self (s)
                              " Some of these were cherry picked from the TextMate snippets
  137              0.000866   if !exists('g:rails_no_abbreviations')
  137   0.003853   0.000678     let buffer = rails#buffer()
                                " Limit to the right filetypes.  But error on the liberal side
  137   0.010362   0.001194     if buffer.type_name('controller','view','helper','test-controller','test-helper','test-integration')
   65   0.014005   0.000806       Rabbrev pa[ params
   65   0.011611   0.000719       Rabbrev rq[ request
   65   0.011742   0.000761       Rabbrev rs[ response
   65   0.011433   0.000652       Rabbrev se[ session
   65   0.011426   0.000614       Rabbrev hd[ headers
   65   0.010905   0.000618       Rabbrev coo[ cookies
   65   0.010888   0.000701       Rabbrev fl[ flash
   65   0.010205   0.000604       Rabbrev rr( render
                                  " ))))))
   65              0.000041     endif
  137   0.005396   0.000708     if buffer.type_name('controller')
   11   0.001653   0.000119       Rabbrev re(  redirect_to
   11   0.001752   0.000098       Rabbrev rst( respond_to
                                  " ))
   11              0.000007     endif
  137   0.009098   0.001088     if buffer.type_name() ==# 'model' || buffer.type_name('model-record')
                                  Rabbrev bt(    belongs_to
                                  Rabbrev ho(    has_one
                                  Rabbrev hm(    has_many
                                  Rabbrev habtm( has_and_belongs_to_many
                                  Rabbrev co(    composed_of
                                  Rabbrev va(    validates_associated
                                  Rabbrev vb(    validates_acceptance_of
                                  Rabbrev vc(    validates_confirmation_of
                                  Rabbrev ve(    validates_exclusion_of
                                  Rabbrev vf(    validates_format_of
                                  Rabbrev vi(    validates_inclusion_of
                                  Rabbrev vl(    validates_length_of
                                  Rabbrev vn(    validates_numericality_of
                                  Rabbrev vp(    validates_presence_of
                                  Rabbrev vu(    validates_uniqueness_of
                                  " )))))))))))))))
                                endif
  137   0.005406   0.000722     if buffer.type_name('db-migration','db-schema')
                                  Rabbrev mac(  add_column
                                  Rabbrev mrnc( rename_column
                                  Rabbrev mrc(  remove_column
                                  Rabbrev mct(  create_table
                                  Rabbrev mcht( change_table
                                  Rabbrev mrnt( rename_table
                                  Rabbrev mdt(  drop_table
                                  " )))))))
                                endif
  137   0.025163   0.001416     Rabbrev logd( logger.debug
  137   0.022267   0.001327     Rabbrev logi( logger.info
  137   0.021989   0.001292     Rabbrev logw( logger.warn
  137   0.022200   0.001278     Rabbrev loge( logger.error
  137   0.021546   0.001340     Rabbrev logf( logger.fatal
  137   0.024258   0.001285     Rabbrev AR::  ActiveRecord
  137   0.024072   0.001535     Rabbrev AV::  ActionView
  137   0.024510   0.001622     Rabbrev AC::  ActionController
  137   0.023751   0.001336     Rabbrev AD::  ActionDispatch
  137   0.024599   0.001349     Rabbrev AS::  ActiveSupport
  137   0.024225   0.001373     Rabbrev AM::  ActionMailer
  137   0.024066   0.001332     Rabbrev AO::  ActiveModel
  137   0.024383   0.001351     Rabbrev AJ::  ActiveJob
                                " )))))
  137              0.000696     for pairs in items(get(g:, 'rails_abbreviations', {}))
                                  call call(function(s:sid.'Abbrev'), [0, pairs[0]] + s:split(pairs[1]))
                                endfor
  137   0.931541   0.001797     for hash in reverse(rails#buffer().projected('abbreviations'))
                                  for pairs in items(hash)
                                    call call(function(s:sid.'Abbrev'), [0, pairs[0]] + s:split(pairs[1]))
                                  endfor
                                endfor
  137              0.000095   endif

FUNCTION  340()
Called 503 times
Total time:   0.188312
 Self time:   0.125695

count  total (s)   self (s)
  503   0.012772   0.005405     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
 3018              0.006400     for type in self._enabled_types
 2515              0.031239         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
 2515              0.015325         if has_key(g:{class}, 'reset')
 1509   0.071149   0.015899             call self._notifier[type].reset(a:loclist)
 1509              0.001588         endif
                            
                                    " also reset stamps
 2515              0.011095         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
 1006              0.008178             let b:syntastic_private_{type}_stamp = []
 1006              0.001323         endif
 2515              0.002506     endfor

FUNCTION  342()
Called 503 times
Total time:   0.008597
 Self time:   0.008597

count  total (s)   self (s)
  503              0.003410     if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
                                endif
                            
  503              0.001191     return s:SyntasticRegistryInstance

FUNCTION  344()
Called 503 times
Total time:   0.192352
 Self time:   0.073164

count  total (s)   self (s)
  503   0.023053   0.003553     let ftlist = self.resolveFiletypes(a:ftalias)
                            
  503              0.004555     let names = !empty(a:hints_list) ? a:hints_list : exists('b:syntastic_checkers') ? b:syntastic_checkers : []
                            
  503              0.001079     let cnames = []
  503              0.001307     if !empty(names)
                                    for name in names
                                        if name !~# '/'
                                            for ft in ftlist
                                                call add(cnames, ft . '/' . name)
                                            endfor
                                        else
                                            call add(cnames, name)
                                        endif
                                    endfor
                                else
 1006              0.001988         for ft in ftlist
  503   0.021169   0.003121             call self._sanityCheck(ft)
  503              0.005084             let defs = exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, [])
  503              0.009042             call extend(cnames, map(copy(defs), 'stridx(v:val, "/") < 0 ? ft . "/" . v:val : v:val' ))
  503              0.000781         endfor
  503              0.000465     endif
  503   0.028381   0.003758     let cnames = syntastic#util#unique(cnames)
                            
 1006   0.031479   0.009598     for ft in syntastic#util#unique(map( copy(cnames), 'v:val[: stridx(v:val, "/")-1]' ))
  503   0.008066   0.003974         call self._loadCheckersFor(ft, 0)
  503              0.000544     endfor
                            
  503   0.034435   0.003390     return self._filterCheckersByName(cnames)

FUNCTION  349()
Called 1006 times
Total time:   0.046633
 Self time:   0.023132

count  total (s)   self (s)
 1006   0.045778   0.022278     return map(split( get(g:syntastic_filetype_map, a:ftalias, a:ftalias), '\m\.' ), 's:_normalise_filetype(v:val)')

FUNCTION  syntastic#util#redraw()
Called 132 times
Total time:   3.497263
 Self time:   3.497263

count  total (s)   self (s)
  132              0.000311     if a:full
                                    redraw!
                                else
  132              3.495993         redraw
  132              0.000357     endif

FUNCTION  gitgutter#diff#parse_diff()
Called 1444 times
Total time:   0.353976
 Self time:   0.115764

count  total (s)   self (s)
 1444              0.004622   let hunks = []
 5669              0.021449   for line in split(a:diff, '\n')
 4225   0.275829   0.037618     let hunk_info = gitgutter#diff#parse_hunk(line)
 4225              0.010815     if len(hunk_info) == 4
 2779              0.008397       call add(hunks, hunk_info)
 2779              0.002803     endif
 4225              0.005384   endfor
 1444              0.001957   return hunks

FUNCTION  <SNR>111_section_is_empty()
Called 58085 times
Total time:   0.618731
 Self time:   0.618731

count  total (s)   self (s)
58085              0.112757   let start=1
                            
                              " do not check for inactive windows or the tabline
58085              0.107540   if a:self._context.active == 0
 8371              0.008941     return 0
                              elseif get(a:self._context, 'tabline', 0)
37143              0.038296     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
12571              0.033044   if get(g:, 'airline_skip_empty_sections', 0) == 0
12571              0.011744     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>65_repo()
Called 346 times
Total time:   0.010316
 Self time:   0.010316

count  total (s)   self (s)
  346              0.002498   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
  346              0.000691   if dir !=# ''
  346              0.001060     if has_key(s:repos, dir)
  346              0.001186       let repo = get(s:repos, dir)
  346              0.000329     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
  346              0.002438     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>65_repo_dir()
Called 451 times
Total time:   0.003197
 Self time:   0.003197

count  total (s)   self (s)
  451              0.002878   return join([self.git_dir]+a:000,'/')

FUNCTION  <SNR>125_matchlens()
Called 57757 times
Total time:   3.724184
 Self time:   2.497004

count  total (s)   self (s)
57757              0.360352 	if empty(a:pat) || index(['^', '$'], a:pat) >= 0 | retu {} | en
51907              0.110819 	let st   = a:0 ? a:1 : 0
51907              0.115187 	let lens = a:0 >= 2 ? a:2 : {}
51907              0.101439 	let nr   = a:0 >= 3 ? a:3 : 0
51907              0.128541 	if nr > 20 | retu {} | en
51907              0.429157 	if match(a:str, a:pat, st) >= 0
27449              0.496008 		let [mst, mnd] = [matchstr(a:str, a:pat, st), matchend(a:str, a:pat, st)]
27449              0.177709 		let lens = extend(lens, { nr : [strlen(mst), mst] })
27449              0.205348 		let lens = s:matchlens(a:str, a:pat, mnd, lens, nr + 1)
27449              0.023897 	en
51907              0.058630 	retu lens

FUNCTION  <SNR>61_BufEnterHook()
Called 458 times
Total time:   0.694325
 Self time:   0.111312

count  total (s)   self (s)
  458   0.178966   0.004393     let buf = syntastic#util#fname2buf(a:fname)
  458   0.075010   0.067810     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
  458              0.002092     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
  437              0.013041         let idx = index(reverse(copy(s:_check_stack)), buf)
  437              0.000666         if idx >= 0
                                        if !has('vim_starting')
                                            call remove(s:_check_stack, -idx - 1)
                                            call s:UpdateErrors(buf, 1, [])
                                        endif
                                    elseif &buftype ==# ''
  437   0.409024   0.007783             call s:notifiers.refresh(g:SyntasticLoclist.current())
  437              0.000322         endif
  437              0.000503     elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"]')
                                    let owner = str2nr(getbufvar(buf, 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif

FUNCTION  140()
Called 2 times
Total time:   0.000239
 Self time:   0.000024

count  total (s)   self (s)
    2   0.000225   0.000010     let array_to_search = a:visible? self.getVisibleChildren() : self.children
    2              0.000004     if a:indx > len(array_to_search)
                                    throw "NERDTree.InvalidArgumentsError: Index is out of bounds."
                                endif
    2              0.000004     return array_to_search[a:indx]

FUNCTION  141()
Called 1 time
Total time:   0.001399
 Self time:   0.000120

count  total (s)   self (s)
    1   0.000485   0.000025     if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                    return -1
                                endif
                            
                                "do a binary search for the child
    1              0.000003     let a = 0
    1   0.000016   0.000009     let z = self.getChildCount()
    2              0.000007     while a < z
    2              0.000010         let mid = (a+z)/2
    2   0.000841   0.000028         let diff = a:path.compareTo(self.children[mid].path)
                            
    2              0.000004         if diff ==# -1
                                        let z = mid
                                    elseif diff ==# 1
    1              0.000003             let a = mid+1
    1              0.000001         else
    1              0.000002             return mid
                                    endif
    1              0.000001     endwhile
                                return -1

FUNCTION  143()
Called 114 times
Total time:   0.085809
 Self time:   0.055609

count  total (s)   self (s)
                            
                                " Construct a path specification such that "globpath()" will return
                                " relative pathnames, if possible.
  114   0.019476   0.004131     if self.path.str() == getcwd()
   30              0.000149         let l:pathSpec = ','
   30              0.000046     else
   84   0.016542   0.002415         let l:pathSpec = fnamemodify(self.path.str({'format': 'Glob'}), ':.')
                            
                                    " On Windows, the drive letter may be removed by "fnamemodify()".
   84   0.001246   0.000518         if nerdtree#runningWindows() && l:pathSpec[0] == '\'
                                        let l:pathSpec = self.path.drive . l:pathSpec
                                    endif
   84              0.000069     endif
                            
  114              0.000281     let l:globList = []
                            
                                " See ":h version7.txt" and ":h version8.txt" for details on the
                                " development of the "glob()" and "globpath()" functions.
  114              0.000880     if v:version > 704 || (v:version == 704 && has('patch654'))
  114              0.035094         let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1, 0)
  114              0.000519     elseif v:version == 704 && has('patch279')
                                    let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1)
                                elseif v:version > 702 || (v:version == 702 && has('patch051'))
                                    let l:globString = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore)
                                    let l:globList = split(l:globString, "\n")
                                else
                                    let l:globString = globpath(l:pathSpec, a:pattern)
                                    let l:globList = split(l:globString, "\n")
                                endif
                            
                                " If "a:all" is false, filter "." and ".." from the output.
  114              0.000194     if !a:all
   57              0.000140         let l:toRemove = []
                            
  114              0.000310         for l:file in l:globList
  114              0.000522             let l:tail = fnamemodify(l:file, ':t')
                            
                                        " Double the modifier if only a separator was stripped.
  114              0.000244             if l:tail == ''
                                            let l:tail = fnamemodify(l:file, ':t:t')
                                        endif
                            
  114              0.000279             if l:tail == '.' || l:tail == '..'
  114              0.000414                 call add(l:toRemove, l:file)
  114              0.000343                 if len(l:toRemove) == 2
   57              0.000072                     break
                                            endif
   57              0.000043             endif
   57              0.000108         endfor
                            
  171              0.000288         for l:file in l:toRemove
  114              0.000575             call remove(l:globList, index(l:globList, l:file))
  114              0.000136         endfor
   57              0.000047     endif
                            
  114              0.000213     return l:globList

FUNCTION  145()
Called 42 times
Total time:   0.022171
 Self time:   0.000208

count  total (s)   self (s)
   42   0.022152   0.000189     return len(self.getVisibleChildren())

FUNCTION  146()
Called 1619 times
Total time:   0.452224
 Self time:   0.061269

count  total (s)   self (s)
 1619              0.002961     let toReturn = []
 6111              0.006955     for i in self.children
 4492   0.414763   0.023809         if i.path.ignore(self.getNerdtree()) ==# 0
 4492              0.009708             call add(toReturn, i)
 4492              0.002907         endif
 4492              0.002736     endfor
 1619              0.001612     return toReturn

FUNCTION  148()
Called 1409 times
Total time:   0.274938
 Self time:   0.014136

count  total (s)   self (s)
 1409              0.002616     if g:NERDTreeCascadeSingleChildDir == 0
                                    return 0
                                endif
                            
 1409   0.265773   0.004972     let c = self.getVisibleChildren()
 1409              0.003246     return len(c) == 1 && c[0].path.isDirectory

FUNCTION  <SNR>118_extend_projection()
Called 37696 times
Total time:   3.153841
 Self time:   3.056767

count  total (s)   self (s)
37696              0.106921   let dest = copy(a:dest)
108128              0.182026   for key in keys(a:src)
70432              0.202697     if !has_key(dest, key) && key ==# 'template'
15872   0.196030   0.098956       let dest[key] = [s:split(a:src[key])]
15872              0.021807     elseif key ==# 'template'
                                  let dest[key] = [s:split(a:src[key])] + dest[key]
                                elseif !has_key(dest, key) || key ==# 'affinity'
54560              0.152876       let dest[key] = a:src[key]
54560              0.164687     elseif type(a:src[key]) == type({}) && type(dest[key]) == type({})
                                  let dest[key] = extend(copy(dest[key]), a:src[key])
                                else
                                  let dest[key] = s:uniq(s:getlist(a:src, key) + s:getlist(dest, key))
                                endif
70432              0.049938   endfor
37696              0.043129   return dest

FUNCTION  emmet#unescapeDollarExpr()
Called 27 times
Total time:   0.000162
 Self time:   0.000162

count  total (s)   self (s)
   27              0.000143   return substitute(a:expand, '\\\$', '$', 'g')

FUNCTION  gitgutter#diff#process_hunks()
Called 1444 times
Total time:   1.799686
 Self time:   0.059250

count  total (s)   self (s)
 1444              0.005467   let modified_lines = []
 4223              0.007195   for hunk in a:hunks
 2779   1.774133   0.033697     call extend(modified_lines, gitgutter#diff#process_hunk(hunk))
 2779              0.002996   endfor
 1444              0.001959   return modified_lines

FUNCTION  352()
Called 799 times
Total time:   0.021627
 Self time:   0.021627

count  total (s)   self (s)
  799              0.003813     let sep_idx = stridx(a:cname, '/')
  799              0.001615     if sep_idx > 0
  799              0.003344         let ft = a:cname[: sep_idx-1]
  799              0.003275         let name = a:cname[sep_idx+1 :]
  799              0.000922     else
                                    let ft = &filetype
                                    let name = a:cname
                                endif
  799              0.004168     return get(self._checkerMap[ft], name, {})

FUNCTION  353()
Called 503 times
Total time:   0.031044
 Self time:   0.009417

count  total (s)   self (s)
  503   0.030708   0.009080     return filter( map(copy(a:cnames), 'self._findChecker(v:val)'), '!empty(v:val)' )

FUNCTION  354()
Called 503 times
Total time:   0.004092
 Self time:   0.004092

count  total (s)   self (s)
  503              0.002846     if !a:force && has_key(self._checkerMap, a:filetype)
  503              0.000664         return
                                endif
                            
                                execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
                                if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  355()
Called 503 times
Total time:   0.018047
 Self time:   0.018047

count  total (s)   self (s)
  503              0.004065     if exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checkers) != type([])
                            
                                    unlet! g:syntastic_{a:filetype}_checkers
                                    call syntastic#log#error('variable g:syntastic_' . a:filetype . '_checkers has to be a list of strings')
                                endif
                            
  503              0.003851     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checker) == type('')
                            
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  357()
Called 1851 times
Total time:   0.038706
 Self time:   0.013440

count  total (s)   self (s)
 1851   0.037705   0.012439     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  358()
Called 911 times
Total time:   1.415542
 Self time:   0.031524

count  total (s)   self (s)
  911   0.012970   0.004758     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
  911   0.015903   0.005406     let old_signs = copy(self._bufSignIds())
  911   0.022115   0.003217     if self.enabled()
  911              0.001613         if !s:setup_done
                                        call self._setup()
                                        let s:setup_done = 1
                                        lockvar s:setup_done
                                    endif
                            
  911   0.225694   0.003882         call self._signErrors(a:loclist)
  911              0.000652     endif
  911   1.128602   0.004001     call self._removeSigns(old_signs)

FUNCTION  gitgutter#sign#add_dummy_sign()
Called 4 times
Total time:   0.004056
 Self time:   0.003963

count  total (s)   self (s)
    4   0.000028   0.000021   let bufnr = gitgutter#utility#bufnr()
    4   0.000050   0.000015   if !gitgutter#utility#getbufvar(bufnr, 'dummy_sign')
    4              0.003885     execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
    4   0.000085   0.000033     call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', 1)
    4              0.000003   endif

FUNCTION  <SNR>125_getparent()
Called 30308 times
Total time:   0.957436
 Self time:   0.957436

count  total (s)   self (s)
30308              0.664055 	let parent = substitute(a:item, '[\/][^\/]\+[\/:]\?$', '', '')
30308              0.151280 	if parent == '' || parent !~ '[\/]'
                            		let parent .= s:lash
                            	en
30308              0.039812 	retu parent

FUNCTION  airline#extensions#tabline#ctrlspace#invalidate()
Called 30 times
Total time:   0.000239
 Self time:   0.000239

count  total (s)   self (s)
   30              0.000115   let s:current_bufnr = -1
   30              0.000085   let s:current_tabnr = -1

FUNCTION  gitgutter#utility#filename()
Called 1590 times
Total time:   0.006227
 Self time:   0.006227

count  total (s)   self (s)
 1590              0.005352   return fnamemodify(s:file, ':t')

FUNCTION  <SNR>99_ws_refresh()
Called 6882 times
Total time:   0.139134
 Self time:   0.139134

count  total (s)   self (s)
 6882              0.062739   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
 4736              0.011405     return
                              endif
 2146              0.008271   unlet! b:airline_whitespace_check
 2146              0.011073   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
 2146              0.013945   let b:airline_ws_changedtick = b:changedtick

FUNCTION  HtmlIndent_CheckUserSettings()
Called 1 time
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
                              "{{{
    1              0.000003   let inctags = ''
    1              0.000004   if exists("b:html_indent_inctags")
                                let inctags = b:html_indent_inctags
                              elseif exists("g:html_indent_inctags")
                                let inctags = g:html_indent_inctags
                              endif
    1              0.000003   let b:hi_tags = {}
    1              0.000002   if len(inctags) > 0
                                call s:AddITags(b:hi_tags, split(inctags, ","))
                              endif
                            
    1              0.000001   let autotags = ''
    1              0.000003   if exists("b:html_indent_autotags")
                                let autotags = b:html_indent_autotags
                              elseif exists("g:html_indent_autotags")
                                let autotags = g:html_indent_autotags
                              endif
    1              0.000002   let b:hi_removed_tags = {}
    1              0.000002   if len(autotags) > 0
                                call s:RemoveITags(b:hi_removed_tags, split(autotags, ","))
                              endif
                            
                              " Syntax names indicating being inside a string of an attribute value.
    1              0.000008   let string_names = []
    1              0.000003   if exists("b:html_indent_string_names")
                                let string_names = b:html_indent_string_names
                              elseif exists("g:html_indent_string_names")
                                let string_names = g:html_indent_string_names
                              endif
    1              0.000002   let b:hi_insideStringNames = ['htmlString']
    1              0.000002   if len(string_names) > 0
                                for s in string_names
                                  call add(b:hi_insideStringNames, s)
                                endfor
                              endif
                            
                              " Syntax names indicating being inside a tag.
    1              0.000002   let tag_names = []
    1              0.000002   if exists("b:html_indent_tag_names")
                                let tag_names = b:html_indent_tag_names
                              elseif exists("g:html_indent_tag_names")
                                let tag_names = g:html_indent_tag_names
                              endif
    1              0.000002   let b:hi_insideTagNames = ['htmlTag', 'htmlScriptTag']
    1              0.000002   if len(tag_names) > 0
                                for s in tag_names
                                  call add(b:hi_insideTagNames, s)
                                endfor
                              endif
                            
    1              0.000004   let indone = {"zero": 0,"auto": "indent(prevnonblank(v:lnum-1))","inc": "b:hi_indent.blocktagind + s:ShiftWidth()"}
                            
    1              0.000001   let script1 = ''
    1              0.000002   if exists("b:html_indent_script1")
                                let script1 = b:html_indent_script1
                              elseif exists("g:html_indent_script1")
                                let script1 = g:html_indent_script1
                              endif
    1              0.000002   if len(script1) > 0
                                let b:hi_js1indent = get(indone, script1, indone.zero)
                              else
    1              0.000002     let b:hi_js1indent = 0
    1              0.000001   endif
                            
    1              0.000001   let style1 = ''
    1              0.000002   if exists("b:html_indent_style1")
                                let style1 = b:html_indent_style1
                              elseif exists("g:html_indent_style1")
                                let style1 = g:html_indent_style1
                              endif
    1              0.000002   if len(style1) > 0
                                let b:hi_css1indent = get(indone, style1, indone.zero)
                              else
    1              0.000002     let b:hi_css1indent = 0
    1              0.000001   endif
                            
    1              0.000002   if !exists('b:html_indent_line_limit')
    1              0.000002     if exists('g:html_indent_line_limit')
                                  let b:html_indent_line_limit = g:html_indent_line_limit
                                else
    1              0.000002       let b:html_indent_line_limit = 200
    1              0.000001     endif
    1              0.000000   endif

FUNCTION  airline#extensions#tabline#new_builder()
Called 1721 times
Total time:   0.172975
 Self time:   0.097444

count  total (s)   self (s)
 1721              0.031022   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
 1721              0.007301   if get(g:, 'airline_powerline_fonts', 0)
 1721              0.012266     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
 1721              0.010972     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
 1721              0.002074   else
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
                              endif
                            
 1721   0.089057   0.013527   return airline#builder#new(builder_context)

FUNCTION  <SNR>91_is_excluded_window()
Called 2400 times
Total time:   0.138117
 Self time:   0.138117

count  total (s)   self (s)
 2400              0.007681   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
 9600              0.014897   for matchw in g:airline_exclude_filenames
 7200              0.054440     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
 7200              0.006024   endfor
                            
 2400              0.004508   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
 2400              0.002254   return 0

FUNCTION  68()
Called 76 times
Total time:   0.000770
 Self time:   0.000770

count  total (s)   self (s)
   76              0.000328     if !exists("s:keyMaps")
                                    let s:keyMaps = []
                                endif
   76              0.000163     return s:keyMaps

FUNCTION  69()
Called 60 times
Total time:   0.005368
 Self time:   0.004864

count  total (s)   self (s)
  804   0.001574   0.001069     for i in s:KeyMap.All()
  798              0.001789          if i.key ==# a:key && i.scope ==# a:scope
   54              0.000068             return i
                                    endif
  744              0.000508     endfor
    6              0.000007     return {}

FUNCTION  <SNR>125_lsCmd()
Called 11 times
Total time:   0.000482
 Self time:   0.000482

count  total (s)   self (s)
   11              0.000078 	let cmd = s:usrcmd
   11              0.000066 	if type(cmd) == 1
   11              0.000033 		retu cmd
                            	elsei type(cmd) == 3 && len(cmd) >= 2 && cmd[:1] != ['', '']
                            		if s:findroot(s:dyncwd, cmd[0], 0, 1) == []
                            			retu len(cmd) == 3 ? cmd[2] : ''
                            		en
                            		let s:vcscmd = s:lash == '\'
                            		retu cmd[1]
                            	elsei type(cmd) == 4 && ( has_key(cmd, 'types') || has_key(cmd, 'fallback') )
                            		let fndroot = []
                            		if has_key(cmd, 'types') && cmd['types'] != {}
                            			let [markrs, cmdtypes] = [[], values(cmd['types'])]
                            			for pair in cmdtypes
                            				cal add(markrs, pair[0])
                            			endfo
                            			let fndroot = s:findroot(s:dyncwd, markrs, 0, 1)
                            		en
                            		if fndroot == []
                            			retu has_key(cmd, 'fallback') ? cmd['fallback'] : ''
                            		en
                            		for pair in cmdtypes
                            			if pair[0] == fndroot[0] | brea | en
                            		endfo
                            		let s:vcscmd = s:lash == '\'
                            		retu pair[1]
                            	en

FUNCTION  <SNR>70_opfunc()
Called 1 time
Total time:   0.003502
 Self time:   0.000642

count  total (s)   self (s)
    1   0.000220   0.000023   let char = s:inputreplacement()
    1              0.000004   if char == ""
                                return s:beep()
                              endif
    1              0.000004   let reg = '"'
    1              0.000007   let sel_save = &selection
    1              0.000014   let &selection = "inclusive"
    1              0.000006   let cb_save  = &clipboard
    1              0.000022   set clipboard-=unnamed clipboard-=unnamedplus
    1              0.000012   let reg_save = getreg(reg)
    1              0.000007   let reg_type = getregtype(reg)
    1              0.000005   let type = a:type
    1              0.000004   if a:type == "char"
                                silent exe 'norm! v`[o`]"'.reg.'y'
                                let type = 'v'
                              elseif a:type == "line"
                                silent exe 'norm! `[V`]"'.reg.'y'
                                let type = 'V'
                              elseif a:type ==# "v" || a:type ==# "V" || a:type ==# "\<C-V>"
    1              0.000007     let &selection = sel_save
    1              0.000005     let ve = &virtualedit
    1              0.000005     if !(a:0 && a:1)
    1              0.000011       set virtualedit=
    1              0.000002     endif
    1              0.000071     silent exe 'norm! gv"'.reg.'y'
    1              0.000010     let &virtualedit = ve
    1              0.000004   elseif a:type =~ '^\d\+$'
                                let type = 'v'
                                silent exe 'norm! ^v'.a:type.'$h"'.reg.'y'
                                if mode() ==# 'v'
                                  norm! v
                                  return s:beep()
                                endif
                              else
                                let &selection = sel_save
                                let &clipboard = cb_save
                                return s:beep()
                              endif
    1              0.000007   let keeper = getreg(reg)
    1              0.000005   if type ==# "v" && a:type !=# "v"
                                let append = matchstr(keeper,'\_s\@<!\s*$')
                                let keeper = substitute(keeper,'\_s\@<!\s*$','','')
                              endif
    1              0.000022   call setreg(reg,keeper,type)
    1   0.000639   0.000027   call s:wrapreg(reg,char,"",a:0 && a:1)
    1              0.000006   if type ==# "v" && a:type !=# "v" && append != ""
                                call setreg(reg,append,"ac")
                              endif
    1              0.000137   silent exe 'norm! gv'.(reg == '"' ? '' : '"' . reg).'p`['
    1              0.000024   if type ==# 'V' || (getreg(reg) =~ '\n' && type ==# 'v')
    1   0.001944   0.000024     call s:reindent()
    1              0.000003   endif
    1              0.000014   call setreg(reg,reg_save,reg_type)
    1              0.000012   let &selection = sel_save
    1              0.000008   let &clipboard = cb_save
    1              0.000012   if a:type =~ '^\d\+$'
                                silent! call repeat#set("\<Plug>Y".(a:0 && a:1 ? "S" : "s")."surround".char.s:input,a:type)
                              else
    1   0.000154   0.000023     silent! call repeat#set("\<Plug>SurroundRepeat".char.s:input)
    1              0.000001   endif

FUNCTION  <SNR>125_dohighlight()
Called 1015 times
Total time:   0.015339
 Self time:   0.008528

count  total (s)   self (s)
 1015   0.014692   0.007882 	retu s:mathi[0] && exists('*clearmatches') && !ctrlp#nosy()

FUNCTION  airline#section#create()
Called 113 times
Total time:   0.023662
 Self time:   0.000821

count  total (s)   self (s)
  113   0.023604   0.000764   return s:create(a:parts, 0)

FUNCTION  <SNR>32_displayHelp()
Called 2 times
Total time:   0.013748
 Self time:   0.000032

count  total (s)   self (s)
    2   0.000017   0.000010     call b:NERDTree.ui.toggleHelp()
    2   0.013387   0.000007     call b:NERDTree.render()
    2   0.000343   0.000013     call b:NERDTree.ui.centerView()

FUNCTION  150()
Called 319 times
Total time:   0.018039
 Self time:   0.018039

count  total (s)   self (s)
  319              0.000790     if a:path.isDirectory != 1
                                    throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
                                endif
                            
  319              0.010581     let newTreeNode = copy(self)
  319              0.001013     let newTreeNode.path = a:path
                            
  319              0.000743     let newTreeNode.isOpen = 0
  319              0.000761     let newTreeNode.children = []
                            
  319              0.000790     let newTreeNode.parent = {}
  319              0.000924     let newTreeNode._nerdtree = a:nerdtree
                            
  319              0.000498     return newTreeNode

FUNCTION  151()
Called 57 times
Total time:   0.521454
 Self time:   0.004061

count  total (s)   self (s)
   57              0.000239     let l:options = a:0 ? a:1 : {}
                            
                                " If special options were specified, process them and return.
   57              0.000306     if has_key(l:options, 'where') && !empty(l:options['where'])
                                    let l:opener = g:NERDTreeOpener.New(self.path, l:options)
                                    call l:opener.open(self)
                                    return 0
                                endif
                            
                                " Open any ancestors of this node that render within the same cascade.
   57              0.000164     let l:parent = self.parent
   57   0.011692   0.000377     while !empty(l:parent) && !l:parent.isRoot()
   29   0.020071   0.000371         if index(l:parent.getCascade(), self) >= 0
                                        let l:parent.isOpen = 1
                                        let l:parent = l:parent.parent
                                    else
   29              0.000031             break
                                    endif
                                endwhile
                            
   57              0.000144     let self.isOpen = 1
                            
   57              0.000166     let l:numChildrenCached = 0
   57              0.000161     if empty(self.children)
   57   0.486940   0.000562         let l:numChildrenCached = self._initChildren(0)
   57              0.000046     endif
                            
   57              0.000092     return l:numChildrenCached

FUNCTION  152()
Called 42 times
Total time:   0.279349
 Self time:   0.001391

count  total (s)   self (s)
   42              0.000119     let opts = a:0 ? a:1 : {}
   42              0.000086     let level = 0
                            
   42              0.000099     let node = self
   44              0.000148     while node.path.isDirectory
   42   0.255774   0.000226         call node.open(opts)
   42              0.000085         let level += 1
   42   0.022337   0.000166         if node.getVisibleChildCount() == 1
    2   0.000251   0.000012             let node = node.getChildByIndex(0, 1)
    2              0.000002         else
   40              0.000033             break
                                    endif
    2              0.000001     endwhile
   42              0.000047     return level

FUNCTION  360()
Called 911 times
Total time:   0.221812
 Self time:   0.213989

count  total (s)   self (s)
  911              0.002277     let loclist = a:loclist
  911   0.006448   0.003666     if !loclist.isEmpty()
                            
   31              0.000085         let buf = bufnr('')
   31              0.000075         if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
   31   0.002104   0.000180         let issues = copy(loclist.errors())
   31   0.001813   0.000201         call extend(issues, loclist.warnings())
   31              0.000301         call filter(issues, 'v:val["bufnr"] == buf')
   31              0.000057         let seen = {}
                            
  230              0.000260         for i in issues
  199              0.000757             if i['lnum'] > 0 && !has_key(seen, i['lnum'])
  169              0.000493                 let seen[i['lnum']] = 1
                            
  169              0.000522                 let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
  169              0.000457                 let sign_subtype = get(i, 'subtype', '')
  169              0.000462                 let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
  169              0.162508                 execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
  169   0.002906   0.001401                 call add(self._bufSignIds(), s:next_sign_id)
  169              0.000459                 let s:next_sign_id += 1
  169              0.000128             endif
  199              0.000128         endfor
   31              0.000021     endif

FUNCTION  361()
Called 911 times
Total time:   1.124600
 Self time:   1.120533

count  total (s)   self (s)
  911              0.003318     if has('signs')
 1072              0.003834         for s in reverse(copy(a:ids))
  161              1.102938             execute 'sign unplace ' . s
  161   0.007750   0.003682             call remove(self._bufSignIds(), index(self._bufSignIds(), s))
  161              0.000219         endfor
  911              0.000602     endif

FUNCTION  362()
Called 1402 times
Total time:   0.016070
 Self time:   0.016070

count  total (s)   self (s)
 1402              0.007404     if !exists('b:syntastic_private_sign_ids')
   33              0.000117         let b:syntastic_private_sign_ids = []
   33              0.000031     endif
 1402              0.002603     return b:syntastic_private_sign_ids

FUNCTION  syntastic#util#rmrf()
Called 1 time
Total time:   0.775543
 Self time:   0.000160

count  total (s)   self (s)
                                " try to make sure we don't delete directories we didn't create
    1              0.000028     if a:what !~? 'vim-syntastic-'
                                    return
                                endif
                            
    1              0.000061     if  getftype(a:what) ==# 'dir'
    1   0.775425   0.000042         call s:_delete(a:what, 'rf')
    1              0.000002     else
                                    silent! call delete(a:what)
                                endif

FUNCTION  367()
Called 5175 times
Total time:   0.027325
 Self time:   0.027325

count  total (s)   self (s)
 5175              0.023979   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  368()
Called 9099 times
Total time:   0.148317
 Self time:   0.101229

count  total (s)   self (s)
 9099              0.041268   let spc = empty(a:contents) ? '' : g:airline_symbols.space
 9099   0.099021   0.051933   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  369()
Called 32157 times
Total time:   0.175337
 Self time:   0.175337

count  total (s)   self (s)
32157              0.155407   call add(self._sections, [a:group, a:contents])

FUNCTION  airline#add_statusline_func()
Called 2 times
Total time:   0.000096
 Self time:   0.000037

count  total (s)   self (s)
    2   0.000094   0.000035   call airline#add_statusline_funcref(function(a:name))

FUNCTION  airline#remove_statusline_func()
Called 2 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000025   let i = index(g:airline_statusline_funcrefs, function(a:name))
    2              0.000006   if i > -1
    2              0.000011     call remove(g:airline_statusline_funcrefs, i)
    2              0.000003   endif

FUNCTION  <SNR>97_update_git_branch()
Called 68 times
Total time:   0.019712
 Self time:   0.003804

count  total (s)   self (s)
   68              0.000177   if !s:has_fugitive
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
   68   0.016326   0.000418   let name = fugitive#head(7)
   68              0.000160   if empty(name)
                                if has_key(s:git_dirs, a:path)
                                  let s:vcs_config['git'].branch = s:git_dirs[a:path]
                                  return
                                endif
                            
                                let dir = fugitive#extract_git_dir(a:path)
                                if empty(dir)
                                  let name = ''
                                else
                                  try
                                    let line = join(readfile(dir . '/HEAD'))
                                    if strpart(line, 0, 16) == 'ref: refs/heads/'
                                      let name = strpart(line, 16)
                                    else
                                      " raw commit hash
                                      let name = strpart(line, 0, 7)
                                    endif
                                  catch
                                    let name = ''
                                  endtry
                                endif
                              endif
                            
   68              0.000270   let s:git_dirs[a:path] = name
   68              0.000251   let s:vcs_config['git'].branch = name

FUNCTION  <SNR>125_nosort()
Called 980 times
Total time:   0.020181
 Self time:   0.020181

count  total (s)   self (s)
  980              0.018666 	retu s:matcher != {} || s:nolim == 1 || ( s:itemtype == 2 && s:mrudef ) || ( s:itemtype =~ '\v^(1|2)$' && s:prompt == ['', '', ''] ) || !s:dosort

FUNCTION  <SNR>125_buftab()
Called 33 times
Total time:   0.003695
 Self time:   0.003695

count  total (s)   self (s)
   64              0.000539 	for tabnr in range(1, tabpagenr('$'))
   33              0.000433 		if tabpagenr() == tabnr && a:md == 't' | con | en
   33              0.000286 		let buflist = tabpagebuflist(tabnr)
   33              0.000220 		if index(buflist, a:bufnr) >= 0
    4              0.000014 			for winnr in range(1, tabpagewinnr(tabnr, '$'))
    6              0.000026 				if buflist[winnr - 1] == a:bufnr | retu [tabnr, winnr] | en
    2              0.000005 			endfo
                            		en
   31              0.000076 	endfo
   31              0.000095 	retu [0, 0]

FUNCTION  <SNR>118_match_type()
Called 1119 times
Total time:   0.018556
 Self time:   0.018556

count  total (s)   self (s)
 1119              0.001671   if a:0
  972              0.015350     return !empty(filter(copy(a:000),'a:type =~# "^".v:val."\\%(-\\|$\\)"'))
                              else
  147              0.000189     return a:type
                              endif

FUNCTION  70()
Called 15 times
Total time:   0.049726
 Self time:   0.007766

count  total (s)   self (s)
  765   0.001966   0.001706     for i in s:KeyMap.All()
  750   0.045855   0.004153         call i.bind()
  750              0.001437     endfor

FUNCTION  71()
Called 750 times
Total time:   0.041701
 Self time:   0.041701

count  total (s)   self (s)
                                " If the key sequence we're trying to map contains any '<>' notation, we
                                " must replace each of the '<' characters with '<lt>' to ensure the string
                                " is not translated into its corresponding keycode during the later part
                                " of the map command below
                                " :he <>
  750              0.003032     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
  750              0.006018     if self.key =~# specialNotationRegex
  120              0.002177         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
  120              0.000203     else
  630              0.002522         let keymapInvokeString = self.key
  630              0.000722     endif
                            
  750              0.003046     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
                            
  750              0.016224     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'

FUNCTION  73()
Called 54 times
Total time:   0.989596
 Self time:   0.067006

count  total (s)   self (s)
   54              0.066328     let Callback = function(self.callback)
   54              0.000093     if a:0
   52   0.909181   0.000339         call Callback(a:1)
   52              0.000032     else
    2   0.013759   0.000011         call Callback()
    2              0.000001     endif

FUNCTION  74()
Called 56 times
Total time:   1.364785
 Self time:   0.005223

count  total (s)   self (s)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
   56   0.001684   0.000961     if !g:NERDTree.ExistsForBuf()
                                    return {}
                                endif
                            
   56   0.364885   0.001110     let node = g:NERDTreeFileNode.GetSelected()
   56              0.000146     if !empty(node)
                            
                                    "try file node
   53              0.000104         if !node.path.isDirectory
    2   0.000442   0.000011             let km = s:KeyMap.FindFor(a:key, "FileNode")
    2              0.000003             if !empty(km)
                                            return km.invoke(node)
                                        endif
    2              0.000001         endif
                            
                                    "try dir node
   53              0.000076         if node.path.isDirectory
   51   0.003777   0.000386             let km = s:KeyMap.FindFor(a:key, "DirNode")
   51              0.000123             if !empty(km)
   50   0.894993   0.000327                 return km.invoke(node)
                                        endif
    1              0.000001         endif
                            
                                    "try generic node
    3   0.000622   0.000019         let km = s:KeyMap.FindFor(a:key, "Node")
    3              0.000005         if !empty(km)
    2   0.081153   0.000013             return km.invoke(node)
                                    endif
                            
    1              0.000000     endif
                            
                                "try bookmark
    4   0.000139   0.000039     let bm = g:NERDTreeBookmark.GetSelected()
    4              0.000008     if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
    4   0.000968   0.000025     let km = s:KeyMap.FindFor(a:key, "all")
    4              0.000008     if !empty(km)
    2   0.013798   0.000008         return km.invoke()
                                endif

FUNCTION  <SNR>63_strip_white_space()
Called 41 times
Total time:   0.001025
 Self time:   0.001025

count  total (s)   self (s)
   41              0.000236   let [l, r] = [a:l, a:r]
   41              0.000454   if stridx(a:line,l) == -1 && stridx(a:line,l[0:-2]) == 0 && a:line[strlen(a:line)-strlen(r[1:]):-1] == r[1:]
                                return [l[0:-2], r[1:]]
                              endif
   41              0.000105   return [l, r]

FUNCTION  79()
Called 490 times
Total time:   0.003806
 Self time:   0.003806

count  total (s)   self (s)
  490              0.001579     if !exists("g:NERDTreeBookmarks")
                                    let g:NERDTreeBookmarks = []
                                endif
  490              0.000659     return g:NERDTreeBookmarks

FUNCTION  <SNR>302_AddITags()
Called 3 times
Total time:   0.000782
 Self time:   0.000782

count  total (s)   self (s)
                              "{{{
  104              0.000087   for itag in a:taglist
  101              0.000292     let a:tags[itag] = 1
  101              0.000291     let a:tags['/' . itag] = -1
  101              0.000072   endfor

FUNCTION  airline#extensions#ctrlp#load_theme()
Called 9 times
Total time:   0.014306
 Self time:   0.000830

count  total (s)   self (s)
    9              0.000036   if exists('a:palette.ctrlp')
                                let theme = a:palette.ctrlp
                              else
    9              0.000087     let s:color_template = has_key(a:palette, s:color_template) ? s:color_template : 'insert'
    9   0.000270   0.000092     let theme = airline#extensions#ctrlp#generate_color_map( a:palette[s:color_template]['airline_c'], a:palette[s:color_template]['airline_b'], a:palette[s:color_template]['airline_a'])
    9              0.000008   endif
   63              0.000114   for key in keys(theme)
   54   0.013622   0.000324     call airline#highlighter#exec(key, theme[key])
   54              0.000066   endfor

FUNCTION  <SNR>61__os_name()
Called 1006 times
Total time:   0.005336
 Self time:   0.005336

count  total (s)   self (s)
 1006              0.004280     return g:_SYNTASTIC_UNAME

FUNCTION  gitgutter#utility#set_buffer()
Called 19245 times
Total time:   0.925091
 Self time:   0.925091

count  total (s)   self (s)
19245              0.099059   let s:bufnr = a:bufnr
19245              0.791934   let s:file = resolve(bufname(a:bufnr))

FUNCTION  162()
Called 57 times
Total time:   0.138558
 Self time:   0.003277

count  total (s)   self (s)
   57              0.000286     let CompareFunc = function("nerdtree#compareNodesBySortKey")
   57   0.138226   0.002945     call sort(self.children, CompareFunc)

FUNCTION  163()
Called 50 times
Total time:   0.285824
 Self time:   0.001278

count  total (s)   self (s)
   50              0.000148     let opts = a:0 ? a:1 : {}
   50              0.000111     if self.isOpen ==# 1
    8   0.005234   0.000036         call self.close()
    8              0.000006     else
   42              0.000109         if g:NERDTreeCascadeOpenSingleChildDir == 0
                                        call self.open(opts)
                                    else
   42   0.279573   0.000224             call self.openAlong(opts)
   42              0.000031         endif
   42              0.000022     endif

FUNCTION  <SNR>118_BufScriptWrappers()
Called 137 times
Total time:   0.017788
 Self time:   0.017788

count  total (s)   self (s)
  137              0.001839   command! -buffer -bang -bar -nargs=? -complete=customlist,s:Complete_script   Rscript       :execute s:deprecate(':Rscript', ':Rails', 'Rails<bang>' . empty(<q-args>) ? 'console' : <q-args>)
  137              0.000821   command! -buffer -bang -bar -nargs=* -complete=customlist,s:Complete_environments Console   :Rails<bang> console <args>
  137              0.001333   command! -buffer -bang -bar -nargs=* -complete=customlist,s:Complete_generate Rgenerate     :execute s:deprecate(':Rgenerate', ':Generate', ':Generate<bang> '.<q-args>)
  137              0.001341   command! -buffer -bang -bar -nargs=* -complete=customlist,s:Complete_generate Generate      :execute rails#app().generator_command(<bang>0,'<mods>','generate',<f-args>)
  137              0.001338   command! -buffer -bar -nargs=*       -complete=customlist,s:Complete_destroy  Rdestroy      :execute s:deprecate(':Rdestroy', ':Destroy', ':Destroy<bang> '.<q-args>)
  137              0.001034   command! -buffer -bar -nargs=*       -complete=customlist,s:Complete_destroy  Destroy       :execute rails#app().generator_command(1,'<mods>','destroy',<f-args>)
  137              0.001295   command! -buffer -bar -nargs=? -bang -complete=customlist,s:Complete_server   Rserver       :execute s:deprecate(':Rserver', ':Server', ':Server<bang> '.<q-args>)
  137              0.001292   command! -buffer -bar -nargs=? -bang -complete=customlist,s:Complete_server   Server        :execute rails#app().server_command(0, <bang>0, <q-args>)
  137              0.001287   command! -buffer -bang -nargs=? -range=0 -complete=customlist,s:Complete_edit Rrunner       :execute s:deprecate(':Rrunner', ':Runner', ':Runner<bang> '.<q-args>)
  137              0.001624   command! -buffer -bang -nargs=? -range=0 -complete=customlist,s:Complete_edit Runner        :execute rails#buffer().runner_command(<bang>0, <count>?<line1>:0, <q-args>)
  137              0.001802   command! -buffer       -nargs=1 -range=0 -complete=customlist,s:Complete_ruby Rp            :execute rails#app().output_command(<count>==<line2>?<count>:-1, 'p begin '.<q-args>.' end')
  137              0.001984   command! -buffer       -nargs=1 -range=0 -complete=customlist,s:Complete_ruby Rpp           :execute rails#app().output_command(<count>==<line2>?<count>:-1, 'require %{pp}; pp begin '.<q-args>.' end')

FUNCTION  <SNR>61_CacheErrors()
Called 503 times
Total time: 2044.826324
 Self time:   0.203272

count  total (s)   self (s)
  503   0.012111   0.005817     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
  503   0.285325   0.012487     call s:ClearCache(a:buf)
  503   0.031268   0.004650     let newLoclist = g:SyntasticLoclist.New([])
  503   0.007555   0.003020     call newLoclist.setOwner(a:buf)
                            
  503   0.079259   0.003365     if !s:_skip_file(a:buf)
                                    " debug logging {{{3
  503   0.010784   0.004530         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
  503   0.008456   0.002610         if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
  503   0.010665   0.004893             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
  503   0.009886   0.004478             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
  503              0.000532         endif
  503   0.013496   0.007991         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
  503   0.020086   0.013815         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
  503   0.198778   0.006426         let clist = s:registry.getCheckers(getbufvar(a:buf, '&filetype'), a:checker_names)
                            
  503   0.044975   0.011363         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(syntastic#util#unique(map(copy(clist), 'v:val.getFiletype()'))) > 1
  503              0.002221         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
  503              0.002143         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
  503              0.000994         let names = []
  503              0.001261         let unavailable_checkers = 0
 1269              0.003582         for checker in clist
  796   0.009868   0.005191             let cname = checker.getCName()
  796   0.691584   0.003945             if !checker.isAvailable()
  293   0.004968   0.002213                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
  293              0.000990                 let unavailable_checkers += 1
  293              0.000451                 continue
                                        endif
                            
  503   0.011574   0.004731             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
  503 2043.135684   0.006084             let loclist = checker.getLocList()
                            
  503   0.005886   0.003724             if !loclist.isEmpty()
   30              0.000053                 if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
   30              0.000109                 call add(names, cname)
   30   0.000846   0.000155                 if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
   30   0.000671   0.000175                 call newLoclist.extend(loclist)
                            
   30              0.000059                 if !aggregate_errors
   30              0.000039                     break
                                            endif
                                        endif
  473              0.000622         endfor
                            
                                    " set names {{{3
  503              0.001137         if !empty(names)
   30   0.001871   0.000679             if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
   30              0.000275                 let type = substitute(names[0], '\m/.*', '', '')
   30              0.000423                 let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
   30   0.000332   0.000212                 call newLoclist.setName( name . ' ('. type . ')' )
   30              0.000035             else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
   30              0.000019         endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
  503              0.001461         if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
                                    endif
                                    " }}}3
                            
  503   0.007801   0.003199         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
  503              0.000823         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
  503              0.000315     endif
                            
  503   0.137119   0.002042     call newLoclist.deploy()

FUNCTION  370()
Called 20753 times
Total time:   0.118197
 Self time:   0.118197

count  total (s)   self (s)
20753              0.106665   call add(self._sections, ['', a:text])

FUNCTION  371()
Called 5175 times
Total time:  26.029294
 Self time:   5.022405

count  total (s)   self (s)
 5175              0.012694   let side = 1
 5175              0.009155   let line = ''
 5175              0.008477   let i = 0
 5175              0.016475   let length = len(self._sections)
 5175              0.008853   let split = 0
 5175              0.009291   let is_empty = 0
 5175              0.009178   let prev_group = ''
                            
63260              0.098300   while i < length
58085              0.170477     let section = self._sections[i]
58085              0.144282     let group = section[0]
58085              0.141704     let contents = section[1]
58085              0.108355     let pgroup = prev_group
58085   1.459217   0.326870     let prev_group = s:get_prev_group(self._sections, i)
58085              0.201603     if group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
  624              0.002023       let group = 'airline_c'. self._context.bufnr
  624              0.002190     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
  624              0.001970       let prev_group = 'airline_c'. self._context.bufnr
  624              0.000500     endif
58085              0.058275     if is_empty
                                  let prev_group = pgroup
                                endif
58085   0.935362   0.316631     let is_empty = s:section_is_empty(self, contents)
                            
58085              0.066623     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
58085              0.080651     if group == ''
20753              0.059916       let line .= contents
20753              0.024200     elseif group == '|'
 5175              0.006665       let side = 0
 5175              0.012089       let line .= contents
 5175              0.006651       let split = 1
 5175              0.003655     else
32157              0.042508       if prev_group == ''
 5175              0.017160         let line .= '%#'.group.'#'
 5175              0.005962       elseif split
 4515              0.004600         if !is_empty
 4515   2.669360   0.046040           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
 4515              0.003843         endif
 4515              0.006250         let split = 0
 4515              0.003219       else
22467              0.024284         if !is_empty
22467  15.226453   0.151722           let line .= s:get_seperator(self, prev_group, group, side)
22467              0.020294         endif
22467              0.013243       endif
32157   1.819307   0.261546       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
32157              0.027647     endif
                            
58085              0.128070     let i = i + 1
58085              0.066741   endwhile
                            
 5175              0.007818   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
 1799              0.064215     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
 1799              0.001894   endif
 5175              0.006415   return line

FUNCTION  emmet#reExpandDollarExpr()
Called 27 times
Total time:   0.007285
 Self time:   0.000735

count  total (s)   self (s)
   27              0.000056   let expand = a:expand
   27   0.006743   0.000193   let dollar_exprs = emmet#getDollarExprs(expand)
   27              0.000055   if len(dollar_exprs) > 0
                                if a:times < 9
                                  for n in range(len(dollar_exprs))
                                    let pair = get(dollar_exprs, n)
                                    let pat = get(pair, 'expr')
                                    let sub = get(pair, 'value')
                                    let expand = substitute(expand, pat, sub, '')
                                  endfor
                                  return emmet#reExpandDollarExpr(expand, a:times + 1)
                                endif
                              endif
   27              0.000028   return expand

FUNCTION  80()
Called 15 times
Total time:   0.002960
 Self time:   0.001493

count  total (s)   self (s)
   15              0.000094     try
   15   0.001720   0.000253         call s:Bookmark.BookmarkFor(a:name)
                                    return 1
                                catch /^NERDTree.BookmarkNotFoundError/
   15              0.000070         return 0
                                endtry

FUNCTION  81()
Called 15 times
Total time:   0.001467
 Self time:   0.000917

count  total (s)   self (s)
   15              0.000096     let l:result = {}
   15   0.000821   0.000271     for l:bookmark in s:Bookmark.Bookmarks()
                                    if l:bookmark.name ==# a:name
                                        let l:result = l:bookmark
                                        break
                                    endif
                                endfor
   15              0.000101     if empty(l:result)
   14            2883.399735         throw 'NERDTree.BookmarkNotFoundError: "' . a:name  . '" not found'
                                endif
                                return l:result

FUNCTION  89()
Called 4 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
    4              0.000016     let line = getline(".")
    4              0.000035     let name = substitute(line, '^>\(.\{-}\) .\+$', '\1', '')
    4              0.000010     if name != line
                                    try
                                        return s:Bookmark.BookmarkFor(name)
                                    catch /^NERDTree.BookmarkNotFoundError/
                                        return {}
                                    endtry
                                endif
    4              0.000005     return {}

FUNCTION  <SNR>61_UpdateErrors()
Called 503 times
Total time: 2046.896463
 Self time:   0.090408

count  total (s)   self (s)
  503   0.012527   0.004323     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
  503   0.010740   0.004572     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
  503   0.009430   0.003248     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
  503   0.013110   0.007331     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
  503   0.023679   0.005302     call s:modemap.synch()
                            
  503   0.086911   0.003591     if s:_skip_file(a:buf)
                                    return
                                endif
                            
  503   0.082673   0.005817     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking(a:buf)
  503              0.001057     if run_checks
  503 2044.836351   0.010027         call s:CacheErrors(a:buf, a:checker_names)
  503   0.008750   0.004725         call syntastic#util#setLastTick(a:buf)
  503              0.000861     elseif a:auto_invoked
                                    return
                                endif
                            
  503   0.018265   0.003263     let loclist = g:SyntasticLoclist.current(a:buf)
                            
  503              0.001692     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
  503   0.009292   0.002741     let do_jump = syntastic#util#var('auto_jump') + 0
  503              0.000803     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
  503   0.007960   0.002122     if syntastic#util#var('always_populate_loc_list') || do_jump
                                    call loclist.setloclist(1)
                                    if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
                                endif
                                " }}}3
                            
  503   1.748049   0.004621     call s:notifiers.refresh(loclist)

FUNCTION  <SNR>74_TmuxAwareNavigate()
Called 262 times
Total time:   7.424243
 Self time:   0.026476

count  total (s)   self (s)
  262              0.002873   let nr = winnr()
  262              0.001826   let tmux_last_pane = (a:direction == 'p' && s:tmux_is_last_pane)
  262              0.000555   if !tmux_last_pane
  262   5.492806   0.003214     call s:VimNavigate(a:direction)
  262              0.000308   endif
  262              0.001718   let at_tab_page_edge = (nr == winnr())
                              " Forward the switch panes command to tmux if:
                              " a) we're toggling between the last tmux pane;
                              " b) we tried switching windows in vim but it didn't have effect.
  262   0.006396   0.002656   if s:ShouldForwardNavigationBackToTmux(tmux_last_pane, at_tab_page_edge)
    5              0.000013     if g:tmux_navigator_save_on_switch == 1
                                  try
                                    update " save the active buffer. See :help update
                                  catch /^Vim\%((\a\+)\)\=:E32/ " catches the no file name error
                                  endtry
                                elseif g:tmux_navigator_save_on_switch == 2
                                  try
                                    wall " save all the buffers. See :help wall
                                  catch /^Vim\%((\a\+)\)\=:E141/ " catches the no file name error
                                  endtry
                                endif
    5              0.000075     let args = 'select-pane -t ' . shellescape($TMUX_PANE) . ' -' . tr(a:direction, 'phjkl', 'lLDUR')
    5   1.904482   0.000141     silent call s:TmuxCommand(args)
    5   0.000253   0.000160     if s:NeedsVitalityRedraw()
                                  redraw!
                                endif
    5              0.000036     let s:tmux_is_last_pane = 1
    5              0.000007   else
  257              0.000633     let s:tmux_is_last_pane = 0
  257              0.000206   endif

FUNCTION  syntastic#util#system()
Called 504 times
Total time: 2042.945441
 Self time: 2042.921831

count  total (s)   self (s)
  504              0.001827     let old_shell = &shell
  504              0.002543     let old_lc_messages = $LC_MESSAGES
  504              0.001666     let old_lc_all = $LC_ALL
                            
  504   0.012298   0.003835     let &shell = syntastic#util#var('shell')
  504              0.003769     let $LC_MESSAGES = 'C'
  504              0.001328     let $LC_ALL = ''
                            
  504              0.001420     let crashed = 0
  504              0.001859     let cmd_start = reltime()
  504              0.000757     try
  504            2042.802753         let out = system(a:command)
  504              0.004295     catch
                                    let crashed = 1
                                    call syntastic#log#error('exception running system(' . string(a:command) . '): ' . v:exception)
                                    if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
                                    endif
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '$PATH = ' . string($PATH))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
                                    let out = ''
                                endtry
  504              0.031399     let cmd_time = split(reltimestr(reltime(cmd_start)))[0]
                            
  504              0.004638     let $LC_ALL = old_lc_all
  504              0.001737     let $LC_MESSAGES = old_lc_messages
                            
  504              0.008021     let &shell = old_shell
                            
  504              0.003429     if !crashed && exists('g:_SYNTASTIC_DEBUG_TRACE')
  504   0.025941   0.010794         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'system: command run in ' . cmd_time . 's')
  504              0.000531     endif
                            
  504              0.001664     return out

FUNCTION  emmet#lang#exists()
Called 175 times
Total time:   0.295829
 Self time:   0.295829

count  total (s)   self (s)
  175              0.000753   if len(a:type) == 0
                                return 0
                              elseif has_key(s:exists, a:type)
  174              0.000599     return s:exists[a:type]
                              endif
    1              0.292793   let s:exists[a:type] = len(globpath(&rtp, 'autoload/emmet/lang/'.a:type.'.vim')) > 0
    1              0.000015   return s:exists[a:type]

FUNCTION  airline#util#wrap()
Called 119222 times
Total time:   0.997619
 Self time:   0.997619

count  total (s)   self (s)
119222              0.439418   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
119222              0.187044   return a:text

FUNCTION  <SNR>125_buffunc()
Called 218 times
Total time:   0.004941
 Self time:   0.004941

count  total (s)   self (s)
  218              0.001485 	if a:e && has_key(s:buffunc, 'enter')
                            		cal call(s:buffunc['enter'], [], s:buffunc)
                            	elsei !a:e && has_key(s:buffunc, 'exit')
                            		cal call(s:buffunc['exit'], [], s:buffunc)
                            	en

FUNCTION  gitgutter#debug#log()
Called 13749 times
Total time:   1.007353
 Self time:   1.007353

count  total (s)   self (s)
13749              0.062815   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  <SNR>222_job_started()
Called 2111 times
Total time:   0.057337
 Self time:   0.057337

count  total (s)   self (s)
 2111              0.010513   if a:0  " vim
                                let s:jobs[a:id] = {'output': [], 'buffer': a:1}
                              else    " nvim
 2111              0.019382     let s:jobs[a:id] = 1
 2111              0.003420   endif

FUNCTION  <SNR>104_map_keys()
Called 6596 times
Total time:   0.167876
 Self time:   0.167876

count  total (s)   self (s)
 6596              0.026514   if s:buffer_idx_mode
                                noremap <silent> <Plug>AirlineSelectTab1 :call <SID>select_tab(0)<CR>
                                noremap <silent> <Plug>AirlineSelectTab2 :call <SID>select_tab(1)<CR>
                                noremap <silent> <Plug>AirlineSelectTab3 :call <SID>select_tab(2)<CR>
                                noremap <silent> <Plug>AirlineSelectTab4 :call <SID>select_tab(3)<CR>
                                noremap <silent> <Plug>AirlineSelectTab5 :call <SID>select_tab(4)<CR>
                                noremap <silent> <Plug>AirlineSelectTab6 :call <SID>select_tab(5)<CR>
                                noremap <silent> <Plug>AirlineSelectTab7 :call <SID>select_tab(6)<CR>
                                noremap <silent> <Plug>AirlineSelectTab8 :call <SID>select_tab(7)<CR>
                                noremap <silent> <Plug>AirlineSelectTab9 :call <SID>select_tab(8)<CR>
                                noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
                                noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                              endif

FUNCTION  <SNR>118_Abbrev()
Called 2323 times
Total time:   0.379118
 Self time:   0.193769

count  total (s)   self (s)
 2323              0.007651   if !exists("b:rails_abbreviations")
   34              0.000110     let b:rails_abbreviations = {}
   34              0.000030   endif
 2323              0.004544   if a:0 > 3 || (a:bang && (a:0 != 1))
                                return s:error("Rabbrev: invalid arguments")
                              endif
 2323              0.002418   if a:0 == 0
                                for key in sort(keys(b:rails_abbreviations))
                                  echo key . join(b:rails_abbreviations[key],"\t")
                                endfor
                                return
                              endif
 2323              0.003905   let lhs = a:1
 2323   0.032322   0.011763   let root = s:sub(lhs,'%(::|\(|\[)$','')
 2323              0.003294   if a:bang
                                if has_key(b:rails_abbreviations,root)
                                  call remove(b:rails_abbreviations,root)
                                endif
                                exe "iunabbrev <buffer> ".root
                                return
                              endif
 2323              0.003298   if a:0 > 3 || a:0 < 2
                                return s:error("Rabbrev: invalid arguments")
                              endif
 2323              0.003544   let rhs = a:2
 2323              0.006099   if has_key(b:rails_abbreviations,root)
 1783              0.005710     call remove(b:rails_abbreviations,root)
 1783              0.001310   endif
 2323              0.006327   if lhs =~ '($'
  772              0.003931     let b:rails_abbreviations[root] = ["(", rhs . (a:0 > 2 ? "\t".a:3 : "")]
  772              0.001022     if a:0 > 2
                                  call s:AddParenExpand(root,rhs,a:3)
                                else
  772   0.063589   0.003930       call s:AddParenExpand(root,rhs)
  772              0.000460     endif
  772              0.000540     return
                              endif
 1551              0.001650   if a:0 > 2
                                return s:error("Rabbrev: invalid arguments")
                              endif
 1551              0.004257   if lhs =~ ':$'
 1096   0.080500   0.005856     call s:AddColonExpand(root,rhs)
 1096              0.001294   elseif lhs =~ '\[$'
  455   0.032909   0.002422     call s:AddBracketExpand(root,rhs)
  455              0.000552   elseif lhs =~ '\w$'
                                call s:AddTabExpand(lhs,rhs)
                              else
                                return s:error("Rabbrev: unimplemented")
                              endif
 1551              0.012643   let b:rails_abbreviations[root] = [matchstr(lhs,'\W*$'),rhs]

FUNCTION  <SNR>118_HiDefaults()
Called 88 times
Total time:   0.023339
 Self time:   0.023339

count  total (s)   self (s)
   88              0.001151   hi def link rubyEntity                      rubyMacro
   88              0.001010   hi def link rubyEntities                    rubyMacro
   88              0.000983   hi def link rubyExceptionHandler            rubyMacro
   88              0.000932   hi def link rubyValidation                  rubyMacro
   88              0.000891   hi def link rubyCallback                    rubyMacro
   88              0.000953   hi def link rubyRakeMacro                   rubyMacro
   88              0.000913   hi def link rubyTestMacro                   rubyMacro
   88              0.001357   hi def link rubyMacro                       Macro
   88              0.000944   hi def link rubyRoute                       rubyControl
   88              0.000926   hi def link rubySchema                      rubyControl
   88              0.000925   hi def link rubyResponse                    rubyControl
   88              0.000917   hi def link rubyUrlHelper                   rubyHelper
   88              0.000895   hi def link rubyViewHelper                  rubyHelper
   88              0.000884   hi def link rubyTestHelper                  rubyHelper
   88              0.000911   hi def link rubyUserAssertion               rubyAssertion
   88              0.000915   hi def link rubyAssertion                   rubyException
   88              0.000899   hi def link rubyTestAction                  rubyControl
   88              0.001227   hi def link rubyHelper                      Function
   88              0.001313   hi def link sprocketsPreProc                PreProc
   88              0.001287   hi def link sprocketsInclude                Include
   88              0.000959   hi def link sprocketsIncludedDir            sprocketsIncluded
   88              0.001215   hi def link sprocketsIncluded               String

FUNCTION  388()
Called 2 times
Total time:   0.877402
 Self time:   0.000190

count  total (s)   self (s)
    2              0.000026   if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
                              end
    2              0.000008   if s:cache_enabled == 0
    2   0.877283   0.000071     call s:try_cmd(s:copy[a:reg], a:lines)
    2              0.000007     return 0
                              end
                            
                              let selection = s:selections[a:reg]
                              if selection.owner > 0
                                " The previous provider instance should exit when the new one takes
                                " ownership, but kill it to be sure we don't fill up the job table.
                                call jobstop(selection.owner)
                              end
                              let selection.data = [a:lines, a:regtype]
                              let argv = split(s:copy[a:reg], " ")
                              let selection.detach = s:cache_enabled
                              let jobid = jobstart(argv, selection)
                              if jobid <= 0
                                echohl WarningMsg
                                echo "clipboard: error when invoking provider"
                                echohl None
                                return 0
                              endif
                              call jobsend(jobid, a:lines)
                              call jobclose(jobid, 'stdin')
                              let selection.owner = jobid

FUNCTION  emmet#lang#css#findTokens()
Called 3 times
Total time:   0.000172
 Self time:   0.000172

count  total (s)   self (s)
    3              0.000086   let tmp = substitute(substitute(a:str, '^.*[;{]\s*', '', ''), '}\s*$', '', '')
    3              0.000020   if tmp =~ '/' && tmp =~ '^[a-zA-Z0-9/_.]\+$'
                                " maybe path or something
                                return ''
                              endif
    3              0.000038   return substitute(substitute(a:str, '^.*[;{]\s*', '', ''), '}\s*$', '', '')

FUNCTION  ctrlp#recordhist()
Called 109 times
Total time:   1.606690
 Self time:   0.006520

count  total (s)   self (s)
  109              0.000853 	let str = join(s:prompt, '')
  109              0.000719 	if empty(str) || !s:maxhst | retu | en
   96              0.000256 	let hst = s:hstry
   96              0.000819 	if len(hst) > 1 && hst[1] == str | retu | en
   96              0.000537 	cal extend(hst, [str], 1)
   96              0.000686 	if len(hst) > s:maxhst | cal remove(hst, s:maxhst, -1) | en
   96   1.602514   0.002344 	cal ctrlp#utils#writecache(hst, s:gethistloc()[0], s:gethistloc()[1])

FUNCTION  <SNR>35_on_window_changed()
Called 782 times
Total time:   8.387907
 Self time:   0.053489

count  total (s)   self (s)
  782              0.004904   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
  782              0.012459   let l:key = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &ft]
  782              0.011206   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
  229              0.000389     return
                              endif
  553              0.004380   let g:airline_last_window_changed = l:key
  553   0.008726   0.004980   call s:init()
  553   8.335126   0.004454   call airline#update_statusline()

FUNCTION  <SNR>125_maxf()
Called 44 times
Total time:   0.000191
 Self time:   0.000191

count  total (s)   self (s)
   44              0.000149 	retu s:maxfiles && a:len > s:maxfiles

FUNCTION  <SNR>125_Reset()
Called 109 times
Total time:   0.685887
 Self time:   0.006893

count  total (s)   self (s)
  109              0.001130 	let opts = has_key(a:args, 'opts') ? [a:args['opts']] : []
  109   0.114854   0.001245 	cal call('s:opts', opts)
  109   0.004033   0.000811 	cal s:autocmds()
  109   0.561329   0.000721 	cal ctrlp#utils#opts()
  109   0.003822   0.002268 	cal s:execextvar('opts')

FUNCTION  xolox#misc#cursorhold#autocmd()
Called 9786 times
Total time:   2.408539
 Self time:   1.881797

count  total (s)   self (s)
                              " The 'top level event handler' that's called by Vim whenever the
                              " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
                              " event handlers registered using `xolox#misc#cursorhold#register()` and
                              " calls each event handler at the appropriate interval, keeping track of
                              " the time when each event handler was last run.
19572              0.141465   for handler in g:xolox#misc#cursorhold#handlers
 9786              0.091534     let function = handler['function']
 9786              0.094585     let last_run = get(handler, 'last_run', 0)
 9786              0.083093     let interval = get(handler, 'interval', 4)
 9786   0.573938   0.262977     call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
                                " Rate limit in case &updatetime is set (very) low.
 9786              0.124703     let time_until_next_run = (last_run + interval) - localtime()
 9786              0.040196     if time_until_next_run > 0
 9533   0.347204   0.159157       call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
 9533              0.014955     else
  253   0.009086   0.004177       call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
  253   0.089842   0.067017       call call(function, get(handler, 'arguments', []))
  253              0.002122       let handler['last_run'] = localtime()
  253              0.000420     endif
 9786              0.018487   endfor

FUNCTION  emmet#util#searchRegion()
Called 1 time
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
    1              0.000019   let b = searchpairpos(a:start, '', a:end, 'bcnW')
    1              0.000003   if b == [0, 0]
                                return [searchpairpos(a:start, '', a:end, 'bnW'), searchpairpos(a:start, '\%#', a:end, 'nW')]
                              else
    1              0.000059     return [b, searchpairpos(a:start, '', a:end. '', 'nW')]
                              endif

FUNCTION  syntastic#log#debugShowVariables()
Called 1006 times
Total time:   0.014458
 Self time:   0.009930

count  total (s)   self (s)
 1006   0.011240   0.006712     if !s:_isDebugEnabled(a:level)
 1006              0.001391         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  airline#extensions#tabline#get()
Called 6596 times
Total time:  16.836212
 Self time:   0.411684

count  total (s)   self (s)
 6596              0.065967   let curtabcnt = tabpagenr('$')
 6596              0.028666   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                              endif
                            
 6596              0.041833   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
 6596              0.012719   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif s:show_buffers && curtabcnt == 1 || !s:show_tabs
 6596  16.502952   0.078425     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  ctrlp#utils#fnesc()
Called 614 times
Total time:   0.038545
 Self time:   0.038545

count  total (s)   self (s)
  614              0.002577 	if exists('*fnameescape')
  614              0.002343 		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = fnameescape(a:path)
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
  614              0.006334 			let path = fnameescape(a:path)
  614              0.000773 		en
  614              0.000621 	el
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = escape(a:path, " \t\n%#*?|<\"")
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = escape(a:path, " \t\n*?[{`$\\%#'\"|!<")
                            		en
                            	en
  614              0.002856 	retu a:0 ? escape(path, a:1) : path

FUNCTION  <SNR>107_exec_separator()
Called 241980 times
Total time: 126.359111
 Self time:   9.456522

count  total (s)   self (s)
241980              0.462460   if pumvisible()
                                return
                              endif
241980  33.989882   1.277276   let l:from = airline#themes#get_highlight(a:from.a:suffix)
241980  33.379152   1.317290   let l:to = airline#themes#get_highlight(a:to.a:suffix)
241980              0.831288   let group = a:from.'_to_'.a:to.a:suffix
241980              0.310120   if a:inverse
149934              0.770318     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
149934              0.134528   else
92046              0.461108     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
92046              0.075210   endif
241980              0.899576   let a:dict[group] = colors
241980  53.537408   1.409288   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>41_addtomrufs()
Called 1422 times
Total time:   1.587156
 Self time:   0.586581

count  total (s)   self (s)
 1422              0.097010 	let fn = fnamemodify(a:fname, ':p')
 1422              0.014705 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
 1422              0.419941 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
 1322              0.013444 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
 1322              0.002330 	if idx
  406              0.008729 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
  406              0.001233 		cal insert(s:mrufs, fn)
  406              0.001405 		if {s:soup} && idx < 0
   17   1.002473   0.001898 			cal s:savetofile(s:mergelists())
   17              0.000033 		en
  406              0.000275 	en

FUNCTION  <SNR>111_get_prev_group()
Called 58085 times
Total time:   1.132346
 Self time:   1.132346

count  total (s)   self (s)
58085              0.147244   let x = a:i - 1
92879              0.137195   while x >= 0
85206              0.274717     let group = a:sections[x][0]
85206              0.183845     if group != '' && group != '|'
50412              0.065957       return group
                                endif
34794              0.064179     let x = x - 1
34794              0.032086   endwhile
 7673              0.007997   return ''

FUNCTION  180()
Called 15 times
Total time:   0.052126
 Self time:   0.002400

count  total (s)   self (s)
                                "make <cr> do the same as the activate node mapping
   15              0.000491     nnoremap <silent> <buffer> <cr> :call nerdtree#ui_glue#invokeKeyMap(g:NERDTreeMapActivateNode)<cr>
                            
   15   0.049948   0.000222     call g:NERDTreeKeyMap.BindAll()
                            
   15              0.000192     command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
   15              0.000240     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark('<args>')
   15              0.000149     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark call nerdtree#ui_glue#openBookmark('<args>')
   15              0.000135     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('<args>')
   15              0.000161     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>', b:NERDTree)
   15              0.000143     command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
   15              0.000178     command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
   15              0.000154     command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()

FUNCTION  181()
Called 15 times
Total time:   0.097404
 Self time:   0.000754

count  total (s)   self (s)
   15   0.097391   0.000740     silent doautocmd User NERDTreeInit

FUNCTION  182()
Called 15 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
   15              0.000036     return 'NERD_tree_'

FUNCTION  183()
Called 15 times
Total time:  12.620794
 Self time:   0.000748

count  total (s)   self (s)
   15   0.001172   0.000479     let creator = s:Creator.New()
   15  12.619549   0.000195     call creator.createTabTree(a:name)

FUNCTION  184()
Called 15 times
Total time:  12.619354
 Self time:   0.002350

count  total (s)   self (s)
   15   0.014935   0.000201     let path = self._pathForString(a:name)
                            
                                "abort if exception was thrown (bookmark/dir doesn't exist)
   15              0.000048     if empty(path)
                                    return
                                endif
                            
   15              0.000031     if path == {}
                                    return
                                endif
                            
                                "if instructed to, then change the vim CWD to the dir the NERDTree is
                                "inited in
   15              0.000045     if g:NERDTreeChDirMode != 0
                                    call path.changeToDir()
                                endif
                            
   15   0.003074   0.000185     if g:NERDTree.ExistsForTab()
   15   0.002758   0.000122         if g:NERDTree.IsOpen()
   15   0.795226   0.000210             call g:NERDTree.Close()
   15              0.000024         endif
                            
   15   0.023920   0.000188         call self._removeTreeBufForTab()
   15              0.000017     endif
                            
   15  11.299654   0.000164     call self._createTreeWin()
   15   0.271235   0.000353     call self._createNERDTree(path, "tab")
   15   0.103746   0.000070     call b:NERDTree.render()
   15   0.006682   0.000138     call b:NERDTree.root.putCursorHere(0, 0)
                            
   15   0.097493   0.000089     call self._broadcastInitEvent()

FUNCTION  187()
Called 15 times
Total time:   0.270882
 Self time:   0.000568

count  total (s)   self (s)
   15   0.004689   0.000281     let b:NERDTree = g:NERDTree.New(a:path, a:type)
                                "TODO: This is kept for compatability only since many things use
                                "b:NERDTreeRoot instead of the new NERDTree.root
                                "Remove this one day
   15              0.000076     let b:NERDTreeRoot = b:NERDTree.root
                            
   15   0.266040   0.000134     call b:NERDTree.root.open()

FUNCTION  emmet#lang#scss#parseIntoTree()
Called 1 time
Total time:   0.019483
 Self time:   0.000132

count  total (s)   self (s)
    1              0.000005   if a:abbr =~# '>'
                                return emmet#lang#html#parseIntoTree(a:abbr, a:type)
                              else
    1   0.019471   0.000119     return emmet#lang#css#parseIntoTree(a:abbr, a:type)
                              endif

FUNCTION  <SNR>97_update_untracked()
Called 68 times
Total time:   2.130294
 Self time:   0.008799

count  total (s)   self (s)
   68              0.001829   let l:file = expand("%:p")
   68              0.000485   if empty(l:file) || isdirectory(l:file)
                                return
                              endif
                            
   68              0.000180   let l:needs_update = 1
  204              0.000487   for vcs in keys(s:vcs_config)
  136              0.000859     if l:file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let l:needs_update = 0
                                endif
  136              0.000629     if has_key(s:vcs_config[vcs].untracked, l:file)
  132              0.000296       let l:needs_update = 0
  132   0.003294   0.001027       call s:update_untracked_in_buffer_config(l:file, vcs)
  132              0.000103     endif
  136              0.000111   endfor
                            
   68              0.000118   if !l:needs_update
   66              0.000068     return
                              endif
                            
    6              0.000028   for vcs in keys(s:vcs_config)
    4              0.000026     let l:config = s:vcs_config[vcs]
    4              0.000010     if s:has_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
                                  call s:get_vcs_untracked_async(l:config, l:file)
                                else
    4   2.119199   0.000176       let output = airline#util#system(l:config.cmd . shellescape(l:file))
    4              0.000190       if output =~? ('^' . l:config.untracked_mark)
                                    let l:config.untracked[l:file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                                  else
    4              0.000045         let l:config.untracked[l:file] = ''
    4              0.000010       endif
    4   0.000321   0.000115       call s:update_untracked_in_buffer_config(l:file, vcs)
    4              0.000005     endif
    4              0.000013   endfor

FUNCTION  <SNR>32_jumpToSibling()
Called 2 times
Total time:   0.015087
 Self time:   0.000072

count  total (s)   self (s)
    2   0.001718   0.000027     let sibling = a:currentNode.findSibling(a:forward)
                            
    2              0.000005     if !empty(sibling)
    1   0.013075   0.000009         call sibling.putCursorHere(1, 0)
    1   0.000280   0.000022         call b:NERDTree.ui.centerView()
    1              0.000001     endif

FUNCTION  airline#util#getwinvar()
Called 16892 times
Total time:   0.078587
 Self time:   0.078587

count  total (s)   self (s)
16892              0.069247     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#extensions#tabline#buffers#invalidate()
Called 48 times
Total time:   0.000325
 Self time:   0.000325

count  total (s)   self (s)
   48              0.000280   let s:current_bufnr = -1

FUNCTION  gitgutter#hunk#hunks()
Called 1444 times
Total time:   0.047549
 Self time:   0.025989

count  total (s)   self (s)
 1444   0.045092   0.023532   return gitgutter#utility#getbufvar(gitgutter#utility#bufnr(), 'hunks', [])

FUNCTION  <SNR>6_FThtml()
Called 1 time
Total time:   4.718439
 Self time:   0.000093

count  total (s)   self (s)
    1              0.000013   let n = 1
    1              0.000014   while n < 10 && n < line("$")
                                if getline(n) =~ '\<DTD\s\+XHTML\s'
                                  setf xhtml
                                  return
                                endif
                                if getline(n) =~ '{%\s*\(extends\|block\|load\)\>\|{#\s\+'
                                  setf htmldjango
                                  return
                                endif
                                let n = n + 1
                              endwhile
    1   4.718365   0.000019   setf html

FUNCTION  airline#highlighter#add_separator()
Called 20771 times
Total time:  11.736377
 Self time:   0.334506

count  total (s)   self (s)
20771              0.150923   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
20771  11.572437   0.170566   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  syntastic#util#getbufvar()
Called 1579 times
Total time:   0.012249
 Self time:   0.012249

count  total (s)   self (s)
 1579              0.011002     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  <SNR>104_get_visible_buffers()
Called 1721 times
Total time:   2.513458
 Self time:   0.503013

count  total (s)   self (s)
 1721   0.209247   0.013430   let buffers = airline#extensions#tabline#buflist#list()
 1721              0.007183   let cur = bufnr('%')
                            
 1721              0.004098   let total_width = 0
 1721              0.003415   let max_width = 0
                            
20726              0.028946   for nr in buffers
19005   1.956198   0.141570     let width = len(airline#extensions#tabline#get_buffer_name(nr)) + 4
19005              0.047220     let total_width += width
19005              0.073062     let max_width = max([max_width, width])
19005              0.020860   endfor
                            
                              " only show current and surrounding buffers if there are too many buffers
 1721              0.006722   let position  = index(buffers, cur)
 1721              0.004328   let vimwidth = &columns
 1721              0.004694   if total_width > vimwidth && position > -1
 1448              0.004224     let buf_count = len(buffers)
                            
                                " determine how many buffers to show based on the longest buffer width,
                                " use one on the right side and put the rest on the left
 1448              0.003920     let buf_max   = vimwidth / max_width
 1448              0.002746     let buf_right = 1
 1448              0.007189     let buf_left  = max([0, buf_max - buf_right])
                            
 1448              0.006456     let start = max([0, position - buf_left])
 1448              0.006994     let end   = min([buf_count, position + buf_right])
                            
                                " fill up available space on the right
 1448              0.002808     if position < buf_left
  362              0.001205       let end += (buf_left - position)
  362              0.000354     endif
                            
                                " fill up available space on the left
 1448              0.004359     if end > buf_count - 1 - buf_right
  484              0.002614       let start -= max([0, buf_right - (buf_count - 1 - position)])
  484              0.000470     endif
                            
 1448              0.011552     let buffers = eval('buffers[' . start . ':' . end . ']')
                            
 1448              0.002481     if start > 0
  777              0.002988       call insert(buffers, -1, 0)
  777              0.000696     endif
                            
 1448              0.003159     if end < buf_count - 1
  964              0.003592       call add(buffers, -1)
  964              0.000881     endif
 1448              0.000988   endif
                            
 1721              0.012584   let s:current_visible_buffers = buffers
 1721              0.002840   return buffers

FUNCTION  190()
Called 15 times
Total time:  11.299490
 Self time:   1.000436

count  total (s)   self (s)
                                "create the nerd tree window
   15              0.000121     let splitLocation = g:NERDTreeWinPos ==# "left" ? "topleft " : "botright "
   15              0.000051     let splitSize = g:NERDTreeWinSize
                            
   15              0.000063     if !exists('t:NERDTreeBufName')
   15   0.000660   0.000110         let t:NERDTreeBufName = self._nextBufferName()
   15   0.562114   0.002950         silent! exec splitLocation . 'vertical ' . splitSize . ' new'
   15   7.623369   0.996680         silent! exec "edit " . t:NERDTreeBufName
   15              0.000017     else
                                    silent! exec splitLocation . 'vertical ' . splitSize . ' split'
                                    silent! exec "buffer " . t:NERDTreeBufName
                                endif
                            
   15              0.000095     setlocal winfixwidth
   15   3.112760   0.000109     call self._setCommonBufOptions()

FUNCTION  191()
Called 15 times
Total time:   0.007865
 Self time:   0.007865

count  total (s)   self (s)
   15              0.000091     redir => bufs
   15              0.007076     silent ls!
   15              0.000163     redir END
                            
   15              0.000477     return bufs =~ a:nr . '..h'

FUNCTION  192()
Called 15 times
Total time:   0.000693
 Self time:   0.000693

count  total (s)   self (s)
   15              0.000580     let newCreator = copy(self)
   15              0.000076     return newCreator

FUNCTION  193()
Called 15 times
Total time:   0.000550
 Self time:   0.000249

count  total (s)   self (s)
   15   0.000493   0.000192     let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
   15              0.000030     return name

FUNCTION  194()
Called 15 times
Total time:   0.000255
 Self time:   0.000255

count  total (s)   self (s)
   15              0.000089     if !exists("s:Creator._NextBufNum")
                                    let s:Creator._NextBufNum = 1
                                else
   15              0.000043         let s:Creator._NextBufNum += 1
   15              0.000014     endif
                            
   15              0.000026     return s:Creator._NextBufNum

FUNCTION  195()
Called 15 times
Total time:   0.014734
 Self time:   0.002880

count  total (s)   self (s)
   15              0.000083     let path = {}
   15   0.003317   0.000358     if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
                                    let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
                                else
   15              0.000894         let dir = a:str ==# '' ? getcwd() : a:str
                            
                                    "hack to get an absolute path if a relative path is given
   15              0.000134         if dir =~# '^\.'
                                        let dir = getcwd() . g:NERDTreePath.Slash() . dir
                                    endif
   15   0.001059   0.000358         let dir = g:NERDTreePath.Resolve(dir)
                            
   15              0.000033         try
   15   0.008336   0.000143             let path = g:NERDTreePath.New(dir)
   15              0.000034         catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo("No bookmark or directory found for: " . a:str)
                                        return {}
                                    endtry
   15              0.000015     endif
   15              0.000032     if !path.isDirectory
                                    let path = path.getParent()
                                endif
                            
   15              0.000024     return path

FUNCTION  197()
Called 15 times
Total time:   3.112652
 Self time:   0.179647

count  total (s)   self (s)
                                "throwaway buffer options
   15              0.177236     setlocal noswapfile
   15              0.000263     setlocal buftype=nofile
   15              0.000102     setlocal bufhidden=hide
   15              0.000165     setlocal nowrap
   15              0.000140     setlocal foldcolumn=0
   15              0.000113     setlocal foldmethod=manual
   15              0.000082     setlocal nofoldenable
   15   0.002050   0.000132     setlocal nobuflisted
   15              0.000100     setlocal nospell
   15              0.000082     if g:NERDTreeShowLineNumbers
                                    setlocal nu
                                else
   15              0.000107         setlocal nonu
   15              0.000068         if v:version >= 703
   15              0.000087             setlocal nornu
   15              0.000026         endif
   15              0.000018     endif
                            
   15              0.000076     iabc <buffer>
                            
   15              0.000051     if g:NERDTreeHighlightCursorline
   15              0.000078         setlocal cursorline
   15              0.000021     endif
                            
   15   0.000410   0.000153     call self._setupStatusline()
   15   0.052222   0.000096     call self._bindMappings()
   15   2.878842   0.000137     setlocal filetype=nerdtree

FUNCTION  198()
Called 15 times
Total time:   0.000256
 Self time:   0.000256

count  total (s)   self (s)
   15              0.000067     if g:NERDTreeStatusline != -1
   15              0.000143         let &l:statusline = g:NERDTreeStatusline
   15              0.000023     endif

FUNCTION  syntastic#util#isRunningWindows()
Called 527 times
Total time:   0.006230
 Self time:   0.006230

count  total (s)   self (s)
  527              0.005382     return has('win16') || has('win32') || has('win64')

FUNCTION  emmet#util#closePopup()
Called 19 times
Total time:   0.000195
 Self time:   0.000195

count  total (s)   self (s)
   19              0.000156   return pumvisible() ? "\<c-e>" : ''

FUNCTION  airline#themes#patch()
Called 9 times
Total time:   0.002990
 Self time:   0.002990

count  total (s)   self (s)
  117              0.000237   for mode in keys(a:palette)
  108              0.000437     if !has_key(a:palette[mode], 'airline_warning')
   36              0.000183       let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
   36              0.000033     endif
  108              0.000387     if !has_key(a:palette[mode], 'airline_error')
   99              0.000511       let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
   99              0.000090     endif
  108              0.000115   endfor
                            
    9              0.000040   let a:palette.accents = get(a:palette, 'accents', {})
    9              0.000032   let a:palette.accents.none = [ '', '', '', '', '' ]
    9              0.000031   let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
    9              0.000031   let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
    9              0.000028   if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
                              endif
    9              0.000024   if !has_key(a:palette.accents, 'green')
    9              0.000032     let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
    9              0.000008   endif
    9              0.000023   if !has_key(a:palette.accents, 'blue')
    9              0.000029     let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
    9              0.000008   endif
    9              0.000023   if !has_key(a:palette.accents, 'yellow')
    9              0.000031     let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
    9              0.000008   endif
    9              0.000022   if !has_key(a:palette.accents, 'orange')
    9              0.000029     let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
    9              0.000008   endif
    9              0.000023   if !has_key(a:palette.accents, 'purple')
    9              0.000031     let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
    9              0.000008   endif

FUNCTION  <SNR>125_compfnlen()
Called 15154 times
Total time:   0.280808
 Self time:   0.280808

count  total (s)   self (s)
                            	" By filename length
15154              0.117986 	let len1 = strlen(split(a:1, s:lash)[-1])
15154              0.101460 	let len2 = strlen(split(a:2, s:lash)[-1])
15154              0.041208 	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1

FUNCTION  rails#buffer_setup()
Called 137 times
Total time:  22.202410
 Self time:   7.336332

count  total (s)   self (s)
  137              0.000583   if !exists('b:rails_root')
                                return ''
                              endif
  137   0.004752   0.001089   let self = rails#buffer()
  137   0.002647   0.000789   let ft = self.getvar('&filetype')
  137   0.102937   0.001270   let b:rails_cached_file_type = self.calculate_file_type()
                            
  137   3.585094   0.002188   call s:set_path_options()
                            
  137   0.011571   0.001795   let rp = s:gsub(self.app().path(),'[ ,]','\\&')
  137              0.000697   if stridx(&tags,rp.'/tags') == -1
   43              0.000326     let &l:tags = rp . '/tags,' . rp . '/tmp/tags,' . &tags
   43              0.000042   endif
                            
  137   0.025881   0.001326   call s:BufMappings()
  137   0.164799   0.001045   call s:BufCommands()
  137   2.228800   0.001107   call s:BufProjectionCommands()
  137   1.382738   0.001646   call s:BufAbbreviations()
                            
  137              0.000630   if ft =~# '^ruby\>'
   10   0.009881   0.000106     call self.setvar('&define',self.define_pattern())
                                " This really belongs in after/ftplugin/ruby.vim but we'll be nice
   10   0.000137   0.000065     if exists('g:loaded_surround') && self.getvar('surround_101') == ''
    1   0.000011   0.000004       call self.setvar('surround_5',   "\r\nend")
    1   0.000010   0.000003       call self.setvar('surround_69',  "\1expr: \1\rend")
    1   0.000010   0.000003       call self.setvar('surround_101', "\r\nend")
    1              0.000001     endif
   10              0.000156     if exists(':UltiSnipsAddFiletypes') == 2
                                  UltiSnipsAddFiletypes rails
                                elseif exists(':SnipMateLoadScope') == 2
                                  SnipMateLoadScope rails
                                endif
   10              0.000017   elseif self.name() =~# '\.yml\%(\.example\)\=$'
                                call self.setvar('&define',self.define_pattern())
                              elseif ft =~# '^eruby\>'
                                call self.setvar('&define',self.define_pattern())
                                if exists("g:loaded_ragtag")
                                  call self.setvar('ragtag_stylesheet_link_tag', "<%= stylesheet_link_tag '\r' %>")
                                  call self.setvar('ragtag_javascript_include_tag', "<%= javascript_include_tag '\r' %>")
                                  call self.setvar('ragtag_doctype_index', 10)
                                endif
                              elseif ft =~# '^haml\>'
   43   0.045777   0.000475     call self.setvar('&define',self.define_pattern())
   43              0.000143     if exists("g:loaded_ragtag")
                                  call self.setvar('ragtag_stylesheet_link_tag', "= stylesheet_link_tag '\r'")
                                  call self.setvar('ragtag_javascript_include_tag', "= javascript_include_tag '\r'")
                                  call self.setvar('ragtag_doctype_index', 10)
                                endif
   43              0.000056   elseif ft =~# 'html\>'
                                call self.setvar('&define', '\<id=["'']\=')
                              endif
  137              0.000405   if ft =~# '^eruby\>'
                                if exists("g:loaded_surround")
                                  if self.getvar('surround_45') == '' || self.getvar('surround_45') == "<% \r %>" " -
                                    call self.setvar('surround_45', "<% \r %>")
                                  endif
                                  if self.getvar('surround_61') == '' " =
                                    call self.setvar('surround_61', "<%= \r %>")
                                  endif
                                  if self.getvar("surround_35") == '' " #
                                    call self.setvar('surround_35', "<%# \r %>")
                                  endif
                                  if self.getvar('surround_101') == '' || self.getvar('surround_101')== "<% \r %>\n<% end %>" "e
                                    call self.setvar('surround_5',   "<% \r %>\n<% end %>")
                                    call self.setvar('surround_69',  "<% \1expr: \1 %>\r<% end %>")
                                    call self.setvar('surround_101', "<% \r %>\n<% end %>")
                                  endif
                                endif
                              endif
                            
  137  11.349715   5.357164   compiler rails
  137   0.066828   0.004476   let &l:makeprg = self.app().rake_command('static')
  137   0.017943   0.003501   let &l:errorformat .= ',chdir '.escape(self.app().path(), ',')
                            
  137              0.001538   if exists(':Dispatch') == 2 && !exists('g:autoloaded_dispatch')
                                runtime! autoload/dispatch.vim
                              endif
  137              0.000573   if exists('*dispatch#dir_opt')
                                let dir = dispatch#dir_opt(self.app().path())
                              endif
                            
  137   1.158246   0.001153   let dispatch = self.projected('dispatch')
  137              0.000409   if !empty(dispatch) && exists('dir')
                                call self.setvar('dispatch', dir . dispatch[0])
                              elseif self.name() =~# '^public'
                                call self.setvar('dispatch', ':Preview')
                              elseif self.name() =~# '^\%(app\|config\|db\|lib\|log\|README\|Rakefile\|test\|spec\|features\)'
  105              0.000307     if !exists('dir')
  105   0.002095   0.000836       call self.setvar('dispatch', ':Rails')
  105              0.000297     elseif self.app().has_rails5()
                                  call self.setvar('dispatch', dir . self.app().ruby_script_command('bin/rails') . ' `=rails#buffer(' . self['#'] . ').default_task(v:lnum)`')
                                else
                                  call self.setvar('dispatch', dir . '-compiler=rails ' . self.app().rake_command('static') . ' `=rails#buffer(' . self['#'] . ').default_rake_task(v:lnum)`')
                                endif
  105              0.000076   endif
                            
  137              1.923882   if !empty(findfile('macros/rails.vim', escape(&runtimepath, ' ')))
                                runtime! macros/rails.vim
                              endif
  137              0.001553   if exists('#User#Rails')
                                try
                                  let [modelines, &modelines] = [&modelines, 0]
                                  doautocmd User Rails
                                finally
                                  let &modelines = modelines
                                endtry
                              endif

FUNCTION  <SNR>97_update_branch()
Called 68 times
Total time:   0.030583
 Self time:   0.009037

count  total (s)   self (s)
   68              0.004213   let l:path = exists("*fnamemodify") ? fnamemodify(resolve(@%), ":p:h") : expand("%:p:h")
  204              0.000647   for vcs in keys(s:vcs_config)
  136   0.023151   0.001605     call {s:vcs_config[vcs].update_branch}(l:path)
  136              0.000707     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
    2              0.000007       let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
    2              0.000003       unlet! b:airline_head
    2              0.000001     endif
  136              0.000270   endfor

FUNCTION  AutoPairsInit()
Called 48 times
Total time:   0.041497
 Self time:   0.026553

count  total (s)   self (s)
   48              0.000321   let b:autopairs_loaded  = 1
   48              0.000217   if !exists('b:autopairs_enabled')
   48              0.000142     let b:autopairs_enabled = 1
   48              0.000046   end
   48              0.000140   let b:AutoPairsClosedPairs = {}
                            
   48              0.000133   if !exists('b:AutoPairs')
   48              0.000142     let b:AutoPairs = g:AutoPairs
   48              0.000041   end
                            
   48              0.000150   if !exists('b:AutoPairsMoveCharacter')
   48              0.000181     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
   48              0.000041   end
                            
                              " buffer level map pairs keys
  336              0.001050   for [open, close] in items(b:AutoPairs)
  288   0.012144   0.001624     call AutoPairsMap(open)
  288              0.000719     if open != close
  144   0.005168   0.000743       call AutoPairsMap(close)
  144              0.000171     end
  288              0.001219     let b:AutoPairsClosedPairs[close] = open
  288              0.000370   endfor
                            
  432              0.001407   for key in split(b:AutoPairsMoveCharacter, '\s*')
  384              0.002115     let escaped_key = substitute(key, "'", "''", 'g')
  384              0.005562     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
  384              0.000505   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
   48              0.000083   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
   48              0.000531     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
   48              0.000045   end
                            
   48              0.000077   if g:AutoPairsMapCh
   48              0.000496     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
   48              0.000043   endif
                            
   48              0.000077   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
   48              0.000124     let do_abbrev = ""
   48              0.000191     if v:version == 703 && has("patch489") || v:version > 703
   48              0.000104       let do_abbrev = "<C-]>"
   48              0.000042     endif
   48              0.000603     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
   48              0.000042   end
                            
   48              0.000117   if g:AutoPairsShortcutFastWrap != ''
   48              0.000605     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
   48              0.000042   end
                            
   48              0.000104   if g:AutoPairsShortcutBackInsert != ''
   48              0.000585     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
   48              0.000040   end
                            
   48              0.000096   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
   48              0.000552     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
   48              0.000671     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
   48              0.000039   end
                            
   48              0.000094   if g:AutoPairsShortcutJump != ''
   48              0.000636     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
   48              0.000665     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
   48              0.000042   end
                            

FUNCTION  <SNR>74_ShouldForwardNavigationBackToTmux()
Called 262 times
Total time:   0.003740
 Self time:   0.003740

count  total (s)   self (s)
  262              0.001628   if g:tmux_navigator_disable_when_zoomed && s:TmuxVimPaneIsZoomed()
                                return 0
                              endif
  262              0.000748   return a:tmux_last_pane || a:at_tab_page_edge

FUNCTION  <SNR>78_CleanUp()
Called 6 times
Total time:   0.000621
 Self time:   0.000621

count  total (s)   self (s)
    6              0.000133   execute "set" a:options
                              " Open folds, if appropriate.
    6              0.000027   if a:mode != "o"
    6              0.000053     if &foldopen =~ "percent"
    6              0.000102       normal! zv
    6              0.000013     endif
                                " In Operator-pending mode, we want to include the whole match
                                " (for example, d%).
                                " This is only a problem if we end up moving in the forward direction.
    6              0.000048   elseif (a:startline < line(".")) || (a:startline == line(".") && a:startcol < col("."))
                                if a:0
                                  " Check whether the match is a single character.  If not, move to the
                                  " end of the match.
                                  let matchline = getline(".")
                                  let currcol = col(".")
                                  let regexp = s:Wholematch(matchline, a:1, currcol-1)
                                  let endcol = matchend(matchline, regexp)
                                  if endcol > currcol  " This is NOT off by one!
                            	call cursor(0, endcol)
                                  endif
                                endif " a:0
                              endif " a:mode != "o" && etc.
    6              0.000011   return 0

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 3166 times
Total time:   1.236139
 Self time:   0.213323

count  total (s)   self (s)
 3166              0.087442   if getbufvar(a:bufnr, '&modified')
 1585              0.022184     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
 1585              0.001917   else
 1581              0.023018     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
 1581              0.005607   endif
                            
 3166              0.007814   if !empty(colors)
 3166   1.056574   0.033758     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
 3166              0.002520   endif

FUNCTION  emmet#parseIntoTree()
Called 27 times
Total time:   0.237099
 Self time:   0.000664

count  total (s)   self (s)
   27              0.000103   let abbr = a:abbr
   27              0.000071   let type = a:type
   27   0.236851   0.000416   return emmet#lang#{emmet#lang#type(type)}#parseIntoTree(abbr, type)

FUNCTION  <SNR>65_buffer_commit()
Called 121 times
Total time:   0.012769
 Self time:   0.002463

count  total (s)   self (s)
  121   0.012284   0.001978   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')

FUNCTION  <SNR>69_doau_user()
Called 882 times
Total time:   0.257573
 Self time:   0.052479

count  total (s)   self (s)
  882              0.012282   if exists('#User#'.a:arg)
  442              0.000931     try
  442              0.009407       let [modelines, &modelines] = [&modelines, 0]
  442   0.220262   0.015167       exe 'doautocmd User' a:arg
  442              0.000662     finally
  442              0.003005       let &modelines = modelines
  442              0.000673     endtry
  442              0.000373   endif

FUNCTION  airline#extensions#syntastic#get_error()
Called 68 times
Total time:   0.013393
 Self time:   0.000453

count  total (s)   self (s)
   68   0.013343   0.000403   return airline#extensions#syntastic#get('error')

FUNCTION  <SNR>118_endswith()
Called 1562 times
Total time:   0.009872
 Self time:   0.009872

count  total (s)   self (s)
 1562              0.009079   return strpart(a:string, len(a:string) - len(a:suffix), len(a:suffix)) ==# a:suffix

FUNCTION  gitgutter#hunk#increment_lines_modified()
Called 156 times
Total time:   0.008373
 Self time:   0.003669

count  total (s)   self (s)
  156   0.001437   0.001117   let bufnr = gitgutter#utility#bufnr()
  156   0.003409   0.000811   let summary = gitgutter#hunk#summary(bufnr)
  156              0.000430   let summary[1] += a:count
  156   0.002834   0.001047   call gitgutter#utility#setbufvar(bufnr, 'summary', summary)

FUNCTION  gitgutter#diff#process_modified_and_added()
Called 156 times
Total time:   0.022823
 Self time:   0.022823

count  total (s)   self (s)
  156              0.000513   let offset = 0
  468              0.000960   while offset < a:from_count
  312              0.000983     let line_number = a:to_line + offset
  312              0.001286     call add(a:modifications, [line_number, 'modified'])
  312              0.000624     let offset += 1
  312              0.000309   endwhile
 1572              0.002183   while offset < a:to_count
 1416              0.003488     let line_number = a:to_line + offset
 1416              0.005720     call add(a:modifications, [line_number, 'added'])
 1416              0.002685     let offset += 1
 1416              0.001118   endwhile

FUNCTION  airline#extensions#syntastic#get()
Called 136 times
Total time:   0.027455
 Self time:   0.004237

count  total (s)   self (s)
  136              0.000660   let _backup = get(g:, 'syntastic_stl_format', '')
  136              0.000447   let is_err = (a:type  is# 'error')
  136              0.000198   if is_err
   68              0.000168     let g:syntastic_stl_format = '%E{%e}'
   68              0.000060   else
   68              0.000163     let g:syntastic_stl_format = '%W{%w}'
   68              0.000056   endif
  136   0.023858   0.000640   let cnt = SyntasticStatuslineFlag()
  136              0.000348   if !empty(_backup)
  136              0.000356     let g:syntastic_stl_format = _backup
  136              0.000119   endif
  136              0.000210   if cnt == 0
  136              0.000156     return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 2778 times
Total time:   0.148010
 Self time:   0.055752

count  total (s)   self (s)
 2778   0.019775   0.013592   let bufnr = gitgutter#utility#bufnr()
 2778   0.066802   0.013213   let summary = gitgutter#hunk#summary(bufnr)
 2778              0.008388   let summary[0] += a:count
 2778   0.047313   0.014827   call gitgutter#utility#setbufvar(bufnr, 'summary', summary)

FUNCTION  <SNR>74_TmuxCommand()
Called 5 times
Total time:   1.904341
 Self time:   1.904145

count  total (s)   self (s)
    5   0.000306   0.000109   let cmd = s:TmuxOrTmateExecutable() . ' -S ' . s:TmuxSocket() . ' ' . a:args
    5              1.904007   return system(cmd)

FUNCTION  fugitive#extract_git_dir()
Called 35 times
Total time:   0.182476
 Self time:   0.011992

count  total (s)   self (s)
   35   0.001402   0.000486   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
   35              0.000184   if isdirectory(a:path)
                                let path = fnamemodify(a:path, ':p:s?[\/]$??')
                              else
   35              0.000554     let path = fnamemodify(a:path, ':p:h:s?[\/]$??')
   35              0.000036   endif
   35   0.001079   0.000580   let root = s:shellslash(resolve(path))
   35              0.000059   let previous = ""
   92              0.000249   while root !=# previous
   92              0.000712     if root =~# '\v^//%([^/]+/?)?$'
                                  " This is for accessing network shares from Cygwin Vim. There won't be
                                  " any git directory called //.git or //serverName/.git so let's avoid
                                  " checking for them since such checks are extremely slow.
                                  break
                                endif
   92              0.000720     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
   92              0.000327     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
                                  return simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??'))
                                endif
   92   0.159552   0.000597     if fugitive#is_git_dir($GIT_DIR)
                                  " Ensure that we've cached the worktree
                                  call s:configured_tree(simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??')))
                                  if has_key(s:dir_for_worktree, root)
                                    return s:dir_for_worktree[root]
                                  endif
                                endif
   92   0.001981   0.000806     let dir = s:sub(root, '[\/]$', '') . '/.git'
   92              0.001020     let type = getftype(dir)
   92   0.007581   0.000440     if type ==# 'dir' && fugitive#is_git_dir(dir)
   35              0.000073       return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
   57              0.000146     let previous = root
   57              0.000235     let root = fnamemodify(root, ':h')
   57              0.000149   endwhile
                              return ''

FUNCTION  <SNR>78_Choose()
Called 6 times
Total time:   0.001808
 Self time:   0.001808

count  total (s)   self (s)
    6              0.000138   let tail = (a:patterns =~ a:comma."$" ? a:patterns : a:patterns . a:comma)
    6              0.000183   let i = matchend(tail, s:notslash . a:comma)
    6              0.000017   if a:0
    6              0.000068     let alttail = (a:1 =~ a:comma."$" ? a:1 : a:1 . a:comma)
    6              0.000119     let j = matchend(alttail, s:notslash . a:comma)
    6              0.000010   endif
    6              0.000045   let current = strpart(tail, 0, i-1)
    6              0.000020   if a:branch == ""
                                let currpat = current
                              else
    6              0.000144     let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
    6              0.000010   endif
   12              0.000201   while a:string !~ a:prefix . currpat . a:suffix
    6              0.000037     let tail = strpart(tail, i)
    6              0.000075     let i = matchend(tail, s:notslash . a:comma)
    6              0.000017     if i == -1
                                  return -1
                                endif
    6              0.000038     let current = strpart(tail, 0, i-1)
    6              0.000018     if a:branch == ""
                                  let currpat = current
                                else
    6              0.000098       let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
    6              0.000009     endif
    6              0.000011     if a:0
    6              0.000028       let alttail = strpart(alttail, j)
    6              0.000062       let j = matchend(alttail, s:notslash . a:comma)
    6              0.000009     endif
    6              0.000028   endwhile
    6              0.000013   if a:0
    6              0.000050     let current = current . a:comma . strpart(alttail, 0, j-1)
    6              0.000008   endif
    6              0.000014   return current

FUNCTION  <SNR>65_buffer_path()
Called 35 times
Total time:   0.030452
 Self time:   0.004687

count  total (s)   self (s)
   35   0.002852   0.000523   let rev = matchstr(self.spec(),'^fugitive://.\{-\}//\zs.*')
   35              0.000081   if rev != ''
                                let rev = s:sub(rev,'\w*','')
                              elseif s:cpath(self.spec()[0 : len(self.repo().dir())]) ==# s:cpath(self.repo().dir() . '/')
                                let rev = '/.git'.self.spec()[strlen(self.repo().dir()) : -1]
                              elseif !self.repo().bare() && s:cpath(self.spec()[0 : len(self.repo().tree())]) ==# s:cpath(self.repo().tree() . '/')
   35   0.005377   0.000512     let rev = self.spec()[strlen(self.repo().tree()) : -1]
   35              0.000035   endif
   35   0.001201   0.000382   return s:sub(s:sub(rev,'.\zs/$',''),'^/',a:0 ? a:1 : '')

FUNCTION  AutoPairsReturn()
Called 84 times
Total time:   0.007039
 Self time:   0.007039

count  total (s)   self (s)
   84              0.000538   if b:autopairs_enabled == 0
                                return ''
                              end
   84              0.000466   let line = getline('.')
   84              0.000632   let pline = getline(line('.')-1)
   84              0.000573   let prev_char = pline[strlen(pline)-1]
   84              0.000196   let cmd = ''
   84              0.000473   let cur_char = line[col('.')-1]
   84              0.000726   if has_key(b:AutoPairs, prev_char) && b:AutoPairs[prev_char] == cur_char
   68              0.000384     if g:AutoPairsCenterLine && winline() * 3 >= winheight(0) * 2
                                  " Recenter before adding new line to avoid replacing line content
   26              0.000082       let cmd = "zz"
   26              0.000031     end
                            
                                " If equalprg has been set, then avoid call =
                                " https://github.com/jiangmiao/auto-pairs/issues/24
   68              0.000216     if &equalprg != ''
                                  return "\<ESC>".cmd."O"
                                endif
                            
                                " conflict with javascript and coffee
                                " javascript   need   indent new line
                                " coffeescript forbid indent new line
   68              0.000292     if &filetype == 'coffeescript' || &filetype == 'coffee'
                                  return "\<ESC>".cmd."k==o"
                                else
   68              0.000332       return "\<ESC>".cmd."=ko"
                                endif
                              end
   16              0.000022   return ''

FUNCTION  airline#highlighter#load_theme()
Called 9 times
Total time:   0.703723
 Self time:   0.001012

count  total (s)   self (s)
    9              0.000086   if pumvisible()
                                return
                              endif
   34              0.000199   for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
   25   0.077077   0.000282     call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
   25              0.000031   endfor
    9   0.329978   0.000120   call airline#highlighter#highlight(['inactive'])
    9              0.000082   if getbufvar( bufnr('%'), '&modified'  )
                                call airline#highlighter#highlight(['normal', 'modified'])
                              else
    9   0.296135   0.000076     call airline#highlighter#highlight(['normal'])
    9              0.000006   endif

FUNCTION  syntastic#util#var()
Called 14263 times
Total time:   0.211119
 Self time:   0.118815

count  total (s)   self (s)
14263   0.203366   0.111061     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  fugitive#head()
Called 68 times
Total time:   0.015908
 Self time:   0.001312

count  total (s)   self (s)
   68              0.000289   if !exists('b:git_dir')
                                return ''
                              endif
                            
   68   0.015351   0.000755   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  <SNR>118_helpermethods()
Called 43 times
Total time:   0.003002
 Self time:   0.003002

count  total (s)   self (s)
   43              0.002531   return ""."action_name asset_path asset_url atom_feed audio_path audio_tag audio_url auto_discovery_link_tag "."button_tag button_to "."cache cache_fragment_name cache_hit cache_if cache_unless capture cdata_section check_box check_box_tag collection_check_boxes collection_radio_buttons collection_select color_field color_field_tag compute_asset_extname compute_asset_host compute_asset_path concat content_tag content_tag_for controller controller_name controller_path convert_to_model cookies csrf_meta_tag csrf_meta_tags current_cycle cycle "."date_field date_field_tag date_select datetime_field datetime_field_tag datetime_local_field datetime_local_field_tag datetime_select debug distance_of_time_in_words distance_of_time_in_words_to_now div_for dom_class dom_id "."email_field email_field_tag escape_javascript escape_once excerpt "."favicon_link_tag field_set_tag fields fields_for file_field file_field_tag flash font_path font_url form_for form_tag form_with "."grouped_collection_select grouped_options_for_select "."headers hidden_field hidden_field_tag highlight "."image_alt image_path image_submit_tag image_tag image_url "."j javascript_cdata_section javascript_include_tag javascript_path javascript_tag javascript_url "."l label label_tag link_to link_to_if link_to_unless link_to_unless_current localize "."mail_to month_field month_field_tag "."number_field number_field_tag number_to_currency number_to_human number_to_human_size number_to_percentage number_to_phone number_with_delimiter number_with_precision "."option_groups_from_collection_for_select options_for_select options_from_collection_for_select "."params password_field password_field_tag path_to_asset path_to_audio path_to_font path_to_image path_to_javascript path_to_stylesheet path_to_video phone_field phone_field_tag pluralize provide public_compute_asset_path "."radio_button radio_button_tag range_field range_field_tag raw render request request_forgery_protection_token reset_cycle response "."safe_concat safe_join sanitize sanitize_css search_field search_field_tag select_date select_datetime select_day select_hour select_minute select_month select_second select_tag select_time select_year session simple_format strip_links strip_tags stylesheet_link_tag stylesheet_path stylesheet_url submit_tag "."t tag telephone_field telephone_field_tag text_area text_area_tag text_field text_field_tag time_ago_in_words time_field time_field_tag time_select time_tag time_zone_options_for_select time_zone_select to_sentence translate truncate "."url_field url_field_tag url_for url_to_asset url_to_audio url_to_font url_to_image url_to_javascript url_to_stylesheet url_to_video utf8_enforcer_tag "."video_path video_tag video_url "."week_field week_field_tag word_wrap"

FUNCTION  <SNR>118_sub()
Called 26733 times
Total time:   0.197112
 Self time:   0.197112

count  total (s)   self (s)
26733              0.183350   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  syntastic#util#compareLexi()
Called 952 times
Total time:   0.023820
 Self time:   0.023820

count  total (s)   self (s)
 1127              0.007396     for idx in range(max([len(a:a), len(a:b)]))
 1127              0.005075         let a_element = str2nr(get(a:a, idx, 0))
 1127              0.004486         let b_element = str2nr(get(a:b, idx, 0))
 1127              0.002138         if a_element != b_element
  952              0.002309             return a_element > b_element ? 1 : -1
                                    endif
  175              0.000147     endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  <SNR>118_app_projections()
Called 992 times
Total time:   5.167329
 Self time:   0.180463

count  total (s)   self (s)
  992   2.692918   0.007848   let dict = s:combine_projections({}, s:default_projections)
 6944              0.014242   for [k, v] in items(s:has_projections)
 5952   0.290979   0.029727     if self.has(k)
 1984   1.672420   0.012541       call s:combine_projections(dict, v)
 1984              0.001484     endif
 5952              0.003769   endfor
  992   0.275439   0.008285   call s:combine_projections(dict, self.smart_projections())
  992   0.029373   0.006994   call s:combine_projections(dict, get(g:, 'rails_projections', ''))
  992              0.003852   for gem in keys(get(g:, 'rails_gem_projections', {}))
                                if self.has_gem(gem)
                                  call s:combine_projections(dict, g:rails_gem_projections[gem])
                                endif
                              endfor
  992   0.065207   0.007470   let gem_path = escape(join(values(self.gems()),','), ' ')
  992              0.002157   if !empty(gem_path)
                                if !has_key(s:projections_for_gems, gem_path)
                                  let gem_projections = {}
                                  for path in ['lib/', 'lib/rails/']
                                    for file in findfile(path.'projections.json', gem_path, -1)
                                      try
                                        call s:combine_projections(gem_projections, rails#json_parse(readfile(self.path(file))))
                                      catch
                                      endtry
                                    endfor
                                  endfor
                                  let s:projections_for_gems[gem_path] = gem_projections
                                endif
                                call s:combine_projections(dict, s:projections_for_gems[gem_path])
                              endif
  992   0.009038   0.003831   if self.cache.needs('projections')
                                call self.cache.set('projections', {})
                            
                                let projections = {}
                                if self.has_path('config/projections.json')
                                  try
                                    let projections = rails#json_parse(readfile(self.path('config/projections.json')))
                                    if type(projections) == type({})
                                      call self.cache.set('projections', projections)
                                    endif
                                  catch /^invalid JSON:/
                                  endtry
                                endif
                              endif
                            
  992   0.036136   0.007947   call s:combine_projections(dict, self.cache.get('projections'))
  992              0.001110   return dict

FUNCTION  <SNR>97_check_in_path()
Called 2 times
Total time:   0.000431
 Self time:   0.000431

count  total (s)   self (s)
    2              0.000011   if !exists('b:airline_file_in_root')
    2              0.000013     let root = get(b:, 'git_dir', get(b:, 'mercurial_dir', ''))
    2              0.000137     let bufferpath = resolve(fnamemodify(expand('%'), ':p'))
                            
    2              0.000017     if !filereadable(root) "not a file
                                  " if .git is a directory, it's the old submodule format
    2              0.000047       if match(root, '\.git$') >= 0
    2              0.000144         let root = expand(fnamemodify(root, ':h'))
    2              0.000004       else
                                    " else it's the newer format, and we need to guesstimate
                                    " 1) check for worktrees
                                    if match(root, 'worktrees') > -1
                                      " worktree can be anywhere, so simply assume true here
                                      return 1
                                    endif
                                    " 2) check for submodules
                                    let pattern = '\.git[\\/]\(modules\)[\\/]'
                                    if match(root, pattern) >= 0
                                      let root = substitute(root, pattern, '', '')
                                    endif
                                  endif
    2              0.000002     endif
                            
    2              0.000012     let b:airline_file_in_root = stridx(bufferpath, root) > -1
    2              0.000002   endif
    2              0.000005   return b:airline_file_in_root

FUNCTION  <SNR>118_readable_projected()
Called 499 times
Total time:   3.694416
 Self time:   0.015661

count  total (s)   self (s)
  499   3.694034   0.015279   return map(self.projected_with_raw(a:key, a:0 ? a:1 : {}), 'v:val[0]')

FUNCTION  ctrlp#hicheck()
Called 872 times
Total time:   0.017985
 Self time:   0.017985

count  total (s)   self (s)
  872              0.014329 	if !hlexists(a:grp)
                            		exe 'hi link' a:grp a:defgrp
                            	en

FUNCTION  ctrlp#utils#mkdir()
Called 125 times
Total time:   0.039956
 Self time:   0.039956

count  total (s)   self (s)
  125              0.038763 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
  125              0.000271 	retu a:dir

FUNCTION  syntastic#postprocess#compressWhitespace()
Called 296 times
Total time:   0.010229
 Self time:   0.010229

count  total (s)   self (s)
  299              0.001430     for e in a:errors
    3              0.000031         let e['text'] = substitute(e['text'], "\001", '', 'g')
    3              0.000049         let e['text'] = substitute(e['text'], '\n', ' ', 'g')
    3              0.000056         let e['text'] = substitute(e['text'], '\m\s\{2,}', ' ', 'g')
    3              0.000030         let e['text'] = substitute(e['text'], '\m^\s\+', '', '')
    3              0.000040         let e['text'] = substitute(e['text'], '\m\s\+$', '', '')
    3              0.000028     endfor
                            
  296              0.000635     return a:errors

FUNCTION  288()
Called 503 times
Total time:   0.051291
 Self time:   0.029818

count  total (s)   self (s)
                                " wildcard quiet_messages
  503   0.014543   0.004774     let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
  503              0.001997     if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
  503              0.001982     let name = self._filetype . '_' . self._name
  503              0.000601     try
  503   0.011766   0.004875         call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
  503              0.000751     catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
  503   0.007832   0.003020     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
  503              0.001098     if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
                                endif

FUNCTION  nerdtree#runningWindows()
Called 8596 times
Total time:   0.075246
 Self time:   0.075246

count  total (s)   self (s)
 8596              0.070898     return has("win16") || has("win32") || has("win64")

FUNCTION  <SNR>125_ifilter()
Called 1 time
Total time:   0.000275
 Self time:   0.000275

count  total (s)   self (s)
    1              0.000022 	let [rlist, estr] = [[], substitute(a:str, 'v:val', 'each', 'g')]
    6              0.000016 	for each in a:list
    5              0.000009 		try
    5              0.000120 			if eval(estr)
    1              0.000006 				cal add(rlist, each)
    1              0.000002 			en
    5              0.000017 		cat | con | endt
    5              0.000017 	endfo
    1              0.000003 	retu rlist

FUNCTION  emmet#lang#css#parseIntoTree()
Called 1 time
Total time:   0.019351
 Self time:   0.000542

count  total (s)   self (s)
    1              0.000005   let abbr = a:abbr
    1              0.000003   let type = a:type
    1              0.000003   let prefix = 0
    1              0.000002   let value = ''
                            
    1   0.000065   0.000010   let indent = emmet#getIndentation(type)
    1   0.000258   0.000010   let aliases = emmet#getResource(type, 'aliases', {})
    1   0.017965   0.000062   let snippets = emmet#getResource(type, 'snippets', {})
    1   0.000119   0.000012   let use_pipe_for_cursor = emmet#getResource(type, 'use_pipe_for_cursor', 1)
                            
    1   0.000031   0.000009   let root = emmet#newNode()
                            
                              " emmet
    1              0.000007   let tokens = split(abbr, '+\ze[^+)!]')
    1   0.000116   0.000022   let block = emmet#util#searchRegion('{', '}')
    1   0.000457   0.000077   if abbr !~# '^@' && emmet#getBaseType(type) ==# 'css' && type !=# 'sass' && block[0] ==# [0,0] && block[1] ==# [0,0]
                                let current = emmet#newNode()
                                let current.snippet = substitute(abbr, '\s\+$', '', '') . " {\n" . indent . "${cursor}\n}"
                                let current.name = ''
                                call add(root.child, deepcopy(current))
                              else
    1              0.000007     for n in range(len(tokens))
                                  let token = tokens[n]
                                  let prop = matchlist(token, '^\(-\{0,1}[a-zA-Z]\+\|[a-zA-Z0-9]\++\{0,1}\|([a-zA-Z0-9]\++\{0,1})\)\(\%([0-9.-]\+\%(p\|e\|em\|vh\|vw\|re\|rem\|%\)\{0,1}-\{0,1}\|-auto\)*\)$')
                                  if len(prop)
                                    let token = substitute(prop[1], '^(\(.*\))', '\1', '')
                                    if token =~# '^-'
                                      let prefix = 1
                                      let token = token[1:]
                                    endif
                                    let value = ''
                                    for v in split(prop[2], '\d\zs-')
                                      if len(value) > 0
                                        let value .= ' '
                                      endif
                                      if token =~# '^[z]'
                                        " TODO
                                        let value .= substitute(v, '[^0-9.]*$', '', '')
                                      elseif v =~# 'p$'
                                        let value .= substitute(v, 'p$', '%', '')
                                      elseif v =~# '%$'
                                        let value .= v
                                      elseif v =~# 'e$'
                                        let value .= substitute(v, 'e$', 'em', '')
                                      elseif v =~# 'em$'
                                        let value .= v
                                      elseif v =~# 'vh$'
                                        let value .= v
                                      elseif v =~# 'vw$'
                                        let value .= v
                                      elseif v =~# 're$'
                                        let value .= substitute(v, 're$', 'rem', '')
                                      elseif v =~# 'rem$'
                                        let value .= v
                                      elseif v =~# '\.'
                                        let value .= v . 'em'
                                      elseif v ==# 'auto'
                                        let value .= v
                                      elseif v ==# '0'
                                        let value .= '0'
                                      else
                                        let value .= v . 'px'
                                      endif
                                    endfor
                                  endif
                            
                                  let tag_name = token
                                  if tag_name =~# '.!$'
                                    let tag_name = tag_name[:-2]
                                    let important = 1
                                  else
                                    let important = 0
                                  endif
                                  " make default node
                                  let current = emmet#newNode()
                                  let current.important = important
                                  let current.name = tag_name
                            
                                  " aliases
                                  if has_key(aliases, tag_name)
                                    let current.name = aliases[tag_name]
                                  endif
                            
                                  " snippets
                                  if !empty(snippets)
                                    let snippet_name = tag_name
                                    if !has_key(snippets, snippet_name)
                                      let pat = '^' . join(split(tag_name, '\zs'), '\%(\|[^:-]\+-\)')
                                      let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                      if len(vv) == 0
                                        let vv = filter(sort(keys(snippets)), 'substitute(v:val, ":", "", "g") == snippet_name')
                                      endif
                                      if len(vv) > 0
                                        let snippet_name = vv[0]
                                      else
                                        let pat = '^' . join(split(tag_name, '\zs'), '\%(\|[^:-]\+-*\)')
                                        let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                        if len(vv) == 0
                                          let pat = '^' . join(split(tag_name, '\zs'), '[^:]\{-}')
                                          let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                          if len(vv) == 0
                                            let pat = '^' . join(split(tag_name, '\zs'), '.\{-}')
                                            let vv = filter(sort(keys(snippets)), 'snippets[v:val] =~ pat')
                                          endif
                                        endif
                                        let minl = -1
                                        for vk in vv
                                          let vvs = snippets[vk]
                                          if minl == -1 || len(vvs) < minl
                                            let snippet_name = vk
                                            let minl = len(vvs)
                                          endif
                                        endfor
                                      endif
                                    endif
                                    if has_key(snippets, snippet_name)
                                      let snippet = snippets[snippet_name]
                                      if use_pipe_for_cursor
                                        let snippet = substitute(snippet, '|', '${cursor}', 'g')
                                      endif
                                      let lines = split(snippet, "\n")
                                      call map(lines, 'substitute(v:val, "\\(    \\|\\t\\)", escape(indent, "\\\\"), "g")')
                                      let current.snippet = join(lines, "\n")
                                      let current.name = ''
                                      let current.snippet = substitute(current.snippet, ';', value . ';', '')
                                      if use_pipe_for_cursor && len(value) > 0
                                        let current.snippet = substitute(current.snippet, '\${cursor}', '', 'g')
                                      endif
                                      if n < len(tokens) - 1
                                        let current.snippet .= "\n"
                                      endif
                                    endif
                                  endif
                            
                                  let current.pos = 0
                                  let lg = matchlist(token, '^\%(linear-gradient\|lg\)(\s*\(\S\+\)\s*,\s*\([^,]\+\)\s*,\s*\([^)]\+\)\s*)$')
                                  if len(lg) == 0
                                    let lg = matchlist(token, '^\%(linear-gradient\|lg\)(\s*\(\S\+\)\s*,\s*\([^,]\+\)\s*)$')
                                    if len(lg)
                                      let [lg[1], lg[2], lg[3]] = ['linear', lg[1], lg[2]]
                                    endif
                                  endif
                                  if len(lg)
                                    let current.name = ''
                                    let current.snippet = printf("background-image:-webkit-gradient(%s, 0 0, 0 100%, from(%s), to(%s));\n", lg[1], lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:-webkit-linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:-moz-linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:-o-linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = printf("background-image:linear-gradient(%s, %s);\n", lg[2], lg[3])
                                    call add(root.child, deepcopy(current))
                                  elseif prefix
                                    let snippet = current.snippet
                                    let current.snippet = '-webkit-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = '-moz-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = '-o-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = '-ms-' . snippet . "\n"
                                    call add(root.child, deepcopy(current))
                                    let current.snippet = snippet
                                    call add(root.child, current)
                                  elseif token =~# '^c#\([0-9a-fA-F]\{3}\|[0-9a-fA-F]\{6}\)\(\.[0-9]\+\)\?'
                                    let cs = split(token, '\.')
                                    let current.name = ''
                                    let [r,g,b] = [0,0,0]
                                    if len(cs[0]) == 5
                                      let rgb = matchlist(cs[0], 'c#\(.\)\(.\)\(.\)')
                                      let r = eval('0x'.rgb[1].rgb[1])
                                      let g = eval('0x'.rgb[2].rgb[2])
                                      let b = eval('0x'.rgb[3].rgb[3])
                                    elseif len(cs[0]) == 8
                                      let rgb = matchlist(cs[0], 'c#\(..\)\(..\)\(..\)')
                                      let r = eval('0x'.rgb[1])
                                      let g = eval('0x'.rgb[2])
                                      let b = eval('0x'.rgb[3])
                                    endif
                                    if len(cs) == 1
                                      let current.snippet = printf('color:rgb(%d, %d, %d);', r, g, b)
                                    else
                                      let current.snippet = printf('color:rgb(%d, %d, %d, %s);', r, g, b, string(str2float('0.'.cs[1])))
                                    endif
                                    call add(root.child, current)
                                  elseif token =~# '^c#'
                                    let current.name = ''
                                    let current.snippet = 'color:\${cursor};'
                                    call add(root.child, current)
                                  else
                                    call add(root.child, current)
                                  endif
                                endfor
    1              0.000001   endif
    1              0.000001   return root

FUNCTION  airline#extensions#tabline#group_of_bufnr()
Called 9506 times
Total time:   0.278261
 Self time:   0.278261

count  total (s)   self (s)
 9506              0.032618   let cur = bufnr('%')
 9506              0.017840   if cur == a:bufnr
 1557              0.006571     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
  578              0.001309       let group = 'airline_tabmod'
  578              0.000578     else
  979              0.001767       let group = 'airline_tabsel'
  979              0.000764     endif
 1557              0.001043   else
 7949              0.031164     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
   52              0.000103       let group = 'airline_tabmod_unsel'
   52              0.000105     elseif index(a:tab_bufs, a:bufnr) > -1
 1324              0.003044       let group = 'airline_tab'
 1324              0.001090     else
 6573              0.012829       let group = 'airline_tabhid'
 6573              0.005297     endif
 7949              0.005001   endif
 9506              0.014074   return group

FUNCTION  <SNR>125_SetWD()
Called 109 times
Total time:   0.024515
 Self time:   0.024515

count  total (s)   self (s)
  109              0.001424 	if has_key(a:args, 'args') && stridx(a:args['args'], '--dir') >= 0 && exists('s:dyncwd')
                            		cal ctrlp#setdir(s:dyncwd) | retu
                            	en
  109              0.000894 	if has_key(a:args, 'dir') && a:args['dir'] != ''
                            		cal ctrlp#setdir(a:args['dir']) | retu
                            	en
  109              0.001006 	let pmode = has_key(a:args, 'mode') ? a:args['mode'] : s:pathmode
  109              0.007520 	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
  109              0.003554 	if s:crfile =~ '^.\+://' | retu | en
  109              0.001561 	if pmode =~ 'c' || ( pmode =~ 'a' && stridx(s:crfpath, s:cwd) < 0 ) || ( !type(pmode) && pmode )
                            		if exists('+acd') | let [s:glb_acd, &acd] = [&acd, 0] | en
                            		cal ctrlp#setdir(s:crfpath)
                            	en
  109              0.000552 	if pmode =~ 'r' || pmode == 2
                            		let markers = ['.git', '.hg', '.svn', '.bzr', '_darcs']
                            		let spath = pmode =~ 'd' ? s:dyncwd : pmode =~ 'w' ? s:cwd : s:crfpath
                            		if type(s:rmarkers) == 3 && !empty(s:rmarkers)
                            			if s:findroot(spath, s:rmarkers, 0, 0) != [] | retu | en
                            			cal filter(markers, 'index(s:rmarkers, v:val) < 0')
                            		en
                            		cal s:findroot(spath, markers, 0, 0)
                            	en

FUNCTION  rails#ruby_syntax()
Called 10 times
Total time:   0.018574
 Self time:   0.010001

count  total (s)   self (s)
   10   0.000264   0.000092   let buffer = rails#buffer()
                            
   10              0.000245   syn keyword rubyAttribute class_attribute
   10              0.000086   syn keyword rubyAttribute attr_internal attr_internal_accessor attr_internal_reader attr_internal_writer
   10              0.000233   syn keyword rubyAttribute cattr_accessor cattr_reader cattr_writer mattr_accessor mattr_reader mattr_writer
   10              0.000080   syn keyword rubyAttribute thread_cattr_accessor thread_cattr_reader thread_cattr_writer thread_mattr_accessor thread_mattr_reader thread_mattr_writer
   10              0.000140   syn keyword rubyMacro alias_attribute concern concerning delegate delegate_missing_to with_options
                            
   10   0.000739   0.000084   if buffer.type_name('channel','controller','helper','job','mailer','model','view')
   10              0.000075     syn keyword rubyHelper logger
   10              0.000008   endif
                            
   10   0.000339   0.000049   if buffer.type_name('mailer')
                                syn keyword rubyResponse mail render
                                syn match   rubyResponse "\<headers\>"
                                syn match   rubyHelper "\<headers\[\@="
                                syn keyword rubyHelper attachments
                                syn keyword rubyMacro default helper helper_attr helper_method layout
                            
                              elseif buffer.type_name('model-observer')
                                syn keyword rubyMacro observe
                            
                              elseif buffer.type_name() ==# 'model' || buffer.type_name('model-record', 'model-concern')
                                syn keyword rubyMacro accepts_nested_attributes_for attr_readonly attribute enum serialize store store_accessor
                                syn keyword rubyMacro default_scope scope
                                syn keyword rubyEntity belongs_to has_one composed_of
                                syn keyword rubyEntities has_many has_and_belongs_to_many
                                syn keyword rubyCallback before_validation after_validation
                                syn keyword rubyCallback before_create before_destroy before_save before_update
                                syn keyword rubyCallback  after_create  after_destroy  after_save  after_update
                                syn keyword rubyCallback around_create around_destroy around_save around_update
                                syn keyword rubyCallback after_commit after_create_commit after_update_commit after_destroy_commit after_rollback
                                syn keyword rubyCallback after_find after_initialize after_touch
                                syn keyword rubyValidation validates validates_acceptance_of validates_associated validates_confirmation_of validates_each validates_exclusion_of validates_format_of validates_inclusion_of validates_length_of validates_numericality_of validates_presence_of validates_absence_of validates_size_of validates_with
                                syn keyword rubyValidation validates_associated validates_uniqueness_of
                                syn keyword rubyMacro validate has_secure_password has_secure_token
                              endif
                            
   10   0.000352   0.000053   if buffer.type_name('job')
                                syn keyword rubyMacro queue_as
                                syn keyword rubyExceptionHandler rescue_from retry_on discard_on
                                syn keyword rubyCallback before_enqueue around_enqueue after_enqueue before_perform around_perform after_perform
                              endif
                            
   10   0.000412   0.000054   if buffer.type_name('helper','view')
                                exe 'syn keyword rubyViewHelper' s:helpermethods()
                                syn match rubyViewHelper '\<select\>\%(\s*{\|\s*do\>\|\s*(\=\s*&\)\@!'
                                syn match rubyViewHelper '\<\%(content_for\w\@!?\=\|current_page?\)'
                                syn match rubyViewHelper '\.\@<!\<\(h\|html_escape\|u\|url_encode\)\>'
                                if buffer.type_name('view-partial')
                                  syn keyword rubyViewHelper local_assigns
                                endif
                              endif
                            
   10   0.000380   0.000052   if buffer.type_name('controller')
   10              0.000104     syn keyword rubyHelper params request response session headers cookies flash render_to_string
   10              0.000229     syn keyword rubyMacro helper helper_attr helper_method filter layout serialize exempt_from_layout filter_parameter_logging hide_action cache_sweeper protect_from_forgery caches_page cache_page caches_action expire_page expire_action
   10              0.000080     syn keyword rubyExceptionHandler rescue_from
   10              0.000117     syn match   rubyMacro '\<respond_to\>\ze[( ] *[:*]'
   10              0.000103     syn match   rubyResponse '\<respond_to\>\ze[( ] *\%([&{]\|do\>\)'
   10              0.000096     syn keyword rubyResponse render head redirect_to redirect_back respond_with
   10              0.000140     syn keyword rubyCallback before_filter append_before_filter prepend_before_filter after_filter append_after_filter prepend_after_filter around_filter append_around_filter prepend_around_filter skip_before_filter skip_after_filter skip_filter before_action append_before_action prepend_before_action after_action append_after_action prepend_after_action around_action append_around_action prepend_around_action skip_before_action skip_after_action skip_action
   10              0.000009   endif
                            
   10   0.000524   0.000116   if buffer.type_name('model-concern', 'controller-concern')
                                syn keyword rubyMacro included class_methods
                              endif
                            
   10   0.000582   0.000091   if buffer.type_name('controller','helper','mailer','view') || buffer.type_name('test-controller', 'test-integration', 'test-system', 'spec-request', 'spec-feature', 'cucumber')
   10              0.000114     syn keyword rubyUrlHelper url_for polymorphic_path polymorphic_url edit_polymorphic_path edit_polymorphic_url new_polymorphic_path new_polymorphic_url
   10              0.000010   endif
                            
   10   0.000455   0.000080   if buffer.type_name('db-migration','db-schema')
                                syn keyword rubySchema create_table change_table drop_table rename_table create_join_table drop_join_table
                                syn keyword rubySchema add_column rename_column change_column change_column_default change_column_null remove_column remove_columns
                                syn keyword rubySchema add_foreign_key remove_foreign_key
                                syn keyword rubySchema add_timestamps remove_timestamps
                                syn keyword rubySchema add_reference remove_reference add_belongs_to remove_belongs_to
                                syn keyword rubySchema add_index remove_index rename_index
                                syn keyword rubySchema enable_extension reversible revert
                                syn keyword rubySchema execute transaction
                              endif
                            
   10   0.000381   0.000063   if buffer.type_name('task')
                                syn match rubyRakeMacro '^\s*\zs\%(task\|file\|namespace\|desc\)\>\%(\s*=\)\@!'
                              endif
                            
   10   0.000364   0.000051   if buffer.type_name('config-routes')
                                syn keyword rubyRoute resource resources collection member new nested shallow
                                syn keyword rubyRoute match get put patch post delete root mount
                                syn keyword rubyRoute scope controller namespace constraints defaults
                                syn keyword rubyRoute concern concerns
                                syn keyword rubyRoute direct resolve
                                syn keyword rubyHelper redirect
                              endif
                            
   10   0.000327   0.000058   if buffer.type_name('test')
                                if !empty(rails#app().user_assertions())
                                  exe "syn keyword rubyUserAssertion ".join(rails#app().user_assertions())
                                endif
                                syn keyword rubyTestMacro test setup teardown
                                syn keyword rubyAssertion refute refute_empty refute_equal refute_in_delta refute_in_epsilon refute_includes refute_instance_of refute_kind_of refute_match refute_nil refute_operator refute_predicate refute_respond_to refute_same
                                syn keyword rubyAssertion assert assert_block assert_equal assert_includes assert_in_delta assert_instance_of assert_kind_of assert_match assert_nil assert_no_match assert_not assert_not_equal assert_not_includes assert_not_nil assert_not_same assert_nothing_raised assert_nothing_thrown assert_operator assert_raise assert_respond_to assert_same assert_send assert_throws
                                syn keyword rubyAssertion flunk
                                syn keyword rubyAssertion assert_difference assert_no_difference
                                syn keyword rubyTestAction travel travel_to travel_back
                              endif
   10   0.000429   0.000053   if buffer.type_name('test-controller', 'test-integration', 'test-system')
                                syn keyword rubyAssertion assert_response assert_redirected_to assert_template assert_recognizes assert_generates assert_routing
                              endif
   10   0.000484   0.000059   if buffer.type_name('test-helper', 'test-controller', 'test-integration', 'test-system')
                                syn keyword rubyAssertion assert_dom_equal assert_dom_not_equal assert_select assert_select_encoded assert_select_email
                                syn keyword rubyTestHelper css_select
                              endif
   10   0.000329   0.000043   if buffer.type_name('test-system')
                                syn keyword rubyAssertion     assert_matches_css     assert_matches_selector     assert_matches_xpath
                                syn keyword rubyAssertion     refute_matches_css     refute_matches_selector     refute_matches_xpath
                                syn keyword rubyAssertion assert_not_matches_css assert_not_matches_selector assert_not_matches_xpath
                                syn keyword rubyAssertion    assert_button    assert_checked_field    assert_content    assert_css    assert_current_path    assert_field    assert_link    assert_select    assert_selector    assert_table    assert_text    assert_title    assert_unchecked_field    assert_xpath
                                syn keyword rubyAssertion assert_no_button assert_no_checked_field assert_no_content assert_no_css assert_no_current_path assert_no_field assert_no_link assert_no_select assert_no_selector assert_no_table assert_no_text assert_no_title assert_no_unchecked_field assert_no_xpath
                                syn keyword rubyAssertion    refute_button    refute_checked_field    refute_content    refute_css    refute_current_path    refute_field    refute_link    refute_select    refute_selector    refute_table    refute_text    refute_title    refute_unchecked_field    refute_xpath
                              endif
                            
   10   0.000294   0.000041   if buffer.type_name('spec')
                                syn match rubyTestHelper '\<subject\>'
                                syn match rubyTestMacro '\<\%(let\|given\)\>!\='
                                syn match rubyTestMacro '\<subject\>!\=\ze\s*\%([({&:]\|do\>\)'
                                syn keyword rubyTestMacro before after around background setup teardown
                                syn keyword rubyTestMacro context describe feature shared_context shared_examples shared_examples_for containedin=rubyKeywordAsMethod
                                syn keyword rubyTestMacro it example specify scenario include_examples include_context it_should_behave_like it_behaves_like
                                syn keyword rubyComment xcontext xdescribe xfeature containedin=rubyKeywordAsMethod
                                syn keyword rubyComment xit xexample xspecify xscenario
                              endif
   10   0.000346   0.000051   if buffer.type_name('spec', 'cucumber')
                                syn keyword rubyAssertion pending skip expect is_expected expect_any_instance_of allow allow_any_instance_of
                                syn keyword rubyTestHelper double instance_double class_double object_double described_class
                              endif
   10   0.000296   0.000042   if buffer.type_name('spec-controller')
                                syn keyword rubyTestMacro render_views
                                syn keyword rubyTestHelper assigns
                              endif
   10   0.000287   0.000040   if buffer.type_name('spec-helper')
                                syn keyword rubyTestAction assign
                                syn keyword rubyTestHelper helper
                              endif
   10   0.000370   0.000040   if buffer.type_name('spec-view')
                                syn keyword rubyTestAction assign render
                                syn keyword rubyTestHelper rendered
                              endif
                            
   10   0.000347   0.000048   if buffer.type_name('test', 'spec')
                                syn keyword rubyTestMacro fixtures use_transactional_tests use_instantiated_fixtures
                                syn keyword rubyTestHelper file_fixture
                              endif
   10   0.000439   0.000059   if buffer.type_name('test-controller', 'test-integration', 'spec-controller', 'spec-request')
                                syn match   rubyTestAction '\.\@<!\<\%(get\|post\|put\|patch\|delete\|head\|process\)\>'
                                syn match   rubyTestAction '\<follow_redirect!'
                                syn keyword rubyTestAction get_via_redirect post_via_redirect
                                syn keyword rubyTestHelper request response flash session cookies
                              endif
   10   0.000406   0.000060   if buffer.type_name('test-system', 'spec-feature', 'cucumber')
                                syn keyword rubyTestHelper body current_host current_path current_scope current_url current_window html response_headers source status_code title windows
                                syn keyword rubyTestHelper page text
                                syn keyword rubyTestHelper all field_labeled find find_all find_button find_by_id find_field find_link first
                                syn keyword rubyTestAction evaluate_script execute_script go_back go_forward open_new_window save_and_open_page save_and_open_screenshot save_page save_screenshot switch_to_frame switch_to_window visit window_opened_by within within_element within_fieldset within_frame within_table within_window
                                syn match   rubyTestAction "\<reset_session!"
                                syn keyword rubyTestAction attach_file check choose click_button click_link click_link_or_button click_on fill_in select uncheck unselect
                              endif
                            

FUNCTION  ctrlp#igncwd()
Called 11 times
Total time:   0.002981
 Self time:   0.000391

count  total (s)   self (s)
   11   0.002966   0.000376 	retu ctrlp#utils#glob(a:cwd, 0) == '' || ( s:igntype >= 0 && s:usrign(a:cwd, getftype(a:cwd)) )

FUNCTION  <SNR>118_buffer_app()
Called 6606 times
Total time:   0.385610
 Self time:   0.076305

count  total (s)   self (s)
 6606   0.087538   0.029848   if self.getvar('rails_root') != ''
 6606   0.294121   0.042507     return rails#app(self.getvar('rails_root'))
                              else
                                throw 'Not in a Rails app'
                              endif

FUNCTION  gitgutter#all()
Called 10 times
Total time:   0.432267
 Self time:   0.157298

count  total (s)   self (s)
   46   0.000972   0.000454   for buffer_id in gitgutter#utility#dedup(tabpagebuflist())
   36              0.155362     let file = expand('#' . buffer_id . ':p')
   36              0.000268     if !empty(file)
   36   0.275159   0.000708       call gitgutter#process_buffer(buffer_id, 0)
   36              0.000072     endif
   36              0.000069   endfor

FUNCTION  gitgutter#utility#extension()
Called 1192 times
Total time:   0.013473
 Self time:   0.013473

count  total (s)   self (s)
 1192              0.011055   return fnamemodify(s:file, ':e')

FUNCTION  emmet#expandAbbr()
Called 27 times
Total time:   0.372525
 Self time:   0.068082

count  total (s)   self (s)
   27   0.004888   0.000838   let type = emmet#getFileType()
   27   0.006824   0.000829   let rtype = emmet#lang#type(emmet#getFileType(1))
   27   0.002312   0.000576   let indent = emmet#getIndentation(type)
   27              0.000066   let expand = ''
   27              0.000053   let line = ''
   27              0.000053   let part = ''
   27              0.000052   let rest = ''
                            
   27   0.008868   0.000235   let filters = emmet#getFilters(type)
   27              0.000105   if len(filters) ==# 0
   26              0.000091     let filters = ['html']
   26              0.000034   endif
                            
   27              0.000057   if a:mode ==# 2
                                let leader = substitute(input('Tag: ', ''), '^\s*\(.*\)\s*$', '\1', 'g')
                                if len(leader) ==# 0
                                  return ''
                                endif
                                if leader =~# s:filtermx
                                  let filters = map(split(matchstr(leader, s:filtermx)[1:], '\s*[^\\]\zs,\s*'), 'substitute(v:val, "\\\\\\\\zs.\\\\ze", "&", "g")')
                                  let leader = substitute(leader, s:filtermx, '', '')
                                endif
                                if leader =~# '\*'
                                  let query = substitute(leader, '*', '*' . (a:lastline - a:firstline + 1), '')
                                  if query !~# '}\s*$' && query !~# '\$#'
                                    let query .= '>{$#}'
                                  endif
                                  if emmet#useFilter(filters, '/')
                                    let spl = emmet#splitFilterArg(filters)
                                    let fline = getline(a:firstline)
                                    let query = substitute(query, '>\{0,1}{\$#}\s*$', '{\\$column\\$}*' . len(split(fline, spl)), '')
                                  else
                                    let spl = ''
                                  endif
                                  let items = emmet#parseIntoTree(query, type).child
                                  let itemno = 0
                                  for item in items
                                    let inner = emmet#toString(item, type, 0, filters, 0, indent)
                                    let inner = substitute(inner, '\$#', '$line'.(itemno*(a:lastline - a:firstline + 1)/len(items)+1).'$', 'g')
                                    let expand .= inner
                                    let itemno = itemno + 1
                                  endfor
                                  if emmet#useFilter(filters, 'e')
                                    let expand = substitute(expand, '&', '\&amp;', 'g')
                                    let expand = substitute(expand, '<', '\&lt;', 'g')
                                    let expand = substitute(expand, '>', '\&gt;', 'g')
                                  endif
                                  let line = getline(a:firstline)
                                  let part = substitute(line, '^\s*', '', '')
                                  for n in range(a:firstline, a:lastline)
                                    let lline = getline(n)
                                    let lpart = substitute(lline, '^\s\+', '', '')
                                    if emmet#useFilter(filters, 't')
                                      let lpart = substitute(lpart, '^[0-9.-]\+\s\+', '', '')
                                      let lpart = substitute(lpart, '\s\+$', '', '')
                                    endif
                                    if emmet#useFilter(filters, '/')
                                      for column in split(lpart, spl)
                                        let expand = substitute(expand, '\$column\$', '\=column', '')
                                      endfor
                                    else
                                      let expand = substitute(expand, '\$line'.(n-a:firstline+1).'\$', '\=lpart', 'g')
                                    endif
                                  endfor
                                  let expand = substitute(expand, '\$line\d*\$', '', 'g')
                                  let expand = substitute(expand, '\$column\$', '', 'g')
                                  let content = join(getline(a:firstline, a:lastline), "\n")
                                  if stridx(expand, '$#') < len(expand)-2
                                    let expand = substitute(expand, '^\(.*\)\$#\s*$', '\1', '')
                                  endif
                                  let expand = substitute(expand, '\$#', '\=content', 'g')
                                else
                                  let str = ''
                                  if visualmode() ==# 'V'
                                    let line = getline(a:firstline)
                                    let lspaces = matchstr(line, '^\s*', '', '')
                                    let part = substitute(line, '^\s*', '', '')
                                    for n in range(a:firstline, a:lastline)
                                      if len(leader) > 0
                                        let line = getline(a:firstline)
                                        let spaces = matchstr(line, '^\s*', '', '')
                                        if len(spaces) >= len(lspaces)
                                          let str .= indent . getline(n)[len(lspaces):] . "\n"
                                        else
                                          let str .= getline(n) . "\n"
                                        endif
                                      else
                                        let lpart = substitute(getline(n), '^\s*', '', '')
                                        let str .= lpart . "\n"
                                      endif
                                    endfor
                                    if stridx(leader, '{$#}') ==# -1
                                      let leader .= '{$#}'
                                    endif
                                    let items = emmet#parseIntoTree(leader, type).child
                                  else
                                    let save_regcont = @"
                                    let save_regtype = getregtype('"')
                                    silent! normal! gvygv
                                    let str = @"
                                    call setreg('"', save_regcont, save_regtype)
                                    if stridx(leader, '{$#}') ==# -1
                                      let leader .= '{$#}'
                                    endif
                                    let items = emmet#parseIntoTree(leader, type).child
                                  endif
                                  for item in items
                                    let expand .= emmet#toString(item, type, 0, filters, 0, '')
                                  endfor
                                  if emmet#useFilter(filters, 'e')
                                    let expand = substitute(expand, '&', '\&amp;', 'g')
                                    let expand = substitute(expand, '<', '\&lt;', 'g')
                                    let expand = substitute(expand, '>', '\&gt;', 'g')
                                  endif
                                  if stridx(leader, '{$#}') !=# -1
                                    let expand = substitute(expand, '\$#', '\="\n" . str', 'g')
                                  endif
                                endif
                              elseif a:mode ==# 4
                                let line = getline('.')
                                let spaces = matchstr(line, '^\s*')
                                if line !~# '^\s*$'
                                  put =spaces.a:abbr
                                else
                                  call setline('.', spaces.a:abbr)
                                endif
                                normal! $
                                call emmet#expandAbbr(0, '')
                                return ''
                              else
   27              0.000162     let line = getline('.')
   27              0.000135     if col('.') < len(line)
    8              0.000160       let line = matchstr(line, '^\(.*\%'.col('.').'c\)')
    8              0.000013     endif
   27              0.000053     if a:mode ==# 1
                                  let part = matchstr(line, '\([a-zA-Z0-9:_\-\@|]\+\)$')
                                else
   27              0.000528       let part = matchstr(line, '\(\S.*\)$')
   27   0.000770   0.000350       let ftype = emmet#lang#exists(type) ? type : 'html'
   27   0.009994   0.000366       let part = emmet#lang#{ftype}#findTokens(part)
   27              0.000278       let line = line[0: strridx(line, part) + len(part) - 1]
   27              0.000038     endif
   27              0.000116     if col('.') ==# col('$')
   14              0.000033       let rest = ''
   14              0.000017     else
   13              0.000082       let rest = getline('.')[len(line):]
   13              0.000017     endif
   27              0.000070     let str = part
   27              0.000409     if str =~# s:filtermx
                                  let filters = split(matchstr(str, s:filtermx)[1:], '\s*,\s*')
                                  let str = substitute(str, s:filtermx, '', '')
                                endif
   27   0.237424   0.000324     let items = emmet#parseIntoTree(str, type).child
   52              0.000095     for item in items
   25   0.023116   0.000309       let expand .= emmet#toString(item, type, 0, filters, 0, indent)
   25              0.000022     endfor
   27   0.000602   0.000143     if emmet#useFilter(filters, 'e')
                                  let expand = substitute(expand, '&', '\&amp;', 'g')
                                  let expand = substitute(expand, '<', '\&lt;', 'g')
                                  let expand = substitute(expand, '>', '\&gt;', 'g')
                                endif
   27              0.000283     let expand = substitute(expand, '\$line\([0-9]\+\)\$', '\=submatch(1)', 'g')
   27              0.000025   endif
   27   0.007564   0.000125   let expand = emmet#expandDollarExpr(expand)
   27   0.001577   0.000157   let expand = emmet#expandCursorExpr(expand, a:mode)
   27              0.000046   if len(expand)
   27              0.000094     if has_key(s:emmet_settings, 'timezone') && len(s:emmet_settings.timezone)
                                  let expand = substitute(expand, '${datetime}', strftime('%Y-%m-%dT%H:%M:%S') . s:emmet_settings.timezone, 'g')
                                else
                                  " TODO: on windows, %z/%Z is 'Tokyo(Standard)'
   27              0.000901       let expand = substitute(expand, '${datetime}', strftime('%Y-%m-%dT%H:%M:%S %z'), 'g')
   27              0.000032     endif
   27   0.000316   0.000154     let expand = emmet#unescapeDollarExpr(expand)
   27              0.000066     if a:mode ==# 2 && visualmode() ==# 'v'
                                  if a:firstline ==# a:lastline
                                    let expand = substitute(expand, '[\r\n]\s*', '', 'g')
                                  else
                                    let expand = substitute(expand, '[\n]$', '', 'g')
                                  endif
                                  silent! normal! gv
                                  let col = col('''<')
                                  silent! normal! c
                                  let line = getline('.')
                                  let lhs = matchstr(line, '.*\%<'.col.'c.')
                                  let rhs = matchstr(line, '\%>'.(col-1).'c.*')
                                  let expand = lhs.expand.rhs
                                  let lines = split(expand, '\n')
                                  call setline(line('.'), lines[0])
                                  if len(lines) > 1
                                    call append(line('.'), lines[1:])
                                  endif
                                else
   27              0.000219       if line[:-len(part)-1] =~# '^\s\+$'
   25              0.000210         let indent = line[:-len(part)-1]
   25              0.000022       else
    2              0.000003         let indent = ''
    2              0.000001       endif
   27              0.000265       let expand = substitute(expand, '[\r\n]\s*$', '', 'g')
   27   0.000669   0.000198       if emmet#useFilter(filters, 's')
                                    let epart = substitute(expand, '[\r\n]\s*', '', 'g')
                                  else
   27              0.000185         let epart = substitute(expand, '[\r\n]', "\n" . indent, 'g')
   27              0.000022       endif
   27              0.000125       let expand = line[:-len(part)-1] . epart . rest
   27              0.000166       let lines = split(expand, '[\r\n]', 1)
   27              0.000040       if a:mode ==# 2
                                    silent! exe 'normal! gvc'
                                  endif
   27              0.000301       call setline('.', lines[0])
   27              0.000059       if len(lines) > 1
                                    call append('.', lines[1:])
                                  endif
   27              0.000015     endif
   27              0.000014   endif
   27              0.000038   if g:emmet_debug > 1
                                call getchar()
                              endif
   27              0.000266   if search('\ze\$\(cursor\|select\)\$', 'c')
   27              0.000091     let oldselection = &selection
   27              0.000161     let &selection = 'inclusive'
   27              0.000088     if foldclosed(line('.')) !=# -1
                                  silent! foldopen
                                endif
   27   0.000516   0.000173     let pos = emmet#util#getcurpos()
   27   0.003942   0.000162     let use_selection = emmet#getResource(type, 'use_selection', 0)
   27              0.000033     try
   27              0.000060       let l:gdefault = &gdefault
   27              0.000202       let &gdefault = 0
   27              0.000084       if use_selection && getline('.')[col('.')-1:] =~# '^\$select'
                                    let pos[2] += 1
                                    silent! s/\$select\$//
                                    let next = searchpos('.\ze\$select\$', 'nW')
                                    silent! %s/\$\(cursor\|select\)\$//g
                                    call emmet#util#selectRegion([pos[1:2], next])
                                    return "\<esc>gv"
                                  else
   27              0.000672         silent! %s/\$\(cursor\|select\)\$//g
   27              0.000133         silent! call setpos('.', pos)
   27              0.000089         if col('.') < col('$')
   27              0.000100           return "\<right>"
                                    endif
                                  endif
                                finally
   27              0.000200       let &gdefault = l:gdefault
   27              0.000044     endtry
                                let &selection = oldselection
                              endif
                              return ''

FUNCTION  <SNR>125_multipliers()
Called 15154 times
Total time:   0.253549
 Self time:   0.253549

count  total (s)   self (s)
15154              0.046359 	let mp0 = !a:1 ? 0 : 2
15154              0.047972 	let mp1 = !a:2 ? 0 : 1 + ( !mp0 ? 1 : mp0 )
15154              0.047323 	let mp2 = !a:3 ? 0 : 1 + ( !( mp0 + mp1 ) ? 1 : ( mp0 + mp1 ) )
15154              0.054989 	let mp3 = !a:4 ? 0 : 1 + ( !( mp0 + mp1 + mp2 ) ? 1 : ( mp0 + mp1 + mp2 ) )
15154              0.038079 	retu [mp0, mp1, mp2, mp3]

FUNCTION  <SNR>125_MapNorms()
Called 109 times
Total time:   0.001400
 Self time:   0.001400

count  total (s)   self (s)
  109              0.001191 	if exists('s:nmapped') && s:nmapped == s:bufnr | retu | en
                            	let pcmd = "nn \<buffer> \<silent> \<k%s> :\<c-u>cal \<SID>%s(\"%s\")\<cr>"
                            	let cmd = substitute(pcmd, 'k%s', 'char-%d', '')
                            	let pfunc = 'PrtFocusMap'
                            	let ranges = [32, 33, 125, 126] + range(35, 91) + range(93, 123)
                            	for each in [34, 92, 124]
                            		exe printf(cmd, each, pfunc, escape(nr2char(each), '"|\'))
                            	endfo
                            	for each in ranges
                            		exe printf(cmd, each, pfunc, nr2char(each))
                            	endfo
                            	for each in range(0, 9)
                            		exe printf(pcmd, each, pfunc, each)
                            	endfo
                            	for [ke, va] in items(s:kprange)
                            		exe printf(pcmd, ke, pfunc, va)
                            	endfo
                            	let s:nmapped = s:bufnr

FUNCTION  <SNR>65_buffer_repo()
Called 210 times
Total time:   0.009097
 Self time:   0.002104

count  total (s)   self (s)
  210   0.008987   0.001994   return s:repo(self.getvar('git_dir'))

FUNCTION  syntastic#util#bufVar()
Called 296 times
Total time:   0.006182
 Self time:   0.003410

count  total (s)   self (s)
  296   0.005820   0.003048     return call('syntastic#util#bufRawVar', [a:buf, 'syntastic_' . a:name] + a:000)

FUNCTION  <SNR>112_get_section()
Called 13640 times
Total time:   0.429300
 Self time:   0.387175

count  total (s)   self (s)
13640              0.044257   if has_key(s:section_truncate_width, a:key)
 7615              0.025671     if winwidth(a:winnr) < s:section_truncate_width[a:key]
 4055              0.004598       return ''
                                endif
 3560              0.002134   endif
 9585              0.022129   let spc = g:airline_symbols.space
 9585              0.044800   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
 9585   0.114578   0.072453   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
 9585              0.065898   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
 9585              0.036723   return empty(text) ? '' : prefix.text.suffix

FUNCTION  ctrlp#utils#cachefile()
Called 129 times
Total time:   0.012783
 Self time:   0.010849

count  total (s)   self (s)
  129              0.004643 	let [tail, dir] = [a:0 == 1 ? '.'.a:1 : '', a:0 == 2 ? a:1 : getcwd()]
  129              0.003927 	let cache_file = substitute(dir, '\([\/]\|^\a\zs:\)', '%', 'g').tail.'.txt'
  129   0.004037   0.002103 	retu a:0 == 1 ? cache_file : s:cache_dir.s:lash(s:cache_dir).cache_file

FUNCTION  <SNR>125_compmatlen()
Called 15154 times
Total time:   3.135169
 Self time:   0.335605

count  total (s)   self (s)
                            	" By match length
15154   1.554746   0.137708 	let mln1 = s:shortest(s:matchlens(a:1, s:compat))
15154   1.520477   0.137951 	let mln2 = s:shortest(s:matchlens(a:2, s:compat))
15154              0.039575 	retu mln1 == mln2 ? 0 : mln1 > mln2 ? 1 : -1

FUNCTION  rails#lencmp()
Called 95113 times
Total time:   0.321269
 Self time:   0.321269

count  total (s)   self (s)
95113              0.284048   return len(a:i1) - len(a:i2)

FUNCTION  <SNR>118_readable_define_pattern()
Called 53 times
Total time:   0.054326
 Self time:   0.003859

count  total (s)   self (s)
   53   0.010424   0.000490   if self.name() =~ '\.yml\%(\.example\)\=$'
                                return '^\%(\h\k*:\)\@='
                              endif
   53              0.000109   let define = '^\s*def\s\+\(self\.\)\='
   53   0.010070   0.000436   if self.name() =~# '\.rake$'
                                let define .= "\\\|^\\s*\\%(task\\\|file\\)\\s\\+[:'\"]"
                              endif
   53   0.010092   0.000577   if self.name() =~# '/schema\.rb$'
                                let define .= "\\\|^\\s*create_table\\s\\+[:'\"]"
                              endif
   53   0.010429   0.000446   if self.name() =~# '\.erb$'
                                let define .= '\|\<id=["'']\='
                              endif
   53   0.010074   0.000463   if self.name() =~# '\.haml$'
   43              0.000145     let define .= '\|^\s*\%(%\w*\)\=\%(\.[[:alnum:]_-]\+\)*#'
   43              0.000034   endif
   53   0.002123   0.000334   if self.type_name('test')
                                let define .= '\|^\s*test\s*[''"]'
                              endif
   53              0.000066   return define

FUNCTION  <SNR>125_Open()
Called 109 times
Total time:   2.054899
 Self time:   0.199178

count  total (s)   self (s)
  109   0.003551   0.000708 	cal s:log(1)
  109   0.080165   0.001387 	cal s:getenv()
  109   0.002175   0.000856 	cal s:execextvar('enter')
  109              0.123786 	sil! exe 'keepa' ( s:mw_pos == 'top' ? 'to' : 'bo' ) '1new ControlP'
  109   0.004075   0.001497 	cal s:buffunc(1)
  109              0.000994 	let [s:bufnr, s:winw] = [bufnr('%'), winwidth(0)]
  109              0.000822 	let [s:focus, s:prompt] = [1, ['', '', '']]
  109              0.000272 	abc <buffer>
  109              0.000487 	if !exists('s:hstry')
                            		let hst = filereadable(s:gethistloc()[1]) ? s:gethistdata() : ['']
                            		let s:hstry = empty(hst) || !s:maxhst ? [''] : hst
                            	en
 3706              0.014909 	for [ke, va] in items(s:glbs) | if exists('+'.ke)
 1635              0.033465 		sil! exe 'let s:glb_'.ke.' = &'.ke.' | let &'.ke.' = '.string(va)
 3379              0.004266 	en | endfo
  109              0.000713 	if s:opmul != '0' && has('signs')
  109              0.008631 		sign define ctrlpmark text=+> texthl=Search
  109              0.000156 	en
  109   1.771475   0.001271 	cal s:setupblank()

FUNCTION  110()
Called 10 times
Total time:   0.001842
 Self time:   0.000080

count  total (s)   self (s)
   10   0.001800   0.000038     if a:path.equals(self.path)
    2              0.000002         return self
                                endif
    8              0.000019     return {}

FUNCTION  airline#highlighter#highlight()
Called 3159 times
Total time: 318.466307
 Self time:  33.585320

count  total (s)   self (s)
 3159              0.011874   let bufnr = a:0 ? a:1 : ''
 3159              0.015038   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
 3159              0.041562   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
 3159              0.013198   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
 8003              0.015287   for mode in mapped
 4844              0.016140     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
                                  continue
                                endif
 4844              0.033700     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
 4744              0.021890       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
253713              0.571796       for kvp in items(dict)
248969              0.657295         let mode_colors = kvp[1]
248969              0.544730         let name = kvp[0]
248969              0.710416         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
  468              0.001085           let name = 'airline_c'.bufnr
  468              0.000346         endif
248969  56.011014   1.543660         call airline#highlighter#exec(name.suffix, mode_colors)
                            
746907              1.379309         for accent in keys(s:accents)
497938              1.368066           if !has_key(p.accents, accent)
                                        continue
                                      endif
497938              1.677919           let colors = copy(mode_colors)
497938              1.535599           if p.accents[accent][0] != ''
248969              0.800996             let colors[0] = p.accents[accent][0]
248969              0.197664           endif
497938              1.150277           if p.accents[accent][2] != ''
248969              0.714205             let colors[2] = p.accents[accent][2]
248969              0.188803           endif
497938              0.872324           if len(colors) >= 5
497938              1.836552             let colors[4] = get(p.accents[accent], 4, '')
497938              0.401475           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
497938 118.934519   3.478126           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
497938              0.446824         endfor
248969              0.181083       endfor
                            
                                  " TODO: optimize this
225953              0.456683       for sep in items(s:separators)
221209 117.042059   2.084820         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
221209              0.213998       endfor
 4744              0.009378     endif
 4844              0.003630   endfor

FUNCTION  gitgutter#diff#process_added()
Called 2622 times
Total time:   1.353479
 Self time:   1.353479

count  total (s)   self (s)
 2622              0.005374   let offset = 0
131009              0.172742   while offset < a:to_count
128387              0.290690     let line_number = a:to_line + offset
128387              0.473496     call add(a:modifications, [line_number, 'added'])
128387              0.234493     let offset += 1
128387              0.107747   endwhile

FUNCTION  repeat#set()
Called 1 time
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
    1              0.000006     let g:repeat_sequence = a:sequence
    1              0.000005     let g:repeat_count = a:0 ? a:1 : v:count
    1              0.000003     let g:repeat_tick = b:changedtick
    1              0.000005     augroup repeat_custom_motion
    1              0.000097         autocmd!
    1              0.000010         autocmd CursorMoved <buffer> let g:repeat_tick = b:changedtick | autocmd! repeat_custom_motion
    1              0.000002     augroup END

FUNCTION  <SNR>97_init_buffer()
Called 2 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    2              0.000006   let b:buffer_vcs_config = {}
    6              0.000011   for vcs in keys(s:vcs_config)
    4              0.000018     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',   }
    4              0.000003   endfor
    2              0.000003   unlet! b:airline_head

FUNCTION  <SNR>61__ignore_file()
Called 1006 times
Total time:   0.062346
 Self time:   0.062346

count  total (s)   self (s)
 1006              0.047044     let fname = fnamemodify(a:filename, ':p')
 1006              0.005171     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
 1006              0.001383     return 0

FUNCTION  airline#parts#ffenc()
Called 68 times
Total time:   0.002014
 Self time:   0.002014

count  total (s)   self (s)
   68              0.000387   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   68              0.000211   let bomb     = &l:bomb ? '[BOM]' : ''
   68              0.000579   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   68              0.000342   if expected is# &fenc.bomb.ff
                                return ''
                              else
   68              0.000247     return &fenc.bomb.ff
                              endif

FUNCTION  <SNR>65_shellslash()
Called 694 times
Total time:   0.016523
 Self time:   0.009375

count  total (s)   self (s)
  694   0.011043   0.003895   if s:winshell()
                                return s:gsub(a:path,'\\','/')
                              else
  694              0.001217     return a:path
                              endif

FUNCTION  emmet#getResource()
Called 284 times
Total time:   0.200140
 Self time:   0.045368

count  total (s)   self (s)
  284              0.001555   if exists('b:emmet_' . a:name)
                                return get(b:, 'emmet_' . a:name)
                              endif
  284              0.000625   let global = {}
  284              0.001284   if has_key(s:emmet_settings, '*') && has_key(s:emmet_settings['*'], a:name)
                                let global = extend(global, s:emmet_settings['*'][a:name])
                              endif
                            
  284              0.000818   if has_key(s:emmet_settings, a:type)
  284              0.000780     let types = [a:type]
  284              0.000265   else
                                let types = split(a:type, '\.')
                              endif
                            
  364              0.000967   for type in types
  284              0.000932     if !has_key(s:emmet_settings, type)
                                  continue
                                endif
  284              0.000650     let ret = a:default
                            
  284              0.001082     if has_key(s:emmet_settings[type], 'extends')
  284              0.001028       let extends = s:emmet_settings[type].extends
  284              0.000780       if type(extends) ==# 1
  284              0.002411         let tmp = split(extends, '\s*,\s*')
  284              0.000682         unlet! extends
  284              0.000738         let extends = tmp
  284              0.000286       endif
  568              0.000898       for ext in extends
  284              0.001687         if has_key(s:emmet_settings, ext) && has_key(s:emmet_settings[ext], a:name)
  103              0.000340           if type(ret) ==# 3 || type(ret) ==# 4
  102   0.152996   0.001065             call emmet#mergeConfig(ret, s:emmet_settings[ext][a:name])
  102              0.000087           else
    1              0.000005             let ret = s:emmet_settings[ext][a:name]
    1              0.000001           endif
  103              0.000126         endif
  284              0.000285       endfor
  284              0.000205     endif
                            
  284              0.001031     if has_key(s:emmet_settings[type], a:name)
   50              0.000133       if type(ret) ==# 3 || type(ret) ==# 4
   25   0.003050   0.000210         call emmet#mergeConfig(ret, s:emmet_settings[type][a:name])
   25              0.000411         return extend(global, ret)
                                  else
   25              0.000060         return s:emmet_settings[type][a:name]
                                  endif
                                endif
  234              0.000544     if !empty(ret)
  154              0.000447       if type(ret) ==# 3 || type(ret) ==# 4
   77              0.001529         let ret = extend(global, ret)
   77              0.000086       endif
  154              0.000206       return ret
                                endif
   80              0.000086   endfor
                            
   80              0.000192   let ret = a:default
   80              0.000290   if type(ret) ==# 3 || type(ret) ==# 4
   27              0.000105     let ret = extend(global, ret)
   27              0.000028   endif
   80              0.000113   return ret

FUNCTION  <SNR>125_nonamecond()
Called 77 times
Total time:   0.002869
 Self time:   0.002869

count  total (s)   self (s)
   77              0.002709 	retu a:str =~ '[\/]\?\[\d\+\*No Name\]$' && !filereadable(a:filpath) && bufnr('^'.a:filpath.'$') < 1

FUNCTION  gitgutter#sign#upsert_new_gitgutter_signs()
Called 1444 times
Total time:   4.947529
 Self time:   4.425570

count  total (s)   self (s)
 1444   0.009621   0.006684   let bufnr = gitgutter#utility#bufnr()
 1444   0.023218   0.007946   let other_signs         = gitgutter#utility#getbufvar(bufnr, 'other_signs')
 1444   0.020230   0.007564   let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
                            
131560              0.119016   for line in a:modified_lines
130116              0.279954     let line_number = line[0]  " <number>
130116              0.288191     if index(other_signs, line_number) == -1  " don't clobber others' signs
129440   1.112361   0.626994       let name = gitgutter#utility#highlight_name_for_change(line[1])
129440              0.362059       if !has_key(old_gitgutter_signs, line_number)  " insert
  813   0.009007   0.003291         let id = gitgutter#sign#next_sign_id()
  813              0.974951         execute "sign place" id "line=" . line_number "name=" . name "buffer=" . bufnr
  813              0.001639       else  " update if sign has changed
128627              0.344878         let old_sign = old_gitgutter_signs[line_number]
128627              0.218493         if old_sign.name !=# name
    2              0.002044           execute "sign place" old_sign.id "name=" . name "buffer=" . bufnr
    2              0.000003         end
128627              0.068185       endif
129440              0.064472     endif
130116              0.084854   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  <SNR>118_app_ruby_script_command()
Called 137 times
Total time:   0.001870
 Self time:   0.001870

count  total (s)   self (s)
  137              0.000918   if has('win32')
                                return 'ruby ' . a:cmd
                              else
  137              0.000309     return a:cmd
                              endif

FUNCTION  <SNR>118_cache_get()
Called 10098 times
Total time:   0.051354
 Self time:   0.051354

count  total (s)   self (s)
10098              0.016397   if a:0 == 1
10098              0.027686     return self.dict[a:1][0]
                              else
                                return self.dict
                              endif

FUNCTION  <SNR>118_set_path_options()
Called 137 times
Total time:   3.582906
 Self time:   0.064523

count  total (s)   self (s)
  137   0.003550   0.000669   let self = rails#buffer()
  137   0.026952   0.000716   let name = self.name()
                            
  137              0.002109   let assetdir = matchstr(name, '^\%(public/\|\w\+/assets/\)\zs[^/]\+')
  137   0.020255   0.002211   let suffixes = join(s:suffixes(assetdir), ',')
  137              0.000293   if !empty(assetdir)
   40              0.000065     let delegate = ''
   40              0.000203     if exists(':chistory')
                                  let cfilemap = maparg('<Plug><cfile>', 'c', 0, 1)
                                  if get(cfilemap, 'buffer') && cfilemap.expr && cfilemap.rhs !~# 'rails#\|Ruby'
                                    let delegate = string(maparg('<Plug><cfile>', 'c'))
                                  endif
                                endif
   40              0.000107     let map = 'rails#asset_cfile('.delegate.')'
   40              0.000082     if len(suffixes)
   40              0.000230       let &l:suffixesadd = suffixes
   40              0.000037     endif
   40              0.000215     if name =~# '\.erb$'
                                  let map = 'rails#embedded_cfile('.string(map).')'
                                  setlocal suffixesadd^=.rb
                                endif
   40              0.001054     exe 'cmap <buffer><script><expr> <Plug><cfile>' map
   40              0.000313     let &l:include = &l:include.(empty(&l:include) ? '' : '\|') . '^\s*[[:punct:]]\+=\s*\%(link\|require\|depend_on\|stub\)\w*'
   40              0.000061   elseif name =~# '^node_modules\>\|^app/javascript\>'
                                let &l:suffixesadd = join(s:uniq(['.coffee', '.js', '.jsx', '.ts', '.vue'] + split(&l:suffixesadd, ',') + ['/package.json']), ',')
                              else
   97              0.000288     if empty(&l:suffixesadd)
   44              0.000304       setlocal suffixesadd=.rb
   44              0.000044     endif
   97              0.000456     if &l:suffixesadd =~# '\.rb\>'
   97              0.000529       setlocal includeexpr=rails#includeexpr(v:fname)
   97              0.001952       cmap <buffer><script><expr> <Plug><cfile> rails#cfile()
   97              0.000083     endif
   97              0.000068   endif
                            
  137   0.010604   0.001535   if self.app().path() =~ '://'
                                return
                              endif
                            
  137              0.000369   let old_path_str = &l:path
  137              0.001009   if old_path_str =~# '\v^\.%(,/%(usr|emx)/include)=,,$'
   50              0.000100     let add_dot = 0
   50              0.000081     let old_path = []
   50              0.000035   else
   87              0.000385     let add_dot = old_path_str =~# '^\.\%(,\|$\)'
   87   0.003801   0.001164     let old_path = s:pathsplit(s:sub(old_path_str,'^\.%(,|$)',''))
   87              0.000082   endif
                            
  137   0.942907   0.001341   let path = filter(self.projected('path'), 'type(v:val) == type("")')
                            
  137              0.000311   let engine_paths = []
  137              0.001282   if &l:suffixesadd =~# '\.rb\>'
   97   1.127685   0.001473     let path += self.app().internal_load_path()
   97              0.000230     let path += ['app/views']
   97   0.675586   0.000572     if self.controller_name() != ''
   65   0.431127   0.000728       let path += ['app/views/'.self.controller_name(), 'app/views/application', 'public']
   65              0.000068     endif
   97   0.018094   0.001004     if !self.app().has_rails5()
   97              0.000378       let path += ['vendor/plugins/*/lib', 'vendor/rails/*/lib']
   97              0.000077     endif
   97   0.016855   0.001146     let engine_paths = map(copy(self.app().engines()), 'v:val . "/app/*"')
   97              0.000083   endif
                            
  137   0.030608   0.002152   if self.name() =~# '^node_modules\>\|^app/javascript\>'
                                call extend(path, ['node_modules'])
                                let add_dot = 1
                              elseif !empty(assetdir)
   40   0.011863   0.000951     call extend(path, self.app().asset_path())
   40              0.000037   else
   97   0.007036   0.000975     call add(path, self.app().path())
   97              0.000110   endif
                            
  137   0.171761   0.019476   call map(path, 'self.app().path(v:val)')
                            
  137   0.059376   0.003566   let &l:path = (add_dot ? '.,' : '').s:pathjoin(s:uniq(path + old_path + engine_paths))
  137              0.000572   let undo = get(b:, 'undo_ftplugin', '')
  137              0.000664   let b:undo_ftplugin = (empty(undo) ? '' : undo . '|') . 'setl path< sua< inc< inex<'

FUNCTION  <SNR>129_Rgb2xterm()
Called 294 times
Total time:   3.674527
 Self time:   1.609292

count  total (s)   self (s)
  294              0.000904   let best_match=0
  294              0.000883   let smallest_distance = 10000000000
  294              0.001610   let r = eval('0x'.a:color[1].a:color[2])
  294              0.001262   let g = eval('0x'.a:color[3].a:color[4])
  294              0.001224   let b = eval('0x'.a:color[5].a:color[6])
75264              0.077149   for c in range(0,254)
74970   3.179847   1.114612     let d = s:pow(s:colortable[c][0]-r,2) + s:pow(s:colortable[c][1]-g,2) + s:pow(s:colortable[c][2]-b,2)
74970              0.114942     if d<smallest_distance
 1363              0.002400       let smallest_distance = d
 1363              0.001980       let best_match = c
 1363              0.001000     endif
74970              0.056748   endfor
  294              0.000449   return best_match

FUNCTION  <SNR>269_Match()
Called 725 times
Total time:   0.078844
 Self time:   0.017483

count  total (s)   self (s)
  725              0.013385   let col = match(getline(a:lnum), '\C'.a:regex) + 1
  725   0.064860   0.003499   return col > 0 && !s:IsInStringOrComment(a:lnum, col) ? col : 0

FUNCTION  ctrlp#utils#opts()
Called 109 times
Total time:   0.560608
 Self time:   0.556169

count  total (s)   self (s)
  109   0.001553   0.000732 	let s:lash = ctrlp#utils#lash()
  109   0.002908   0.001318 	let usrhome = $HOME . s:lash( $HOME )
  109              0.001027 	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
  109   0.551829   0.549801 	let cadir = isdirectory(usrhome.'.ctrlp_cache') ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
  109              0.000574 	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
                            	en
  109              0.000368 	let s:cache_dir = cadir

FUNCTION  ctrlp#utils#lash()
Called 218 times
Total time:   0.001823
 Self time:   0.001823

count  total (s)   self (s)
  218              0.001597 	retu &ssl || !exists('+ssl') ? '/' : '\'

FUNCTION  <SNR>125_comparent()
Called 15154 times
Total time:   1.836064
 Self time:   0.593969

count  total (s)   self (s)
                            	" By same parent dir
15154              0.051965 	if !stridx(s:crfpath, s:dyncwd)
15154   0.477665   0.193006 		let [as1, as2] = [s:dyncwd.s:lash().a:1, s:dyncwd.s:lash().a:2]
15154   1.140554   0.183118 		let [loc1, loc2] = [s:getparent(as1), s:getparent(as2)]
15154              0.069433 		if loc1 == s:crfpath && loc2 != s:crfpath | retu -1 | en
14767              0.055466 		if loc2 == s:crfpath && loc1 != s:crfpath | retu 1  | en
13996              0.013332 		retu 0
                            	en
                            	retu 0

FUNCTION  nerdtree#compareNodesBySortKey()
Called 1230 times
Total time:   0.135282
 Self time:   0.050341

count  total (s)   self (s)
 1230   0.052220   0.005117     let sortKey1 = a:n1.path.getSortKey()
 1230   0.042450   0.004613     let sortKey2 = a:n2.path.getSortKey()
                            
 1230              0.001493     let i = 0
 2136              0.007251     while i < min([len(sortKey1), len(sortKey2)])
                                    " Compare chunks upto common length.
                                    " If chunks have different type, the one which has
                                    " integer type is the lesser.
 2136              0.007397         if type(sortKey1[i]) == type(sortKey2[i])
 2136              0.004917             if sortKey1[i] <# sortKey2[i]
  603              0.000608                 return - 1
                                        elseif sortKey1[i] ># sortKey2[i]
  627              0.000562                 return 1
                                        endif
  906              0.001575         elseif sortKey1[i] == type(0)
                                        return -1
                                    elseif sortKey2[i] == type(0)
                                        return 1
                                    endif
  906              0.001790         let i = i + 1
  906              0.000808     endwhile
                            
                                " Keys are identical upto common length.
                                " The key which has smaller chunks is the lesser one.
                                if len(sortKey1) < len(sortKey2)
                                    return -1
                                elseif len(sortKey1) > len(sortKey2)
                                    return 1
                                else
                                    return 0
                                endif

FUNCTION  gitgutter#async#available()
Called 2111 times
Total time:   0.011176
 Self time:   0.011176

count  total (s)   self (s)
 2111              0.008949   return s:available

FUNCTION  AutoPairsMap()
Called 432 times
Total time:   0.014944
 Self time:   0.014944

count  total (s)   self (s)
                              " | is special key which separate map command from text
  432              0.001269   let key = a:key
  432              0.000933   if key == '|'
                                let key = '<BAR>'
                              end
  432              0.002692   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
  432              0.007856   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
                            

FUNCTION  ctrlp#setdir()
Called 75 times
Total time:   0.017716
 Self time:   0.012258

count  total (s)   self (s)
   75              0.000541 	let cmd = a:0 ? a:1 : 'lc!'
   75   0.013231   0.007773 	sil! exe cmd s:fnesc(a:path, 'c')
   75              0.003592 	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]

FUNCTION  gitgutter#diff#parse_hunk()
Called 4225 times
Total time:   0.238212
 Self time:   0.238212

count  total (s)   self (s)
 4225              0.101487   let matches = matchlist(a:line, s:hunk_re)
 4225              0.013571   if len(matches) > 0
 2779              0.015572     let from_line  = str2nr(matches[1])
 2779              0.016052     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
 2779              0.010352     let to_line    = str2nr(matches[3])
 2779              0.015804     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
 2779              0.018176     return [from_line, from_count, to_line, to_count]
                              else
 1446              0.003023     return []
                              end

FUNCTION  <SNR>118_pathsplit()
Called 87 times
Total time:   0.002073
 Self time:   0.001408

count  total (s)   self (s)
   87              0.000540   if type(a:path) == type([]) | return copy(a:path) | endif
   87   0.001450   0.000785   return split(s:gsub(a:path, '\\ ', ' '), ',')

FUNCTION  gitgutter#utility#has_fresh_changes()
Called 8789 times
Total time:   0.480788
 Self time:   0.166731

count  total (s)   self (s)
 8789   0.466227   0.152170   return getbufvar(s:bufnr, 'changedtick') != gitgutter#utility#getbufvar(s:bufnr, 'last_tick')

FUNCTION  321()
Called 61 times
Total time:   0.002182
 Self time:   0.000802

count  total (s)   self (s)
   61              0.000220     if !exists('self._cachedErrors')
   30   0.001649   0.000269         let self._cachedErrors = self.filter({'type': 'E'})
   30              0.000030     endif
   61              0.000086     return self._cachedErrors

FUNCTION  <SNR>125_ispathitem()
Called 118 times
Total time:   0.001250
 Self time:   0.001250

count  total (s)   self (s)
  118              0.000659 	retu s:itemtype < 3 || ( s:itemtype > 2 && s:getextvar('type') == 'path' )

FUNCTION  <SNR>107_CheckDefined()
Called 992215 times
Total time:  23.508989
 Self time:  23.508989

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
992215              3.282297   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
992215              3.180932   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
1164401              2.323690   for val in a:colors
1139715              2.823243     if !empty(val) && val !=# 'NONE'
967529              1.306623       return a:colors
                                endif
172186              0.114450   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
24686              0.050325   let fg = g:airline#highlighter#normal_fg_hi
24686              0.368807   let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
24686              0.043907   if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
24686              0.159543   return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>125_strwidth()
Called 6538 times
Total time:   0.036960
 Self time:   0.036960

count  total (s)   self (s)
 6538              0.033881 	retu exists('*strdisplaywidth') ? strdisplaywidth(a:str) : strlen(a:str)

FUNCTION  repeat#run()
Called 5 times
Total time:   0.090913
 Self time:   0.090913

count  total (s)   self (s)
    5              0.000045     try
    5              0.000042         if g:repeat_tick == b:changedtick
                                        let r = ''
                                        if g:repeat_reg[0] ==# g:repeat_sequence && !empty(g:repeat_reg[1])
                                            if g:repeat_reg[1] ==# '='
                                                " This causes a re-evaluation of the expression on repeat, which
                                                " is what we want.
                                                let r = '"=' . getreg('=', 1) . "\<CR>"
                                            else
                                                let r = '"' . g:repeat_reg[1]
                                            endif
                                        endif
                            
                                        let c = g:repeat_count
                                        let s = g:repeat_sequence
                                        let cnt = c == -1 ? "" : (a:count ? a:count : (c ? c : ''))
                                        if ((v:version == 703 && has('patch100')) || (v:version == 704 && !has('patch601')))
                                            exe 'norm ' . r . cnt . s
                                        else
                                            call feedkeys(s, 'i')
                                            call feedkeys(r . cnt, 'ni')
                                        endif
                                    else
    5              0.000082             if ((v:version == 703 && has('patch100')) || (v:version == 704 && !has('patch601')))
                                            exe 'norm! '.(a:count ? a:count : '') . '.'
                                        else
    5              0.090094                 call feedkeys((a:count ? a:count : '') . '.', 'ni')
    5              0.000044             endif
    5              0.000010         endif
    5              0.000026     catch /^Vim(normal):/
                                    return 'echoerr v:errmsg'
                                endtry
    5              0.000017     return ''

FUNCTION  emmet#getDollarExprs()
Called 27 times
Total time:   0.006551
 Self time:   0.003654

count  total (s)   self (s)
   27              0.000061   let expand = a:expand
   27              0.000050   let dollar_list = []
   27              0.000070   let dollar_reg = '\%(\\\)\@<!\${\(\([^{}]\|\%(\\\)\@\<=[{}]\)\{}\)}'
   53              0.000065   while 1
   53              0.000907     let matcharr = matchlist(expand, dollar_reg)
   53              0.000131     if len(matcharr) > 0
   26              0.000072       let key = get(matcharr, 1)
   26              0.000107       if key !~# '^\d\+:'
   26              0.000121         let key = substitute(key, '\\{', '{', 'g')
   26              0.000093         let key = substitute(key, '\\}', '}', 'g')
   26   0.003248   0.000352         let value = emmet#getDollarValueByKey(key)
   26              0.000061         if type(value) ==# type('')
                                      let expr = get(matcharr, 0)
                                      call add(dollar_list, {'expr': expr, 'value': value})
                                    endif
   26              0.000013       endif
   26              0.000014     else
   27              0.000021       break
                                endif
   26              0.000585     let expand = substitute(expand, dollar_reg, '', '')
   26              0.000071   endwhile
   27              0.000034   return dollar_list

FUNCTION  airline#parts#get()
Called 113 times
Total time:   0.000640
 Self time:   0.000640

count  total (s)   self (s)
  113              0.000562   return get(s:parts, a:key, {})

FUNCTION  SyntaxCheckers_ruby_mri_GetHighlightRegex()
Called 196 times
Total time:   0.002437
 Self time:   0.002437

count  total (s)   self (s)
  196              0.000889     if stridx(a:i['text'], 'assigned but unused variable') >= 0
                                    let term = split(a:i['text'], ' - ')[1]
                                    return '\V\<' . escape(term, '\') . '\>'
                                endif
                            
  196              0.000193     return ''

FUNCTION  airline#load_theme()
Called 9 times
Total time:   1.335756
 Self time:   0.128552

count  total (s)   self (s)
    9              0.000263   if exists('*airline#themes#{g:airline_theme}#refresh')
    9   0.302478   0.000214     call airline#themes#{g:airline_theme}#refresh()
    9              0.000011   endif
                            
    9              0.000051   let palette = g:airline#themes#{g:airline_theme}#palette
    9   0.003146   0.000156   call airline#themes#patch(palette)
                            
    9              0.000040   if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
                              endif
                            
    9   0.703792   0.000069   call airline#highlighter#load_theme()
    9   0.041367   0.000120   call airline#extensions#load_theme()
    9   0.157068   0.000089   call airline#update_statusline()

FUNCTION  <SNR>125_gethistloc()
Called 192 times
Total time:   0.012552
 Self time:   0.005935

count  total (s)   self (s)
  192   0.002419   0.001656 	let utilcadir = ctrlp#utils#cachedir()
  192   0.005028   0.001830 	let cache_dir = utilcadir.s:lash(utilcadir).'hist'
  192   0.004869   0.002213 	retu [cache_dir, cache_dir.s:lash(cache_dir).'cache.txt']

FUNCTION  airline#parts#paste()
Called 31449 times
Total time:   0.155348
 Self time:   0.155348

count  total (s)   self (s)
31449              0.134013   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#extensions#load_theme()
Called 9 times
Total time:   0.041247
 Self time:   0.000177

count  total (s)   self (s)
    9   0.041233   0.000163   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  <SNR>97_update_hg_branch()
Called 68 times
Total time:   0.001835
 Self time:   0.001835

count  total (s)   self (s)
   68              0.000152   if s:has_lawrencium
                                let stl=lawrencium#statusline()
                                if !empty(stl) && s:has_async
                                  call s:get_mq_async('LC_ALL=C hg qtop', expand('%:p'))
                                endif
                                if exists("s:mq") && !empty(s:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.s:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
   68              0.000225     let s:vcs_config['mercurial'].branch = ''
   68              0.000060   endif

FUNCTION  <SNR>78_Wholematch()
Called 6 times
Total time:   0.000993
 Self time:   0.000993

count  total (s)   self (s)
    6              0.000047   let group = '\%(' . a:pat . '\)'
    6              0.000060   let prefix = (a:start ? '\(^.*\%<' . (a:start + 2) . 'c\)\zs' : '^')
    6              0.000033   let len = strlen(a:string)
    6              0.000042   let suffix = (a:start+1 < len ? '\(\%>'.(a:start+1).'c.*$\)\@=' : '$')
    6              0.000632   if a:string !~ prefix . group . suffix
    1              0.000004     let prefix = ''
    1              0.000001   endif
    6              0.000032   return prefix . group . suffix

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
Called 56 times
Total time:   1.366181
 Self time:   0.001397

count  total (s)   self (s)
   56   1.366047   0.001262     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  airline#update_statusline()
Called 708 times
Total time:  10.225618
 Self time:   0.120274

count  total (s)   self (s)
  708   0.011989   0.006772   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
 2507              0.013210   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
 1799   0.021553   0.011079     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
 1799              0.009395     call setwinvar(nr, 'airline_active', 0)
 1799              0.011662     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
 1799   6.617861   0.020733     call s:invoke_funcrefs(context, s:inactive_funcrefs)
 1799              0.004970   endfor
                            
  708              0.001934   unlet! w:airline_render_left w:airline_render_right
  708              0.009692   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
  708              0.001704   let w:airline_active = 1
  708              0.003904   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
  708   3.499016   0.006492   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>61_BufWritePostHook()
Called 503 times
Total time: 2047.076988
 Self time:   0.028100

count  total (s)   self (s)
  503   0.148815   0.007827     let buf = syntastic#util#fname2buf(a:fname)
  503   0.022763   0.011326     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWritePost, buffer ' . buf . ' = ' . string(a:fname))
  503 2046.902769   0.006306     call s:UpdateErrors(buf, 1, [])

FUNCTION  gitgutter#utility#restore_shell()
Called 10791 times
Total time:   0.566352
 Self time:   0.566352

count  total (s)   self (s)
10791              0.084875   if has('unix')
10791              0.077249     if exists('s:shell')
10791              0.127705       let &shell = s:shell
10791              0.098688       let &shellcmdflag = s:shellcmdflag
10791              0.089818       let &shellredir = s:shellredir
10791              0.024462     endif
10791              0.017204   endif

FUNCTION  ctrlp#utils#cachedir()
Called 193 times
Total time:   0.000770
 Self time:   0.000770

count  total (s)   self (s)
  193              0.000619 	retu s:cache_dir

FUNCTION  gitgutter#diff#run_diff()
Called 8076 times
Total time:  38.324496
 Self time:  16.440441

count  total (s)   self (s)
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
 8076              0.034057   let cmd = '('
                            
 8076   0.116936   0.078715   let bufnr = gitgutter#utility#bufnr()
 8076   0.315564   0.104313   let tracked = gitgutter#utility#getbufvar(bufnr, 'tracked', 0)  " i.e. tracked by git
 8076              0.022367   if !tracked
                                " Don't bother trying to realtime-diff an untracked file.
                                " NOTE: perhaps we should pull this guard up to the caller?
 6634              0.016397     if a:realtime
 5965            2172.172237       throw 'diff failed'
                                else
  669   0.024760   0.007251       let cmd .= g:gitgutter_git_executable.' ls-files --error-unmatch '.gitgutter#utility#shellescape(gitgutter#utility#filename()).' && ('
  669              0.000639     endif
  669              0.000422   endif
                            
 2111              0.004539   if a:realtime
 1192   0.254385   0.026252     let blob_name = g:gitgutter_diff_base.':'.gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
 1192              0.006461     let blob_file = s:temp_index
 1192              0.005668     let buff_file = s:temp_buffer
 1192   0.031183   0.017711     let extension = gitgutter#utility#extension()
 1192              0.006287     if !empty(extension)
 1192              0.008275       let blob_file .= '.'.extension
 1192              0.006525       let buff_file .= '.'.extension
 1192              0.002073     endif
 1192              0.012900     let cmd .= g:gitgutter_git_executable.' show '.blob_name.' > '.blob_file.' && '
                            
                                " Writing the whole buffer resets the '[ and '] marks and also the
                                " 'modified' flag (if &cpoptions includes '+').  These are unwanted
                                " side-effects so we save and restore the values ourselves.
 1192              0.015005     let modified      = getbufvar(bufnr, "&mod")
 1192              0.011178     let op_mark_start = getpos("'[")
 1192              0.008729     let op_mark_end   = getpos("']")
                            
 1192             15.431996     execute 'keepalt noautocmd silent write!' buff_file
                            
 1192              0.056372     call setbufvar(bufnr, "&mod", modified)
 1192              0.014372     call setpos("'[", op_mark_start)
 1192              0.008251     call setpos("']", op_mark_end)
 1192              0.003963   endif
                            
 2111              0.015282   let cmd .= g:gitgutter_git_executable
 2111              0.006651   if s:c_flag
 2111              0.010373     let cmd .= ' -c "diff.autorefreshindex=0"'
 2111              0.009368     let cmd .= ' -c "diff.noprefix=false"'
 2111              0.003407   endif
 2111              0.018381   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' '
                            
 2111              0.006328   if a:realtime
 1192              0.015237     let cmd .= ' -- '.blob_file.' '.buff_file
 1192              0.003337   else
  919   0.026044   0.008291     let cmd .= g:gitgutter_diff_base.' -- '.gitgutter#utility#shellescape(gitgutter#utility#filename())
  919              0.000833   endif
                            
 2111              0.010722   if !a:preserve_full_diff && s:grep_available
 2111   0.230737   0.046853     let cmd .= ' | '.s:grep_command.' '.gitgutter#utility#shellescape('^@@ ')
 2111              0.003135   endif
                            
 2111              0.009676   if (!a:preserve_full_diff && s:grep_available) || a:realtime
                                " grep exits with 1 when no matches are found; diff exits with 1 when
                                " differences are found.  However we want to treat non-matches and
                                " differences as non-erroneous behaviour; so we OR the command with one
                                " which always exits with success (0).
 2111              0.007617     let cmd .= ' || exit 0'
 2111              0.002671   endif
                            
 2111              0.005941   let cmd .= ')'
                            
 2111              0.004092   if !tracked
  669              0.001070     let cmd .= ')'
  669              0.000438   endif
                            
 2111   0.118123   0.019397   let cmd = gitgutter#utility#command_in_directory_of_file(cmd)
                            
 2111   0.032921   0.021745   if g:gitgutter_async && gitgutter#async#available() && !a:preserve_full_diff
 2111  21.110590   0.046659     call gitgutter#async#execute(cmd)
 2111              0.012521     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if gitgutter#utility#shell_error()
                                  " A shell error indicates the file is not tracked by git (unless something bizarre is going on).
                                  throw 'diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  airline#extensions#hunks#get_hunks()
Called 68 times
Total time:   0.012877
 Self time:   0.006546

count  total (s)   self (s)
   68              0.000348   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
   68              0.001064   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty'
                                return b:airline_hunks
                              endif
   68   0.006779   0.000448   let hunks = s:get_hunks()
   68              0.000144   let string = ''
   68              0.000161   if !empty(hunks)
  264              0.000468     for i in [0, 1, 2]
  198              0.000955       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
                                    let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
                                  endif
  198              0.000182     endfor
   66              0.000055   endif
   68              0.000188   let b:airline_hunks = string
   68              0.000187   let b:airline_changenr = b:changedtick
   68              0.000207   let s:airline_winwidth = winwidth(0)
   68              0.000100   return string

FUNCTION  gitgutter#sign#obsolete_gitgutter_signs_to_remove()
Called 1444 times
Total time:   1.371927
 Self time:   1.353391

count  total (s)   self (s)
 1444   0.012276   0.008457   let bufnr = gitgutter#utility#bufnr()
 1444              0.003480   let signs_to_remove = []  " list of [<id (number)>, ...]
 1444              0.002687   let remove_all_signs = 1
 1444   0.022521   0.007805   let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
131022              0.150659   for line_number in keys(old_gitgutter_signs)
129578              0.455768     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
  275              0.000935       call add(signs_to_remove, old_gitgutter_signs[line_number].id)
  275              0.000189     else
129303              0.174991       let remove_all_signs = 0
129303              0.079713     endif
129578              0.074571   endfor
 1444              0.004734   let s:remove_all_old_signs = remove_all_signs
 1444              0.002214   return signs_to_remove

FUNCTION  <SNR>118_buffer_type_name()
Called 1119 times
Total time:   0.042576
 Self time:   0.021273

count  total (s)   self (s)
 1119   0.009933   0.007186   let type = getbufvar(self.number(),'rails_cached_file_type')
 1119              0.001891   if type == ''
                                let type = self.calculate_file_type()
                              endif
 1119   0.026789   0.008233   return call('s:match_type',[type == '-' ? '' : type] + a:000)

FUNCTION  <SNR>74_TmuxSocket()
Called 5 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
                              " The socket path is the first value in the comma-separated list of $TMUX.
    5              0.000074   return split($TMUX, ',')[0]

FUNCTION  <SNR>118_resetomnicomplete()
Called 442 times
Total time:   0.009412
 Self time:   0.009412

count  total (s)   self (s)
  442              0.002859   if exists("+completefunc") && &completefunc == 'syntaxcomplete#Complete'
                                if exists("g:loaded_syntax_completion")
                                  " Ugly but necessary, until we have our own completion
                                  unlet g:loaded_syntax_completion
                                  silent! delfunction syntaxcomplete#Complete
                                endif
                              endif

FUNCTION  airline#parts#readonly()
Called 46949 times
Total time:   0.526080
 Self time:   0.526080

count  total (s)   self (s)
46949              0.222860   if &readonly && &modifiable && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
46949              0.122220     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>118_uniq()
Called 177 times
Total time:   0.056948
 Self time:   0.056948

count  total (s)   self (s)
  177              0.000402   let i = 0
  177              0.000273   let seen = {}
 4146              0.006807   while i < len(a:list)
 3969              0.013074     let key = string(a:list[i])
 3969              0.007728     if has_key(seen, key)
                                  call remove(a:list, i)
                                else
 3969              0.007311       let seen[key] = 1
 3969              0.004789       let i += 1
 3969              0.002529     endif
 3969              0.002503   endwhile
  177              0.000222   return a:list

FUNCTION  airline#util#system()
Called 4 times
Total time:   2.119022
 Self time:   2.119022

count  total (s)   self (s)
    4              0.000073     let l:config = { 'buf': '', 'on_stdout': function('s:system_job_handler'), }
    4              0.007227     let l:id = jobstart(a:cmd, l:config)
    4              0.000030     if l:id < 1
                                  return system(a:cmd)
                                endif
    4              2.111488     call jobwait([l:id])
    4              0.000095     return l:config.buf

FUNCTION  <SNR>302_AddBlockTag()
Called 5 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
                              "{{{
    5              0.000015   if !(a:id >= 2 && a:id < len(s:endtags))
                                echoerr 'AddBlockTag ' . a:id
                                return
                              endif
    5              0.000014   let s:indent_tags[a:tag] = a:id
    5              0.000006   if a:0 == 0
    3              0.000010     let s:indent_tags['/' . a:tag] = -a:id
    3              0.000010     let s:endtags[a:id] = "</" . a:tag . ">"
    3              0.000002   else
    2              0.000004     let s:indent_tags[a:1] = -a:id
    2              0.000004     let s:endtags[a:id] = a:1
    2              0.000001   endif

FUNCTION  syntastic#util#bufIsActive()
Called 940 times
Total time:   0.024772
 Self time:   0.024772

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
  940              0.003692     let buf = str2nr(a:buffer)
                            
  940              0.003459     if !bufloaded(buf) || !buflisted(buf)
                                    return 0
                                endif
                            
                                " get rid of hidden buffers
  940              0.004510     for tab in range(1, tabpagenr('$'))
  940              0.004246         if index(tabpagebuflist(tab), buf) >= 0
  940              0.001109             return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  <SNR>118_suffixes()
Called 137 times
Total time:   0.018044
 Self time:   0.006277

count  total (s)   self (s)
  137              0.001025   if a:type =~# '^stylesheets\=$\|^css$'
   40              0.000149     let exts = ['css', 'scss', 'css.scss', 'sass', 'css.sass']
   40              0.000499     call extend(exts, map(copy(exts), 'v:val.".erb"'))
   40              0.000068   elseif a:type =~# '^javascripts\=$\|^js$'
                                let exts = ['js', 'coffee', 'js.coffee', 'es6']
                                call extend(exts, map(copy(exts), 'v:val.".erb"'))
                                call extend(exts, ['ejs', 'eco', 'jst', 'jst.ejs', 'jst.eco'])
                              else
   97              0.000111     return []
                              endif
   40              0.000426   let suffixes = map(copy(exts), '".".v:val')
   40              0.000581   call extend(suffixes, map(copy(suffixes), '"/index".v:val'))
   40   0.012001   0.000234   return s:uniq(suffixes)

FUNCTION  ctrlp#utils#writecache()
Called 125 times
Total time:   2.134815
 Self time:   2.094002

count  total (s)   self (s)
  125   0.041749   0.001793 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
  125   2.091394   2.090537 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
  125              0.000798 	en

FUNCTION  emmet#getIndentation()
Called 79 times
Total time:   0.003807
 Self time:   0.003807

count  total (s)   self (s)
   79              0.000215   if a:0 > 0
   79              0.000222     let type = a:1
   79              0.000092   else
                                let type = emmet#getFileType()
                              endif
   79              0.000558   if has_key(s:emmet_settings, type) && has_key(s:emmet_settings[type], 'indentation')
   77              0.000319     let indent = s:emmet_settings[type].indentation
   77              0.000215   elseif has_key(s:emmet_settings, 'indentation')
                                let indent = s:emmet_settings.indentation
                              elseif has_key(s:emmet_settings.variables, 'indentation')
                                let indent = s:emmet_settings.variables.indentation
                              else
    2              0.000015     let sw = exists('*shiftwidth') ? shiftwidth() : &l:shiftwidth
    2              0.000016     let indent = (&l:expandtab || &l:tabstop !=# sw) ? repeat(' ', sw) : "\t"
    2              0.000003   endif
   79              0.000148   return indent

FUNCTION  nerdtree#has_opt()
Called 2298 times
Total time:   0.011358
 Self time:   0.011358

count  total (s)   self (s)
 2298              0.009989     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  <SNR>35_airline_refresh()
Called 9 times
Total time:   1.480213
 Self time:   0.002221

count  total (s)   self (s)
    9              0.000307   if !exists("#airline")
                                " disabled
                                return
                              endif
    9              0.000067   let nomodeline=''
    9              0.000081   if v:version > 703 || v:version == 703 && has("patch438")
    9              0.000037     let nomodeline = '<nomodeline>'
    9              0.000012   endif
    9   0.002374   0.001098   exe printf("silent doautocmd %s User AirlineBeforeRefresh", nomodeline)
    9   1.335905   0.000149   call airline#load_theme()
    9   0.140999   0.000039   call airline#update_statusline()

FUNCTION  <SNR>113__isDebugEnabled_smart()
Called 18024 times
Total time:   0.074732
 Self time:   0.074732

count  total (s)   self (s)
18024              0.063750     return and(g:syntastic_debug, a:level)

FUNCTION  <SNR>118_function()
Called 661 times
Total time:   0.024914
 Self time:   0.024914

count  total (s)   self (s)
  661              0.024332   return function(substitute(a:name, '^s:', matchstr(expand('<sfile>'),  '.*\zs<SNR>\d\+_'), ''))

FUNCTION  <SNR>118_AddSelectiveExpand()
Called 2323 times
Total time:   0.146828
 Self time:   0.091781

count  total (s)   self (s)
 2323   0.049760   0.020237   let expn  = s:gsub(s:gsub(a:expn        ,'[\"|]','\\&'),'\<','\\<Lt>')
 2323   0.044790   0.019266   let expn2 = s:gsub(s:gsub(a:0 ? a:1 : '','[\"|]','\\&'),'\<','\\<Lt>')
 2323              0.002926   if a:0
  772              0.013077     exe "inoreabbrev <buffer> <silent> ".a:abbr." <C-R>=<SID>selectiveexpand(".string(a:pat).",\"".expn."\",".string(a:abbr).",\"".expn2."\")<CR>"
  772              0.000674   else
 1551              0.022779     exe "inoreabbrev <buffer> <silent> ".a:abbr." <C-R>=<SID>selectiveexpand(".string(a:pat).",\"".expn."\",".string(a:abbr).")<CR>"
 1551              0.001302   endif

FUNCTION  gitgutter#utility#setbufvar()
Called 28459 times
Total time:   0.756108
 Self time:   0.756108

count  total (s)   self (s)
28459              0.240855   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
28459              0.265378   let dict[a:varname] = a:val
28459              0.206676   call setbufvar(a:buffer, 'gitgutter', dict)

FUNCTION  emmet#mergeConfig()
Called 127 times
Total time:   0.154772
 Self time:   0.154772

count  total (s)   self (s)
  127              0.000629   let [lhs, rhs] = [a:lhs, a:rhs]
  127              0.000319   if type(lhs) ==# 3
                                if type(rhs) ==# 3
                                  let lhs += rhs
                                  if len(lhs)
                                    call remove(lhs, 0, len(lhs)-1)
                                  endif
                                  for rhi in rhs
                                    call add(lhs, rhs[rhi])
                                  endfor
                                elseif type(rhs) ==# 4
                                  let lhs += map(keys(rhs), '{v:val : rhs[v:val]}')
                                endif
                              elseif type(lhs) ==# 4
  127              0.000239     if type(rhs) ==# 3
                                  for V in rhs
                                    if type(V) != 4
                                      continue
                                    endif
                                    for k in keys(V)
                                      let lhs[k] = V[k]
                                    endfor
                                  endfor
                                elseif type(rhs) ==# 4
 4654              0.006833       for key in keys(rhs)
 4527              0.011329         if type(rhs[key]) ==# 3
 2100              0.004405           if !has_key(lhs, key)
 2100              0.005012             let lhs[key] = []
 2100              0.001638           endif
 2100              0.004739           if type(lhs[key]) == 3
 2100              0.005805             let lhs[key] += rhs[key]
 2100              0.003494           elseif type(lhs[key]) == 4
                                        for k in keys(rhs[key])
                                          let lhs[key][k] = rhs[key][k]
                                        endfor
                                      endif
 2100              0.003091         elseif type(rhs[key]) ==# 4
   25              0.000055           if has_key(lhs, key)
                                        call emmet#mergeConfig(lhs[key], rhs[key])
                                      else
   25              0.000065             let lhs[key] = rhs[key]
   25              0.000020           endif
   25              0.000016         else
 2402              0.007150           let lhs[key] = rhs[key]
 2402              0.002066         endif
 4527              0.003481       endfor
  127              0.000108     endif
  127              0.000092   endif

FUNCTION  <SNR>65_buffer_getvar()
Called 850 times
Total time:   0.005509
 Self time:   0.005509

count  total (s)   self (s)
  850              0.004909   return getbufvar(self['#'],a:var)

FUNCTION  airline#extensions#tabline#buffers#clickbuf()
Called 1 time
Total time:   0.109819
 Self time:   0.048585

count  total (s)   self (s)
                                " Clickable buffers
                                " works only in recent NeoVim with has('tablineat')
                            
                                " single mouse button click without modifiers pressed
    1              0.000045     if a:clicks == 1 && a:modifiers !~# '[^ ]'
    1              0.000009       if a:button is# 'l'
                                    " left button - switch to buffer
    1   0.109715   0.048481         silent execute 'buffer' a:minwid
    1              0.000002       elseif a:button is# 'm'
                                    " middle button - delete buffer
                            
                                    if get(g:, 'airline#extensions#tabline#middle_click_preserves_windows', 0) == 0
                                      " just simply delete the clicked buffer. This will cause windows
                                      " associated with the clicked buffer to be closed.
                                      silent execute 'bdelete' a:minwid
                                    else
                                      " find windows displaying the clicked buffer and open an new
                                      " buffer in them.
                                      let current_window = bufwinnr("%")
                                      let window_number = bufwinnr(a:minwid)
                                      let last_window_visited = -1
                            
                                      " Set to 1 if the clicked buffer was open in any windows.
                                      let buffer_in_window = 0
                            
                                      " Find the next window with the clicked buffer open. If bufwinnr()
                                      " returns the same window number, this is because we clicked a new
                                      " buffer, and then tried editing a new buffer. Vim won't create a
                                      " new empty buffer for the same window, so we get the same window
                                      " number from bufwinnr(). In this case we just give up and don't
                                      " delete the buffer.
                                      " This could be made cleaner if we could check if the clicked buffer
                                      " is a new buffer, but I don't know if there is a way to do that.
                                      while window_number != -1 && window_number != last_window_visited
                                        let buffer_in_window = 1
                                        silent execute window_number . 'wincmd w'
                                        silent execute 'enew'
                                        let last_window_visited = window_number
                                        let window_number = bufwinnr(a:minwid)
                                      endwhile
                                      silent execute current_window . 'wincmd w'
                                      if window_number != last_window_visited || buffer_in_window == 0
                                        silent execute 'bdelete' a:minwid
                                      endif
                                    endif
                                  endif
    1              0.000001     endif

FUNCTION  emmet#expandDollarExpr()
Called 27 times
Total time:   0.007439
 Self time:   0.000154

count  total (s)   self (s)
   27   0.007419   0.000134   return emmet#reExpandDollarExpr(a:expand, 0)

FUNCTION  <SNR>112_build_sections()
Called 2965 times
Total time:   0.799085
 Self time:   0.176919

count  total (s)   self (s)
15340              0.022481   for key in a:keys
12375              0.039810     if (key == 'warning' || key == 'error') && !a:context.active
 2350              0.002667       continue
                                endif
10025   0.679975   0.057809     call s:add_section(a:builder, a:context, key)
10025              0.008582   endfor

FUNCTION  <SNR>126_lash()
Called 347 times
Total time:   0.005553
 Self time:   0.005553

count  total (s)   self (s)
  347              0.005163 	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''

FUNCTION  <SNR>78_ParseSkip()
Called 6 times
Total time:   0.000280
 Self time:   0.000280

count  total (s)   self (s)
    6              0.000031   let skip = a:str
    6              0.000034   if skip[1] == ":"
    5              0.000018     if skip[0] == "s"
    5              0.000039       let skip = "synIDattr(synID(line('.'),col('.'),1),'name') =~? '" . strpart(skip,2) . "'"
    5              0.000013     elseif skip[0] == "S"
                                  let skip = "synIDattr(synID(line('.'),col('.'),1),'name') !~? '" . strpart(skip,2) . "'"
                                elseif skip[0] == "r"
                                  let skip = "strpart(getline('.'),0,col('.'))=~'" . strpart(skip,2). "'"
                                elseif skip[0] == "R"
                                  let skip = "strpart(getline('.'),0,col('.'))!~'" . strpart(skip,2). "'"
                                endif
    5              0.000005   endif
    6              0.000013   return skip

FUNCTION  airline#extensions#whitespace#check()
Called 68 times
Total time:   0.023754
 Self time:   0.008700

count  total (s)   self (s)
   68              0.000339   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   68              0.000501   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
                            
   68              0.000253   if !exists('b:airline_whitespace_check')
    5              0.000013     let b:airline_whitespace_check = ''
    5              0.000035     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    5              0.000009     let trailing = 0
    5              0.000016     if index(checks, 'trailing') > -1
    5              0.000007       try
    5              0.000019         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    5              0.000490         let trailing = search(regexp, 'nw')
    5              0.000009       catch
                                    echomsg 'airline#whitespace: error occured evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
    5              0.000004     endif
                            
    5              0.000009     let mixed = 0
    5              0.000009     let check = 'indent'
    5              0.000056     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    5   0.009796   0.000063       let mixed = s:check_mixed_indent()
    5              0.000018     endif
                            
    5              0.000015     let mixed_file = ''
    5              0.000011     let check = 'mixed-indent-file'
    5              0.000068     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    5   0.002251   0.000059       let mixed_file = s:check_mixed_indent_file()
    5              0.000004     endif
                            
    5              0.000008     let long = 0
    5              0.000016     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    5              0.000014     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
    5              0.000015       let b:airline_whitespace_check = s:symbol
    5              0.000012       if strlen(s:symbol) > 0
    5              0.000017         let space = (g:airline_symbols.space)
    5              0.000004       else
                                    let space = ''
                                  endif
                            
    5              0.000006       if s:show_message
    5              0.000006         if trailing != 0
    5              0.000022           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
    5              0.000041           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
    5              0.000004         endif
    5              0.000006         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
    5              0.000005         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
    5              0.000011         if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
    5              0.000003       endif
    5              0.000003     endif
    5              0.000003   endif
   68   0.003546   0.000418   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  airline#extensions#tabline#formatters#default#format()
Called 60970 times
Total time:   4.541826
 Self time:   3.295718

count  total (s)   self (s)
60970              0.279145   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
60970              0.098402   let _ = ''
                            
60970              0.196279   let name = bufname(a:bufnr)
60970              0.130159   if empty(name)
                                let _ .= '[No Name]'
                              else
60970              0.082784     if s:fnamecollapse
60970              1.013862       let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
60970              0.068796     else
                                  let _ .= fnamemodify(name, fmod)
                                endif
60970              0.257949     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
60970              0.043159   endif
                            
60970   1.694466   0.448357   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  <SNR>125_usrign()
Called 1232 times
Total time:   0.067918
 Self time:   0.067918

count  total (s)   self (s)
 1232              0.066833 	retu s:igntype == 1 ? a:item =~ s:usrign : s:igntype == 4 && has_key(s:usrign, a:type) && s:usrign[a:type] != '' ? a:item =~ s:usrign[a:type] : 0

FUNCTION  <SNR>41_chop()
Called 18 times
Total time:   0.000477
 Self time:   0.000477

count  total (s)   self (s)
   18              0.000377 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
   18              0.000044 	retu a:mrufs

FUNCTION  nerdtree#exec()
Called 102 times
Total time:   0.339103
 Self time:   0.003532

count  total (s)   self (s)
  102              0.000616     let old_ei = &ei
  102              0.000927     set ei=BufEnter,BufLeave,VimEnter
  102   0.336690   0.001120     exec a:cmd
  102              0.000609     let &ei = old_ei

FUNCTION  <SNR>125_nocache()
Called 118 times
Total time:   0.003613
 Self time:   0.003613

count  total (s)   self (s)
  118              0.000407 	if !s:caching
                            		retu 1
                            	elsei s:caching > 1
                            		if !( exists(s:ccex) && !{s:ccex} ) || has_key(s:ficounts, s:dyncwd)
                            			retu get(s:ficounts, s:dyncwd, [0, 0])[0] < s:caching
                            		elsei a:0 && filereadable(a:1)
                            			retu len(ctrlp#utils#readfile(a:1)) < s:caching
                            		en
                            		retu 1
                            	en
  118              0.000155 	retu 0

FUNCTION  <SNR>65_can_diffoff()
Called 227 times
Total time:   0.003198
 Self time:   0.003198

count  total (s)   self (s)
  227              0.002595   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  emmet#lang#html#parseIntoTree()
Called 26 times
Total time:   0.214259
 Self time:   0.048936

count  total (s)   self (s)
   26              0.000369   let abbr = a:abbr
   26              0.000095   let type = a:type
                            
   26   0.000351   0.000244   let settings = emmet#getSettings()
   26              0.000115   if !has_key(settings, type)
                                let type = 'html'
                              endif
   26              0.000150   if len(type) == 0 | let type = 'html' | endif
                            
   26   0.001470   0.000208   let indent = emmet#getIndentation(type)
   26              0.000579   let pmap = {'p': 'span','ul': 'li','ol': 'li','table': 'tr','tr': 'td','tbody': 'tr','thead': 'tr','tfoot': 'tr','colgroup': 'col','select': 'option','optgroup': 'option','audio': 'source','video': 'source','object': 'param','map': 'area'}
                            
   26              0.000749   let inlineLevel = split('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var',',')
                            
   26   0.006665   0.000311   let custom_expands = emmet#getResource(type, 'custom_expands', {})
   26              0.000138   if empty(custom_expands) && has_key(settings, 'custom_expands')
   26              0.000101     let custom_expands = settings['custom_expands']
   26              0.000027   endif
                            
                              " try 'foo' to (foo-x)
   26   0.019052   0.000262   let rabbr = emmet#getExpandos(type, abbr)
   26              0.000073   if rabbr == abbr
                                " try 'foo+(' to (foo-x)
   26              0.001054     let rabbr = substitute(abbr, '\%(+\|^\)\([a-zA-Z][a-zA-Z0-9+]\+\)+\([(){}>]\|$\)', '\="(".emmet#getExpandos(type, submatch(1)).")".submatch(2)', 'i')
   26              0.000044   endif
   26              0.000065   let abbr = rabbr
                            
   26   0.000750   0.000212   let root = emmet#newNode()
   26              0.000072   let parent = root
   26              0.000051   let last = root
   26              0.000049   let pos = []
   51              0.000132   while len(abbr)
                                " parse line
   25              0.002231     let match = matchstr(abbr, s:mx)
   25              0.001832     let str = substitute(match, s:mx, '\0', 'ig')
   25              0.001728     let operator = substitute(match, s:mx, '\1', 'ig')
   25              0.001564     let block_start = substitute(match, s:mx, '\2', 'ig')
   25              0.001563     let tag_name = substitute(match, s:mx, '\3', 'ig')
   25              0.001541     let attributes = substitute(match, s:mx, '\4', 'ig')
   25              0.001449     let value = substitute(match, s:mx, '\5', 'ig')
   25              0.001408     let basevalue = substitute(match, s:mx, '\6', 'ig')
   25              0.001490     let multiplier = 0 + substitute(match, s:mx, '\7', 'ig')
   25              0.001414     let block_end = substitute(match, s:mx, '\8', 'ig')
   25              0.000062     let custom = ''
   25              0.000052     let important = 0
   25              0.000077     if len(str) == 0
                                  break
                                endif
   25              0.000097     if tag_name =~# '^#'
                                  let attributes = tag_name . attributes
                                  let tag_name = ''
                                endif
   25              0.000130     if tag_name =~# '[^!]!$'
                                  let tag_name = tag_name[:-2]
                                  let important = 1
                                endif
   25              0.000076     if tag_name =~# '^\.'
                                  let attributes = tag_name . attributes
                                  let tag_name = ''
                                endif
   25              0.000094     if tag_name =~# '^\[.*\]$'
                                  let attributes = tag_name . attributes
                                  let tag_name = ''
                                endif
                            
   50              0.000157     for k in keys(custom_expands)
   25              0.000194       if tag_name =~ k
                                    let custom = tag_name
                                    let tag_name = ''
                                    break
                                  endif
   25              0.000122     endfor
                            
   25              0.000070     if empty(tag_name)
                                  let pname = len(parent.child) > 0 ? parent.child[0].name : ''
                                  if !empty(pname) && has_key(pmap, pname)
                                    let tag_name = pmap[pname]
                                  elseif !empty(pname) && index(inlineLevel, pname) > -1
                                    let tag_name = 'span'
                                  elseif len(parent.child) == 0 || len(custom) == 0
                                    let tag_name = 'div'
                                  else
                                    let tag_name = custom
                                  endif
                                endif
                            
   25              0.000152     let basedirect = basevalue[1] ==# '-' ? -1 : 1
   25              0.000136     let basevalue = 0 + abs(basevalue[1:])
   25              0.000134     if multiplier <= 0 | let multiplier = 1 | endif
                            
                                " make default node
   25   0.000560   0.000170     let current = emmet#newNode()
                            
   25              0.000086     let current.name = tag_name
   25              0.000071     let current.important = important
                            
                                " aliases
   25   0.040697   0.000323     let aliases = emmet#getResource(type, 'aliases', {})
   25              0.000087     if has_key(aliases, tag_name)
                                  let current.name = aliases[tag_name]
                                endif
                            
   25   0.003696   0.000273     let use_pipe_for_cursor = emmet#getResource(type, 'use_pipe_for_cursor', 1)
                            
                                " snippets
   25   0.022415   0.000256     let snippets = emmet#getResource(type, 'snippets', {})
   25              0.000076     if !empty(snippets)
   25              0.000068       let snippet_name = tag_name
   25              0.000082       if has_key(snippets, snippet_name)
                                    let snippet = snippet_name
                                    while has_key(snippets, snippet)
                                      let snippet = snippets[snippet]
                                    endwhile
                                    if use_pipe_for_cursor
                                      let snippet = substitute(snippet, '|', '${cursor}', 'g')
                                    endif
                                    " just redirect to expanding
                                    if type == 'html' && snippet !~ '^\s*[{\[<]'
                                       return emmet#lang#html#parseIntoTree(snippet, a:type)
                                    endif
                                    let lines = split(snippet, "\n", 1)
                                    call map(lines, 'substitute(v:val, "\\(    \\|\\t\\)", escape(indent, "\\\\"), "g")')
                                    let current.snippet = join(lines, "\n")
                                    let current.name = ''
                                  endif
   25              0.000019     endif
                            
   50              0.000119     for k in keys(custom_expands)
   25              0.000196       if tag_name =~# k
                                    let current.snippet = '${' . (empty(custom) ? tag_name : custom) . '}'
                                    let current.name = ''
                                    break
                                  elseif custom =~# k
                                    let current.snippet = '${' . custom . '}'
                                    let current.name = ''
                                    break
                                  endif
   25              0.000022     endfor
                            
                                " default_attributes
   25   0.072261   0.000334     let default_attributes = emmet#getResource(type, 'default_attributes', {})
   25              0.000062     if !empty(default_attributes)
   73              0.000131       for pat in [current.name, tag_name]
   49              0.000114         if has_key(default_attributes, pat)
    1              0.000002           if type(default_attributes[pat]) == 4
                                        let a = default_attributes[pat]
                                        let current.attrs_order += keys(a)
                                        if use_pipe_for_cursor
                                          for k in keys(a)
                                            let current.attr[k] = len(a[k]) ? substitute(a[k], '|', '${cursor}', 'g') : '${cursor}'
                                          endfor
                                        else
                                          for k in keys(a)
                                            let current.attr[k] = a[k]
                                          endfor
                                        endif
                                      else
    2              0.000003             for a in default_attributes[pat]
    1              0.000003               let current.attrs_order += keys(a)
    1              0.000001               if use_pipe_for_cursor
    2              0.000003                 for k in keys(a)
    1              0.000004                   let current.attr[k] = len(a[k]) ? substitute(a[k], '|', '${cursor}', 'g') : '${cursor}'
    1              0.000001                 endfor
    1              0.000001               else
                                            for k in keys(a)
                                              let current.attr[k] = a[k]
                                            endfor
                                          endif
    1              0.000001             endfor
    1              0.000001           endif
    1              0.000002           if has_key(settings.html.default_attributes, current.name)
    1              0.000005             let current.name = substitute(current.name, ':.*$', '', '')
    1              0.000001           endif
    1              0.000001           break
                                    endif
   48              0.000031       endfor
   25              0.000016     endif
                            
                                " parse attributes
   25              0.000054     if len(attributes)
                                  let attr = attributes
                                  while len(attr)
                                    let item = matchstr(attr, '\(\%(\%(#[{}a-zA-Z0-9_\-\$]\+\)\|\%(\[\%("[^"]*"\|[^"\]]*\)\+\]\)\|\%(\.[{}a-zA-Z0-9_\-\$]\+\)*\)\)')
                                    if g:emmet_debug > 1
                                      echomsg 'attr=' . item
                                    endif
                                    if len(item) == 0
                                      break
                                    endif
                                    if item[0] ==# '#'
                                      let current.attr.id = item[1:]
                                    endif
                                    if item[0] ==# '.'
                                      let current.attr.class = substitute(item[1:], '\.', ' ', 'g')
                                    endif
                                    if item[0] ==# '['
                                      let atts = item[1:-2]
                                      if matchstr(atts, '^\s*\zs[0-9a-zA-Z_\-:]\+\(="[^"]*"\|=''[^'']*''\|=[^ ''"]\+\)') ==# ''
                                        let ks = []
                            			if has_key(default_attributes, current.name)
                                          let dfa = default_attributes[current.name]
                                          let ks = type(dfa) == 3 ? len(dfa) > 0 ? keys(dfa[0]) : [] : keys(dfa)
                                        endif
                                        if len(ks) == 0 && has_key(default_attributes, current.name . ':src')
                                          let dfa = default_attributes[current.name . ':src']
                                          let ks = type(dfa) == 3 ? len(dfa) > 0 ? keys(dfa[0]) : [] : keys(dfa)
                                        endif
                                        if len(ks) > 0
                                          let current.attr[ks[0]] = atts
                                        else
                                          let current.attr[atts] = ''
                                        endif
                                      else
                                        while len(atts)
                                          let amat = matchstr(atts, '^\s*\zs\([0-9a-zA-Z-:]\+\%(={{.\{-}}}\|="[^"]*"\|=''[^'']*''\|=[^ ''"]\+\|[^ ''"\]]*\)\{0,1}\)')
                                          if len(amat) == 0
                                            break
                                          endif
                                          let key = split(amat, '=')[0]
                                          let Val = amat[len(key)+1:]
                                          if key =~# '\.$' && Val ==# ''
                                            let key = key[:-2]
                                            unlet Val
                                            let Val = function('emmet#types#true')
                                          elseif Val =~# '^["'']'
                                            let Val = Val[1:-2]
                                          endif
                                          let current.attr[key] = Val
                                          if index(current.attrs_order, key) == -1
                                            let current.attrs_order += [key]
                                          endif
                                          let atts = atts[stridx(atts, amat) + len(amat):]
                                          unlet Val
                                        endwhile
                                      endif
                                    endif
                                    let attr = substitute(strpart(attr, len(item)), '^\s*', '', '')
                                  endwhile
                                endif
                            
                                " parse text
   25              0.000130     if tag_name =~# '^{.*}$'
                                  let current.name = ''
                                  let current.value = tag_name
                                else
   25              0.000055       let current.value = value
   25              0.000019     endif
   25              0.000047     let current.basedirect = basedirect
   25              0.000043     let current.basevalue = basevalue
   25              0.000053     let current.multiplier = multiplier
                            
                                " parse step inside/outside
   25              0.000046     if !empty(last)
   25              0.000066       if operator =~# '>'
                                    unlet! parent
                                    let parent = last
                                    let current.parent = last
                                    let current.pos = last.pos + 1
                                  else
   25              0.000054         let current.parent = parent
   25              0.000047         let current.pos = last.pos
   25              0.000018       endif
   25              0.000014     else
                                  let current.parent = parent
                                  let current.pos = 1
                                endif
   25              0.000103     if operator =~# '[<^]'
                                  for c in range(len(operator))
                                    let tmp = parent.parent
                                    if empty(tmp)
                                      break
                                    endif
                                    let parent = tmp
                                    let current.parent = tmp
                                  endfor
                                endif
                            
   25              0.000079     call add(parent.child, current)
   25              0.000042     let last = current
                            
                                " parse block
   25              0.000105     if block_start =~# '('
                                  if operator =~# '>'
                                    let last.pos += 1
                                  endif
                                  let last.block = 1
                                  for n in range(len(block_start))
                                    let pos += [last.pos]
                                  endfor
                                endif
   25              0.000064     if block_end =~# ')'
                                  for n in split(substitute(substitute(block_end, ' ', '', 'g'), ')', ',),', 'g'), ',')
                                    if n ==# ')'
                                      if len(pos) > 0 && last.pos >= pos[-1]
                                        for c in range(last.pos - pos[-1])
                                          let tmp = parent.parent
                                          if !has_key(tmp, 'parent')
                                            break
                                          endif
                                          let parent = tmp
                                        endfor
                                        if len(pos) > 0
                                          call remove(pos, -1)
                                        endif
                                        let last = parent
                                        let last.pos += 1
                                      endif
                                    elseif len(n)
                                      let st = 0
                                      for nc in range(len(last.child))
                                        if last.child[nc].block
                                          let st = nc
                                          break
                                        endif
                                      endfor
                                      let cl = last.child[st :]
                                      let cls = []
                                      for c in range(n[1:])
                                        for cc in cl
                                          if cc.multiplier > 1
                                            let cc.basedirect = c + 1
                                          else
                                            let cc.basevalue = c + 1
                                          endif
                                        endfor
                                        let cls += deepcopy(cl)
                                      endfor
                                      if st > 0
                                        let last.child = last.child[:st-1] + cls
                                      else
                                        let last.child = cls
                                      endif
                                    endif
                                  endfor
                                endif
   25              0.000199     let abbr = abbr[stridx(abbr, match) + len(match):]
   25              0.000052     if abbr == '/'
                                  let current.empty = 1
                                endif
                            
   25              0.000049     if g:emmet_debug > 1
                                  echomsg 'str='.str
                                  echomsg 'block_start='.block_start
                                  echomsg 'tag_name='.tag_name
                                  echomsg 'operator='.operator
                                  echomsg 'attributes='.attributes
                                  echomsg 'value='.value
                                  echomsg 'basevalue='.basevalue
                                  echomsg 'multiplier='.multiplier
                                  echomsg 'block_end='.block_end
                                  echomsg 'abbr='.abbr
                                  echomsg 'pos='.string(pos)
                                  echomsg '---'
                                endif
   25              0.000021   endwhile
   26              0.000041   return root

FUNCTION  <SNR>125_PrtSelectMove()
Called 33 times
Total time:   0.004381
 Self time:   0.004381

count  total (s)   self (s)
   33              0.000664 	let wht = winheight(0)
   33              0.000856 	let dirs = {'t': 'gg','b': 'G','j': 'j','k': 'k','u': wht.'k','d': wht.'j'}
   33              0.001492 	exe 'keepj norm!' dirs[a:dir]
   33              0.000599 	if s:nolim != 1 | let s:cline = line('.') | en
   33              0.000446 	if line('$') > winheight(0) | cal s:BuildPrompt(0) | en

FUNCTION  <SNR>13_LoadFTPlugin()
Called 106 times
Total time:  11.678347
 Self time:   5.232420

count  total (s)   self (s)
  106              0.001227     if exists("b:undo_ftplugin")
  103              0.007510       exe b:undo_ftplugin
  103              0.000643       unlet! b:undo_ftplugin b:did_ftplugin
  103              0.000171     endif
                            
  106              0.001177     let s = expand("<amatch>")
  106              0.000465     if s != ""
  106              0.001883       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
  212              0.001778       for name in split(s, '\.')
  106  11.658755   5.212827 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
  106              0.000915       endfor
  106              0.000166     endif

FUNCTION  <SNR>56__set_screen_column()
Called 60 times
Total time:   0.001571
 Self time:   0.001571

count  total (s)   self (s)
   60              0.000184     if !has_key(a:item, 'scol')
   60              0.000174         let col = get(a:item, 'col', 0)
   60              0.000143         if col != 0 && get(a:item, 'vcol', 0) == 0
                                        let buf = str2nr(a:item['bufnr'])
                                        try
                                            let line = getbufline(buf, a:item['lnum'])[0]
                                        catch  /\m^Vim\%((\a\+)\)\=:E684/
                                            let line = ''
                                        endtry
                                        let a:item['scol'] = syntastic#util#screenWidth(strpart(line, 0, col), getbufvar(buf, '&tabstop'))
                                    else
   60              0.000125             let a:item['scol'] = col
   60              0.000043         endif
   60              0.000033     endif

FUNCTION  <SNR>274_build_path()
Called 1 time
Total time:   0.000171
 Self time:   0.000171

count  total (s)   self (s)
    1              0.000122   let path = join(map(copy(a:path), 'v:val ==# "." ? "" : v:val'), ',')
    1              0.000029   if &g:path !~# '\v^\.%(,/%(usr|emx)/include)=,,$'
                                let path = substitute(&g:path,',,$',',','') . ',' . path
                              endif
    1              0.000004   return path

FUNCTION  <SNR>99_check_mixed_indent()
Called 5 times
Total time:   0.009733
 Self time:   0.009733

count  total (s)   self (s)
    5              0.000024   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    5              0.000009   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    5              0.009638     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>125_getenv()
Called 109 times
Total time:   0.078778
 Self time:   0.057446

count  total (s)   self (s)
  109              0.007693 	let [s:cwd, s:winres] = [getcwd(), [winrestcmd(), &lines, winnr('$')]]
  109              0.001487 	let [s:crword, s:crnbword] = [expand('<cword>', 1), expand('<cWORD>', 1)]
  109              0.030511 	let [s:crgfile, s:crline] = [expand('<cfile>', 1), getline('.')]
  109              0.001385 	let [s:winmaxh, s:crcursor] = [min([s:mw_max, &lines]), getpos('.')]
  109   0.022726   0.001944 	let [s:crbufnr, s:crvisual] = [bufnr('%'), s:lastvisual()]
  109              0.007788 	let s:crfile = bufname('%') == '' ? '['.s:crbufnr.'*No Name]' : expand('%:p', 1)
  109              0.004902 	let s:crfpath = expand('%:p:h', 1)
  109   0.001917   0.001368 	let s:mrbs = ctrlp#mrufiles#bufs()

FUNCTION  ctrlp#getcline()
Called 77 times
Total time:   0.002183
 Self time:   0.002183

count  total (s)   self (s)
   77              0.000889 	let [linenr, offset] = [line('.'), ( s:offset > 0 ? s:offset : 0 )]
   77              0.000958 	retu !empty(s:lines) && !( offset && linenr <= offset ) ? s:lines[linenr - 1 - offset] : ''

FUNCTION  airline#highlighter#exec()
Called 992215 times
Total time: 223.112866
 Self time:  64.281928

count  total (s)   self (s)
992215              1.821180   if pumvisible()
                                return
                              endif
992215              1.759323   let colors = a:colors
992215              1.271566   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
992215 112.736442   4.646693   let old_hi = airline#highlighter#get_highlight(a:group)
992215              2.075699   if len(colors) == 4
242029              0.577126     call add(colors, '')
242029              0.175570   endif
992215              1.468269   if g:airline_gui_mode ==# 'gui'
992215              4.590754     let new_hi = [colors[0], colors[1], '', '', colors[4]]
992215              0.805839   else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
                              endif
992215  27.932344   4.423356   let colors = s:CheckDefined(colors)
992215  18.114350   4.937386   if old_hi != new_hi || !s:hl_group_exists(a:group)
296845  22.068354   8.013117     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg=', ''), s:Get(colors, 1, 'guibg=', ''), s:Get(colors, 2, 'ctermfg=', ''), s:Get(colors, 3, 'ctermbg=', ''), s:Get(colors, 4, 'gui=', ''), s:Get(colors, 4, 'cterm=', ''), s:Get(colors, 4, 'term=', ''))
296845              3.854531     exe cmd
296845              0.246227   endif

FUNCTION  <SNR>125_walker()
Called 2108 times
Total time:   0.010354
 Self time:   0.010354

count  total (s)   self (s)
 2108              0.009116 	retu a:d >= 0 ? a:p < a:m ? a:p + a:d : 0 : a:p > 0 ? a:p + a:d : a:m

FUNCTION  <SNR>35_init()
Called 553 times
Total time:   0.003746
 Self time:   0.003746

count  total (s)   self (s)
  553              0.001735   if s:airline_initialized
  553              0.000836     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  <SNR>125_iscmdwin()
Called 109 times
Total time:   0.013992
 Self time:   0.013992

count  total (s)   self (s)
  109              0.001370 	let ermsg = v:errmsg
  109              0.004919 	sil! noa winc p
  109              0.002404 	sil! noa winc p
  109              0.001588 	let [v:errmsg, ermsg] = [ermsg, v:errmsg]
  109              0.002681 	retu ermsg =~ '^E11:'

FUNCTION  gitgutter#diff#process_removed()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000002   if a:to_line == 0
    1              0.000004     call add(a:modifications, [1, 'removed_first_line'])
    1              0.000001   else
                                call add(a:modifications, [a:to_line, 'removed'])
                              endif

FUNCTION  GetHamlIndent()
Called 215 times
Total time:   0.241572
 Self time:   0.241572

count  total (s)   self (s)
  215              0.005294   let lnum = prevnonblank(v:lnum-1)
  215              0.001034   if lnum == 0
    9              0.000036     return 0
                              endif
  206              0.006047   let line = substitute(getline(lnum),'\s\+$','','')
  206              0.004895   let cline = substitute(substitute(getline(v:lnum),'\s\+$','',''),'^\s\+','','')
  206              0.001355   let lastcol = strlen(line)
  206              0.002220   let line = substitute(line,'^\s\+','','')
  206              0.001054   let indent = indent(lnum)
  206              0.000901   let cindent = indent(v:lnum)
  206              0.001744   let sw = exists('*shiftwidth') ? shiftwidth() : &sw
  206              0.002783   if cline =~# '\v^-\s*%(elsif|else|when)>'
                                let indent = cindent < indent ? cindent : indent - sw
                              endif
  206              0.001024   let increase = indent + sw
  206              0.000747   if indent == indent(lnum)
  206              0.000872     let indent = cindent <= indent ? -1 : increase
  206              0.000259   endif
                            
  206              0.160684   let group = synIDattr(synID(lnum,lastcol,1),'name')
                            
  206              0.001498   if line =~ '^!!!'
                                return indent
                              elseif line =~ '^/\%(\[[^]]*\]\)\=$'
                                return increase
                              elseif group == 'hamlFilter'
    2              0.000007     return increase
                              elseif line =~ '^'.s:tag.'[&!]\=[=~-]\s*\%(\%(if\|else\|elsif\|unless\|case\|when\|while\|until\|for\|begin\|module\|class\|def\)\>\%(.*\<end\>\)\@!\|.*do\%(\s*|[^|]*|\)\=\s*$\)'
   11              0.000037     return increase
                              elseif line =~ '^'.s:tag.'[&!]\=[=~-].*,\s*$'
                                return increase
                              elseif line == '-#'
                                return increase
                              elseif group =~? '\v^(hamlSelfCloser)$' || line =~? '^%\v%('.g:haml_self_closing_tags.')>'
                                return indent
                              elseif group =~? '\v^%(hamlTag|hamlAttributesDelimiter|hamlObjectDelimiter|hamlClass|hamlId|htmlTagName|htmlSpecialTagName)$'
   67              0.000219     return increase
                              elseif synIDattr(synID(v:lnum,1,1),'name') ==? 'hamlRubyFilter'
                                return GetRubyIndent()
                              else
  126              0.000299     return indent
                              endif

FUNCTION  <SNR>99_check_mixed_indent_file()
Called 5 times
Total time:   0.002192
 Self time:   0.002192

count  total (s)   self (s)
    5              0.000033   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    5              0.000023   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
    5              0.000009     let head_spc = '\v(^ +)'
    5              0.000004   endif
    5              0.000680   let indent_tabs = search('\v(^\t+)', 'nw')
    5              0.001376   let indent_spc  = search(head_spc, 'nw')
    5              0.000014   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    5              0.000006     return ''
                              endif

FUNCTION  emmet#toString()
Called 25 times
Total time:   0.022807
 Self time:   0.006748

count  total (s)   self (s)
   25              0.000189   let current = a:1
   25              0.000083   if a:0 > 1
   25              0.000055     let type = a:2
   25              0.000022   else
                                let type = &filetype
                              endif
   25              0.000138   if len(type) ==# 0 | let type = 'html' | endif
   25              0.000031   if a:0 > 2
   25              0.000046     let inline = a:3
   25              0.000019   else
                                let inline = 0
                              endif
   25              0.000026   if a:0 > 3
   25              0.000056     if type(a:4) ==# 1
                                  let filters = split(a:4, '\s*,\s*')
                                else
   25              0.000045       let filters = a:4
   25              0.000019     endif
   25              0.000015   else
                                let filters = ['html']
                              endif
   25              0.000026   if a:0 > 4
   25              0.000046     let group_itemno = a:5
   25              0.000017   else
                                let group_itemno = 0
                              endif
   25              0.000025   if a:0 > 5
   25              0.000042     let indent = a:6
   25              0.000017   else
                                let indent = ''
                              endif
                            
   25   0.003042   0.000190   let dollar_expr = emmet#getResource(type, 'dollar_expr', 1)
   25              0.000040   let itemno = 0
   25              0.000034   let str = ''
   25   0.001063   0.000135   let rtype = emmet#lang#type(type)
   50              0.000100   while itemno < current.multiplier
   25              0.000052     if len(current.name)
   25              0.000037       if current.multiplier ==# 1
   25   0.012643   0.000363         let inner = emmet#lang#{rtype}#toString(s:emmet_settings, current, type, inline, filters, s:itemno(group_itemno, current), indent)
   25              0.000019       else
                                    let inner = emmet#lang#{rtype}#toString(s:emmet_settings, current, type, inline, filters, s:itemno(itemno, current), indent)
                                  endif
   25              0.000036       if current.multiplier > 1
                                    let inner = substitute(inner, '\$#', '$line'.(itemno+1).'$', 'g')
                                  endif
   25              0.000053       let str .= inner
   25              0.000017     else
                                  let snippet = current.snippet
                                  if len(snippet) ==# 0
                                    let snippets = emmet#getResource(type, 'snippets', {})
                                    if !empty(snippets) && has_key(snippets, 'emmet_snippet')
                                      let snippet = snippets['emmet_snippet']
                                    endif
                                  endif
                                  if len(snippet) > 0
                                    let tmp = snippet
                                    let tmp = substitute(tmp, '\${emmet_name}', current.name, 'g')
                                    let snippet_node = emmet#newNode()
                                    let snippet_node.value = '{'.tmp.'}'
                                    let snippet_node.important = current.important
                                    let snippet_node.multiplier = current.multiplier
                                    let str .= emmet#lang#{rtype}#toString(s:emmet_settings, snippet_node, type, inline, filters, s:itemno(group_itemno, current), indent)
                                    if current.multiplier > 1
                                      let str .= "\n"
                                    endif
                                  else
                                    if len(current.name)
                                      let str .= current.name
                                    endif
                                    if len(current.value)
                                      let text = current.value[1:-2]
                                      if dollar_expr
                                        " TODO: regexp engine specified
                                        if exists('&regexpengine')
                                          let text = substitute(text, '\%#=1\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", max([itemno, group_itemno])+1).submatch(2)', 'g')
                                        else
                                          let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", max([itemno, group_itemno])+1).submatch(2)', 'g')
                                        endif
                                        let text = substitute(text, '\${nr}', "\n", 'g')
                                        let text = substitute(text, '\\\$', '$', 'g')
                                      endif
                                      let str .= text
                                    endif
                                  endif
                                  let inner = ''
                                  if len(current.child)
                                    for n in current.child
                                      let inner .= emmet#toString(n, type, inline, filters, s:itemno(group_itemno, n), indent)
                                    endfor
                                  else
                                    let inner = current.value[1:-2]
                                  endif
                                  let inner = substitute(inner, "\n", "\n" . indent, 'g')
                                  let str = substitute(str, '\${child}', inner, '')
                                endif
   25              0.000066     let itemno = itemno + 1
   25              0.000023   endwhile
   25              0.000031   return str

FUNCTION  <SNR>74_TmuxOrTmateExecutable()
Called 5 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    5              0.000096   return (match($TMUX, 'tmate') != -1 ? 'tmate' : 'tmux')

FUNCTION  <SNR>129_Xterm2rgb()
Called 255 times
Total time:   0.007658
 Self time:   0.007658

count  total (s)   self (s)
                              " 16 basic colors
  255              0.000339   let r=0
  255              0.000271   let g=0
  255              0.000273   let b=0
  255              0.000282   if a:color<16
   16              0.000037     let r = s:basic16[a:color][0]
   16              0.000034     let g = s:basic16[a:color][1]
   16              0.000033     let b = s:basic16[a:color][2]
   16              0.000011   endif
                            
                              " color cube color
  255              0.000344   if a:color>=16 && a:color<=232
  217              0.000430     let color=a:color-16
  217              0.000515     let r = s:valuerange[(color/36)%6]
  217              0.000509     let g = s:valuerange[(color/6)%6]
  217              0.000489     let b = s:valuerange[color%6]
  217              0.000153   endif
                            
                              " gray tone
  255              0.000319   if a:color>=233 && a:color<=253
   21              0.000041     let r=8+(a:color-232)*0x0a
   21              0.000022     let g=r
   21              0.000020     let b=r
   21              0.000012   endif
  255              0.000510   let rgb=[r,g,b]
  255              0.000259   return rgb

FUNCTION  gitgutter#utility#not_git_dir()
Called 11169 times
Total time:   2.462686
 Self time:   0.499643

count  total (s)   self (s)
11169   2.443822   0.480780   return gitgutter#utility#full_path_to_directory_of_file() !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  gitgutter#utility#full_path_to_directory_of_file()
Called 11169 times
Total time:   1.963042
 Self time:   1.963042

count  total (s)   self (s)
11169              1.949273   return fnamemodify(s:file, ':p:h')

FUNCTION  <SNR>125_buildpat()
Called 898 times
Total time:   0.059659
 Self time:   0.059659

count  total (s)   self (s)
  898              0.004379 	let pat = a:lst[0]
 4700              0.012951 	for item in range(1, len(a:lst) - 1)
 3802              0.028254 		let pat .= '[^'.a:lst[item - 1].']\{-}'.a:lst[item]
 3802              0.004995 	endfo
  898              0.001792 	retu pat

FUNCTION  <SNR>269_ExtraBrackets()
Called 1 time
Total time:   0.000433
 Self time:   0.000285

count  total (s)   self (s)
    1              0.000009   let opening = {'parentheses': [], 'braces': [], 'brackets': []}
    1              0.000009   let closing = {'parentheses': [], 'braces': [], 'brackets': []}
                            
    1              0.000005   let line = getline(a:lnum)
    1              0.000013   let pos  = match(line, '[][(){}]', 0)
                            
                              " Save any encountered opening brackets, and remove them once a matching
                              " closing one has been found. If a closing bracket shows up that doesn't
                              " close anything, save it for later.
    2              0.000007   while pos != -1
    1   0.000161   0.000013     if !s:IsInStringOrComment(a:lnum, pos + 1)
    1              0.000008       if line[pos] == '('
                                    call add(opening.parentheses, {'type': '(', 'pos': pos})
                                  elseif line[pos] == ')'
                                    if empty(opening.parentheses)
                                      call add(closing.parentheses, {'type': ')', 'pos': pos})
                                    else
                                      let opening.parentheses = opening.parentheses[0:-2]
                                    endif
                                  elseif line[pos] == '{'
                                    call add(opening.braces, {'type': '{', 'pos': pos})
                                  elseif line[pos] == '}'
                                    if empty(opening.braces)
                                      call add(closing.braces, {'type': '}', 'pos': pos})
                                    else
                                      let opening.braces = opening.braces[0:-2]
                                    endif
                                  elseif line[pos] == '['
    1              0.000011         call add(opening.brackets, {'type': '[', 'pos': pos})
    1              0.000010       elseif line[pos] == ']'
                                    if empty(opening.brackets)
                                      call add(closing.brackets, {'type': ']', 'pos': pos})
                                    else
                                      let opening.brackets = opening.brackets[0:-2]
                                    endif
                                  endif
    1              0.000001     endif
                            
    1              0.000011     let pos = match(line, '[][(){}]', pos + 1)
    1              0.000005   endwhile
                            
                              " Find the rightmost brackets, since they're the ones that are important in
                              " both opening and closing cases
    1              0.000006   let rightmost_opening = {'type': '(', 'pos': -1}
    1              0.000005   let rightmost_closing = {'type': ')', 'pos': -1}
                            
    2              0.000010   for opening in opening.parentheses + opening.braces + opening.brackets
    1              0.000004     if opening.pos > rightmost_opening.pos
    1              0.000004       let rightmost_opening = opening
    1              0.000001     endif
    1              0.000001   endfor
                            
    1              0.000005   for closing in closing.parentheses + closing.braces + closing.brackets
                                if closing.pos > rightmost_closing.pos
                                  let rightmost_closing = closing
                                endif
                              endfor
                            
    1              0.000004   return [rightmost_opening, rightmost_closing]

FUNCTION  <SNR>214_count_braces()
Called 2978 times
Total time:   0.557171
 Self time:   0.557171

count  total (s)   self (s)
 2978              0.007998   let n_open = 0
 2978              0.005668   let n_close = 0
 2978              0.009804   let line = getline(a:lnum)
 2978              0.006207   let pattern = '[{}]'
 2978              0.024331   let i = match(line, pattern)
 4665              0.010696   while i != -1
 1687              0.375482     if synIDattr(synID(a:lnum, i + 1, 0), 'name') !~ 'css\%(Comment\|StringQ\{1,2}\)'
 1687              0.008760       if line[i] == '{'
  928              0.002874         let n_open += 1
  928              0.001873       elseif line[i] == '}'
  759              0.001233         if n_open > 0
                                      let n_open -= 1
                                    else
  759              0.001509           let n_close += 1
  759              0.000679         endif
  759              0.000880       endif
 1687              0.001143     endif
 1687              0.011848     let i = match(line, pattern, i + 1)
 1687              0.006339   endwhile
 2978              0.007868   return a:count_open ? n_open : n_close

FUNCTION  ctrlp#clra()
Called 1 time
Total time:   0.138145
 Self time:   0.057012

count  total (s)   self (s)
    1   0.000021   0.000014 	let cadir = ctrlp#utils#cachedir()
    1              0.000040 	if isdirectory(cadir)
    1   0.080886   0.000068 		let cafiles = split(s:glbpath(s:fnesc(cadir, 'g', ','), '**', 1), "\n")
    1              0.000012 		let eval = '!isdirectory(v:val) && v:val !~ ''\v[\/]cache[.a-z]+$|\.log$'''
    1   0.057051   0.056777 		sil! cal map(s:ifilter(cafiles, eval), 'delete(v:val)')
    1              0.000014 	en
    1   0.000064   0.000030 	cal ctrlp#clr()

FUNCTION  <SNR>95_get_hunks()
Called 68 times
Total time:   0.006330
 Self time:   0.002386

count  total (s)   self (s)
   68              0.000435   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    2              0.000006     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
    2              0.000005       let b:source_func = 's:get_hunks_gitgutter'
    2              0.000003     elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
    2              0.000001   endif
   68   0.004492   0.000548   return {b:source_func}()

FUNCTION  <SNR>269_PrevNonBlankNonString()
Called 147 times
Total time:   0.068885
 Self time:   0.007052

count  total (s)   self (s)
  147              0.000350   let in_block = 0
  147              0.000492   let lnum = prevnonblank(a:lnum)
  147              0.000308   while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
  141              0.000347     let line = getline(lnum)
  141              0.000538     if line =~ '^=begin'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
                                elseif !in_block && line =~ '^=end'
                                  let in_block = 1
                                elseif !in_block && line !~ '^\s*#.*$' && !(s:IsInStringOrComment(lnum, 1) && s:IsInStringOrComment(lnum, strlen(line)))
  141              0.000284       break
                                endif
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
  147              0.000195   return lnum

FUNCTION  airline#highlighter#add_accent()
Called 113 times
Total time:   0.000534
 Self time:   0.000534

count  total (s)   self (s)
  113              0.000460   let s:accents[a:accent] = 1

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 60970 times
Total time:   1.246109
 Self time:   1.246109

count  total (s)   self (s)
60970              0.259823   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
60970              0.391779   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
60970              0.260376   if getbufvar(a:bufnr, '&modified') == 1
 3966              0.013202     let _ .= s:buf_modified_symbol
 3966              0.004025   endif
60970              0.077587   return _

FUNCTION  <SNR>112_add_section()
Called 10025 times
Total time:   0.622166
 Self time:   0.292902

count  total (s)   self (s)
10025              0.055250     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
10025   0.062874   0.053084     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
 1090              0.000827       return
                                endif
 8935              0.009702     if condition
                                  call a:builder.add_raw('%(')
                                endif
 8935   0.402499   0.083024     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
 8935              0.012582     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  <SNR>125_highlight()
Called 980 times
Total time:   0.091185
 Self time:   0.091185

count  total (s)   self (s)
  980              0.004179 	if s:matcher != {} | retu | en
  980              0.002715 	cal clearmatches()
  980              0.002702 	if !empty(a:pat) && s:ispath
  863              0.003678 		let pat = s:regexp ? substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g') : a:pat
  863              0.001226 		if s:byfname
                            			let pat = substitute(pat, '\[\^\(.\{-}\)\]\\{-}', '[^\\/\1]\\{-}', 'g')
                            			let pat = substitute(pat, '\$\@<!$', '\\ze[^\\/]*$', 'g')
                            		en
  863              0.037360 		cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C' ).pat)
  863              0.029702 		cal matchadd('CtrlPLinePre', '^>')
  863              0.001304 	en

FUNCTION  <SNR>101_update_tabline()
Called 48 times
Total time:   0.005802
 Self time:   0.004036

count  total (s)   self (s)
   48              0.000241   if get(g:, 'airline#extensions#tabline#disable_refresh', 0)
                                return
                              endif
   48              0.000846   let match = expand('<afile>')
   48              0.000116   if pumvisible()
                                return
                              elseif !get(g:, 'airline#extensions#tabline#enabled', 0)
                                return
                              " return, if buffer matches ignore pattern or is directory (netrw)
                              elseif empty(match) || match(match, s:ignore_bufadd_pat) > -1 || isdirectory(expand("<afile>"))
   30              0.000033     return
                              endif
   18   0.002339   0.000573   doautocmd User BufMRUChange

FUNCTION  airline#parts#spell()
Called 31449 times
Total time:   0.157620
 Self time:   0.157620

count  total (s)   self (s)
31449              0.135485   return g:airline_detect_spell && &spell ? g:airline_symbols.spell : ''

FUNCTION  airline#themes#solarized#refresh()
Called 9 times
Total time:   0.302264
 Self time:   0.298828

count  total (s)   self (s)
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Options
                              """"""""""""""""""""""""""""""""""""""""""""""""
    9              0.000625   let s:background           = get(g:, 'airline_solarized_bg', &background)
    9              0.000170   let s:ansi_colors          = get(g:, 'solarized_termcolors', 16) != 256 && &t_Co >= 16 ? 1 : 0
    9              0.000069   let s:use_green            = get(g:, 'airline_solarized_normal_green', 0)
    9              0.000100   let s:dark_inactive_border = get(g:, 'airline_solarized_dark_inactive_border', 0)
    9              0.000080   let s:tty                  = &t_Co == 8
                            
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Colors
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Base colors
                              " Extended base16 support by @cuviper.
                              " Via https://github.com/blueyed/vim-colors-solarized/commit/92f2f994 /
                              " https://github.com/cuviper/vim-colors-solarized.
    9              0.000056   if s:ansi_colors && get(g:, 'solarized_base16', 0)
                                let s:base03  = {'t': 0,  'g': "#002b36"}  " Base 00
                                let s:base02  = {'t': 18, 'g': "#073642"}  " Base 01
                                let s:base01  = {'t': 19, 'g': "#586e75"}  " Base 02
                                let s:base00  = {'t': 8,  'g': "#657b83"}  " Base 03
                                let s:base0   = {'t': 20, 'g': "#839496"}  " Base 04
                                let s:base1   = {'t': 7,  'g': "#93a1a1"}  " Base 05
                                let s:base2   = {'t': 21, 'g': "#eee8d5"}  " Base 06
                                let s:base3   = {'t': 15, 'g': "#fdf6e3"}  " Base 07
                                let s:yellow  = {'t': 3,  'g': "#dc322f"}  " Base 0A
                                let s:orange  = {'t': 16, 'g': "#cb4b16"}  " Base 09
                                let s:red     = {'t': 1,  'g': "#b58900"}  " Base 08
                                let s:magenta = {'t': 17, 'g': "#859900"}  " Base 0F
                                let s:violet  = {'t': 5,  'g': "#2aa198"}  " Base 0E
                                let s:blue    = {'t': 4,  'g': "#268bd2"}  " Base 0D
                                let s:cyan    = {'t': 6,  'g': "#6c71c4"}  " Base 0C
                                let s:green   = {'t': 2,  'g': "#d33682"}  " Base 0B
                              else
    9              0.000295     let s:base03  = {'t': s:ansi_colors ?   8 : (s:tty ? '0' : 234), 'g': '#002b36'}
    9              0.000079     let s:base02  = {'t': s:ansi_colors ? '0' : (s:tty ? '0' : 235), 'g': '#073642'}
    9              0.000190     let s:base01  = {'t': s:ansi_colors ?  10 : (s:tty ? '0' : 240), 'g': '#586e75'}
    9              0.000278     let s:base00  = {'t': s:ansi_colors ?  11 : (s:tty ? '7' : 241), 'g': '#657b83'}
    9              0.000151     let s:base0   = {'t': s:ansi_colors ?  12 : (s:tty ? '7' : 244), 'g': '#839496'}
    9              0.000160     let s:base1   = {'t': s:ansi_colors ?  14 : (s:tty ? '7' : 245), 'g': '#93a1a1'}
    9              0.000120     let s:base2   = {'t': s:ansi_colors ?   7 : (s:tty ? '7' : 254), 'g': '#eee8d5'}
    9              0.000149     let s:base3   = {'t': s:ansi_colors ?  15 : (s:tty ? '7' : 230), 'g': '#fdf6e3'}
    9              0.000210     let s:yellow  = {'t': s:ansi_colors ?   3 : (s:tty ? '3' : 136), 'g': '#b58900'}
    9              0.000155     let s:orange  = {'t': s:ansi_colors ?   9 : (s:tty ? '1' : 166), 'g': '#cb4b16'}
    9              0.000154     let s:red     = {'t': s:ansi_colors ?   1 : (s:tty ? '1' : 160), 'g': '#dc322f'}
    9              0.000137     let s:magenta = {'t': s:ansi_colors ?   5 : (s:tty ? '5' : 125), 'g': '#d33682'}
    9              0.000152     let s:violet  = {'t': s:ansi_colors ?  13 : (s:tty ? '5' : 61 ), 'g': '#6c71c4'}
    9              0.000120     let s:blue    = {'t': s:ansi_colors ?   4 : (s:tty ? '4' : 33 ), 'g': '#268bd2'}
    9              0.000132     let s:cyan    = {'t': s:ansi_colors ?   6 : (s:tty ? '6' : 37 ), 'g': '#2aa198'}
    9              0.000185     let s:green   = {'t': s:ansi_colors ?   2 : (s:tty ? '2' : 64 ), 'g': '#859900'}
    9              0.000018   endif
                            
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Simple mappings
                              " NOTE: These are easily tweakable mappings. The actual mappings get
                              " the specific gui and terminal colors from the base color dicts.
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Normal mode
    9              0.000052   if s:background == 'dark'
                                let s:N1 = [s:base3, (s:use_green ? s:green : s:base1), 'bold']
                                let s:N2 = [s:base2, (s:tty ? s:base01 : s:base00), '']
                                let s:N3 = [s:base01, s:base02, '']
                              else
    9              0.000263     let s:N1 = [s:base2, (s:use_green ? s:green : s:base00), 'bold']
    9              0.000068     let s:N2 = [(s:tty ? s:base01 : s:base2), s:base1, '']
    9              0.000092     let s:N3 = [s:base1, s:base2, '']
    9              0.000014   endif
    9              0.000087   let s:NF = [s:orange, s:N3[1], '']
    9              0.000203   let s:NW = [s:base3, s:orange, '']
    9              0.000052   if s:background == 'dark'
                                let s:NM = [s:base1, s:N3[1], '']
                                let s:NMi = [s:base2, s:N3[1], '']
                              else
    9              0.000050     let s:NM = [s:base01, s:N3[1], '']
    9              0.000192     let s:NMi = [s:base02, s:N3[1], '']
    9              0.000014   endif
                            
                              " Insert mode
    9              0.000198   let s:I1 = [s:N1[0], s:yellow, 'bold']
    9              0.000030   let s:I2 = s:N2
    9              0.000021   let s:I3 = s:N3
    9              0.000022   let s:IF = s:NF
    9              0.000023   let s:IM = s:NM
                            
                              " Visual mode
    9              0.000163   let s:V1 = [s:N1[0], s:magenta, 'bold']
    9              0.000027   let s:V2 = s:N2
    9              0.000043   let s:V3 = s:N3
    9              0.000023   let s:VF = s:NF
    9              0.000073   let s:VM = s:NM
                            
                              " Replace mode
    9              0.000136   let s:R1 = [s:N1[0], s:red, '']
    9              0.000078   let s:R2 = s:N2
    9              0.000103   let s:R3 = s:N3
    9              0.000099   let s:RM = s:NM
    9              0.000069   let s:RF = s:NF
                            
                              " Inactive, according to VertSplit in solarized
                              " (bg dark: base00; bg light: base0)
    9              0.000034   if s:background == 'dark'
                                if s:dark_inactive_border
                                  let s:IA = [s:base01, s:base02, '']
                                else
                                  let s:IA = [s:base02, s:base00, '']
                                endif
                              else
    9              0.000132     let s:IA = [s:base2, s:base0, '']
    9              0.000014   endif
                            
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Actual mappings
                              " WARNING: Don't modify this section unless necessary.
                              """"""""""""""""""""""""""""""""""""""""""""""""
    9              0.000184   let s:NFa = [s:NF[0].g, s:NF[1].g, s:NF[0].t, s:NF[1].t, s:NF[2]]
    9              0.000167   let s:IFa = [s:IF[0].g, s:IF[1].g, s:IF[0].t, s:IF[1].t, s:IF[2]]
    9              0.000200   let s:VFa = [s:VF[0].g, s:VF[1].g, s:VF[0].t, s:VF[1].t, s:VF[2]]
    9              0.000179   let s:RFa = [s:RF[0].g, s:RF[1].g, s:RF[0].t, s:RF[1].t, s:RF[2]]
                            
    9              0.000940   let g:airline#themes#solarized#palette.accents = { 'red': s:NFa, }
                            
    9   0.004629   0.003497   let g:airline#themes#solarized#palette.inactive = airline#themes#generate_color_map( [s:IA[0].g, s:IA[1].g, s:IA[0].t, s:IA[1].t, s:IA[2]], [s:IA[0].g, s:IA[1].g, s:IA[0].t, s:IA[1].t, s:IA[2]], [s:IA[0].g, s:IA[1].g, s:IA[0].t, s:IA[1].t, s:IA[2]])
    9              0.000684   let g:airline#themes#solarized#palette.inactive_modified = { 'airline_c': [s:NMi[0].g, '', s:NMi[0].t, '', s:NMi[2]]}
                            
    9   0.201674   0.201061   let g:airline#themes#solarized#palette.normal = airline#themes#generate_color_map( [s:N1[0].g, s:N1[1].g, s:N1[0].t, s:N1[1].t, s:N1[2]], [s:N2[0].g, s:N2[1].g, s:N2[0].t, s:N2[1].t, s:N2[2]], [s:N3[0].g, s:N3[1].g, s:N3[0].t, s:N3[1].t, s:N3[2]])
                            
    9              0.000156   let g:airline#themes#solarized#palette.normal.airline_warning = [ s:NW[0].g, s:NW[1].g, s:NW[0].t, s:NW[1].t, s:NW[2]]
                            
    9              0.000094   let g:airline#themes#solarized#palette.normal.airline_error = [ s:NW[0].g, s:NW[1].g, s:NW[0].t, s:NW[1].t, s:NW[2]]
                            
    9              0.078902   let g:airline#themes#solarized#palette.normal_modified = { 'airline_c': [s:NM[0].g, s:NM[1].g, s:NM[0].t, s:NM[1].t, s:NM[2]]}
                            
    9              0.000080   let g:airline#themes#solarized#palette.normal_modified.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9   0.001709   0.001101   let g:airline#themes#solarized#palette.insert = airline#themes#generate_color_map( [s:I1[0].g, s:I1[1].g, s:I1[0].t, s:I1[1].t, s:I1[2]], [s:I2[0].g, s:I2[1].g, s:I2[0].t, s:I2[1].t, s:I2[2]], [s:I3[0].g, s:I3[1].g, s:I3[0].t, s:I3[1].t, s:I3[2]])
                            
    9              0.000061   let g:airline#themes#solarized#palette.insert.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9              0.000660   let g:airline#themes#solarized#palette.insert_modified = { 'airline_c': [s:IM[0].g, s:IM[1].g, s:IM[0].t, s:IM[1].t, s:IM[2]]}
                            
    9              0.000055   let g:airline#themes#solarized#palette.insert_modified.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9   0.001574   0.001015   let g:airline#themes#solarized#palette.visual = airline#themes#generate_color_map( [s:V1[0].g, s:V1[1].g, s:V1[0].t, s:V1[1].t, s:V1[2]], [s:V2[0].g, s:V2[1].g, s:V2[0].t, s:V2[1].t, s:V2[2]], [s:V3[0].g, s:V3[1].g, s:V3[0].t, s:V3[1].t, s:V3[2]])
                            
    9              0.000071   let g:airline#themes#solarized#palette.visual.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9              0.000613   let g:airline#themes#solarized#palette.visual_modified = { 'airline_c': [s:VM[0].g, s:VM[1].g, s:VM[0].t, s:VM[1].t, s:VM[2]]}
                            
    9              0.000057   let g:airline#themes#solarized#palette.visual_modified.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9   0.000861   0.000338   let g:airline#themes#solarized#palette.replace = airline#themes#generate_color_map( [s:R1[0].g, s:R1[1].g, s:R1[0].t, s:R1[1].t, s:R1[2]], [s:R2[0].g, s:R2[1].g, s:R2[0].t, s:R2[1].t, s:R2[2]], [s:R3[0].g, s:R3[1].g, s:R3[0].t, s:R3[1].t, s:R3[2]])
                            
    9              0.000048   let g:airline#themes#solarized#palette.replace.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9              0.000135   let g:airline#themes#solarized#palette.replace_modified = { 'airline_c': [s:RM[0].g, s:RM[1].g, s:RM[0].t, s:RM[1].t, s:RM[2]]}
                            
    9              0.000048   let g:airline#themes#solarized#palette.replace_modified.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9              0.000121   let g:airline#themes#solarized#palette.tabline = {}
                            
    9              0.000078   let g:airline#themes#solarized#palette.tabline.airline_tab = [ s:I2[0].g, s:I2[1].g, s:I2[0].t, s:I2[1].t, s:I2[2]]
                            
    9              0.000084   let g:airline#themes#solarized#palette.tabline.airline_tabtype = [ s:N2[0].g, s:N2[1].g, s:N2[0].t, s:N2[1].t, s:N2[2]]

FUNCTION  gitgutter#hunk#summary()
Called 3001 times
Total time:   0.058028
 Self time:   0.023128

count  total (s)   self (s)
 3001   0.056470   0.021570   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>129_pow()
Called 224910 times
Total time:   2.065235
 Self time:   2.065235

count  total (s)   self (s)
224910              0.451922   let x = a:x
224910              0.719659   for i in range(a:n-1)
224910              0.408329     let x = x*a:x
224910              0.243747   return x

FUNCTION  rails#app()
Called 8723 times
Total time:   0.260869
 Self time:   0.181684

count  total (s)   self (s)
 8723   0.136932   0.057747   let root = s:sub(a:0 ? a:1 : get(b:, 'rails_root', ''), '[\/]$', '')
 8723              0.019542   if !empty(root)
 8723              0.028782     if !has_key(s:apps, root) && filereadable(root . '/config/environment.rb')
                                  let s:apps[root] = deepcopy(s:app_prototype)
                                  let s:apps[root].root = root
                                  let s:apps[root]._root = root
                                endif
 8723              0.021826     return get(s:apps, root, {})
                              endif
                              return {}

FUNCTION  airline#extensions#tabline#load_theme()
Called 9 times
Total time:   0.026309
 Self time:   0.001424

count  total (s)   self (s)
    9              0.000019   if pumvisible()
                                return
                              endif
    9              0.000033   let colors    = get(a:palette, 'tabline', {})
                              " Theme for tabs on the left
    9              0.000043   let l:tab     = get(colors, 'airline_tab', a:palette.normal.airline_b)
    9              0.000032   let l:tabsel  = get(colors, 'airline_tabsel', a:palette.normal.airline_a)
    9              0.000032   let l:tabtype = get(colors, 'airline_tabtype', a:palette.visual.airline_a)
    9              0.000026   let l:tabfill = get(colors, 'airline_tabfill', a:palette.normal.airline_c)
    9              0.000029   let l:tabmod  = get(colors, 'airline_tabmod', a:palette.insert.airline_a)
    9              0.000024   let l:tabhid  = get(colors, 'airline_tabhid', a:palette.normal.airline_c)
    9              0.000038   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
    9              0.000036     let l:tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal_modified.airline_c)
    9              0.000006   else
                                "Fall back to normal airline_c if modified airline_c isn't present
                                let l:tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal.airline_c)
                              endif
    9   0.002052   0.000049   call airline#highlighter#exec('airline_tab', l:tab)
    9   0.002303   0.000050   call airline#highlighter#exec('airline_tabsel', l:tabsel)
    9   0.001857   0.000053   call airline#highlighter#exec('airline_tabtype', l:tabtype)
    9   0.001885   0.000046   call airline#highlighter#exec('airline_tabfill', l:tabfill)
    9   0.002235   0.000052   call airline#highlighter#exec('airline_tabmod', l:tabmod)
    9   0.001838   0.000059   call airline#highlighter#exec('airline_tabmod_unsel', l:tabmodu)
    9   0.002148   0.000053   call airline#highlighter#exec('airline_tabhid', l:tabhid)
                            
                              " Theme for tabs on the right
    9              0.000044   let l:tabsel_right  = get(colors, 'airline_tabsel_right', a:palette.normal.airline_a)
    9              0.000038   let l:tab_right     = get(colors, 'airline_tab_right',    a:palette.inactive.airline_c)
    9              0.000033   let l:tabmod_right  = get(colors, 'airline_tabmod_right', a:palette.insert.airline_a)
    9              0.000032   let l:tabhid_right  = get(colors, 'airline_tabhid_right', a:palette.normal.airline_c)
    9              0.000038   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
    9              0.000036     let l:tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal_modified.airline_c)
    9              0.000007   else
                                "Fall back to normal airline_c if modified airline_c isn't present
                                let l:tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal.airline_c)
                              endif
    9   0.002078   0.000055   call airline#highlighter#exec('airline_tab_right',    l:tab_right)
    9   0.002700   0.000060   call airline#highlighter#exec('airline_tabsel_right', l:tabsel_right)
    9   0.002548   0.000071   call airline#highlighter#exec('airline_tabmod_right', l:tabmod_right)
    9   0.001972   0.000061   call airline#highlighter#exec('airline_tabhid_right', l:tabhid_right)
    9   0.001931   0.000053   call airline#highlighter#exec('airline_tabmod_unsel_right', l:tabmodu_right)

FUNCTION  <SNR>41_record()
Called 1452 times
Total time:   1.685327
 Self time:   0.098171

count  total (s)   self (s)
 1452              0.009909 	if s:locked | retu | en
 1452              0.007517 	let bufnr = a:bufnr + 0
 1452              0.009560 	let bufname = bufname(bufnr)
 1452              0.006834 	if bufnr > 0 && !empty(bufname)
 1422              0.036260 		cal filter(s:mrbs, 'v:val != bufnr')
 1422              0.006181 		cal insert(s:mrbs, bufnr)
 1422   1.601833   0.014677 		cal s:addtomrufs(bufname)
 1422              0.001369 	en

FUNCTION  <SNR>125_MapSpecs()
Called 109 times
Total time:   0.181800
 Self time:   0.181800

count  total (s)   self (s)
  109              0.000901 	if !( exists('s:smapped') && s:smapped == s:bufnr )
                            		" Correct arrow keys in terminal
                            		if ( has('termresponse') && v:termresponse =~ "\<ESC>" ) || &term =~? '\vxterm|<k?vt|gnome|screen|linux|ansi'
                            			for each in ['\A <up>','\B <down>','\C <right>','\D <left>']
                            				exe s:lcmap.' <esc>['.each
                            			endfo
                            		en
                            	en
13189              0.027090 	for [ke, va] in items(s:prtmaps) | for kp in va
 5777              0.121391 		exe s:lcmap kp ':<c-u>cal <SID>'.ke.'<cr>'
 9483              0.012790 	endfo | endfo
  109              0.000401 	let s:smapped = s:bufnr

FUNCTION  <SNR>214_prevnonblanknoncomment()
Called 1507 times
Total time:   0.056460
 Self time:   0.056460

count  total (s)   self (s)
 1507              0.005188   let lnum = a:lnum
 1507              0.003916   while lnum > 1
 1464              0.005500     let lnum = prevnonblank(lnum)
 1464              0.004355     let line = getline(lnum)
 1464              0.006463     if line =~ '\*/'
   98              0.000388       while lnum > 1 && line !~ '/\*'
   91              0.000230         let lnum -= 1
   91              0.000117       endwhile
    7              0.000049       if line =~ '^\s*/\*'
                                    let lnum -= 1
                                  else
    7              0.000018         break
                                  endif
                                else
 1457              0.002198       break
                                endif
                              endwhile
 1507              0.002576   return lnum

FUNCTION  <SNR>106_wrap_accent()
Called 113 times
Total time:   0.002284
 Self time:   0.001750

count  total (s)   self (s)
  113              0.000408   if exists('a:part.accent')
  113   0.001215   0.000681     call airline#highlighter#add_accent(a:part.accent)
  113              0.000518     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  ctrlp#progress()
Called 44 times
Total time:   0.147614
 Self time:   0.145159

count  total (s)   self (s)
   44              0.056337 	if has('macunix') || has('mac') | sl 1m | en
   44              0.000868 	let txt = a:0 ? '(press ctrl-c to abort)' : ''
   44              0.000324 	if s:status != {}
   44              0.000696 		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{ 'str': a:enum }] : [a:enum]
   44   0.003698   0.001243 		let &l:stl = call(s:status['prog'], argms, s:status)
   44              0.000066 	el
                            		let &l:stl = '%#CtrlPStats# '.a:enum.' %* '.txt.'%=%<%#CtrlPMode2# %{getcwd()} %*'
                            	en
   44              0.085041 	redraws

FUNCTION  <SNR>118_pathjoin()
Called 137 times
Total time:   0.010629
 Self time:   0.010629

count  total (s)   self (s)
  137              0.000272   let i = 0
  137              0.000207   let path = ""
  274              0.000408   while i < a:0
  137              0.000487     if type(a:000[i]) == type([])
  137              0.005727       let path .= "," . escape(join(a:000[i], ','), ' ')
  137              0.000163     else
                                  let path .= "," . a:000[i]
                                endif
  137              0.000188     let i += 1
  137              0.000111   endwhile
  137              0.001206   return substitute(path,'^,','','')

FUNCTION  196()
Called 15 times
Total time:   0.023732
 Self time:   0.014033

count  total (s)   self (s)
   15              0.002292     let buf = bufnr(t:NERDTreeBufName)
                            
                                "if &hidden is not set then it will already be gone
   15              0.000042     if buf != -1
                            
                                    "nerdtree buf may be mirrored/displayed elsewhere
   15   0.007993   0.000128         if self._isBufHidden(buf)
   15   0.013003   0.011168             exec "bwipeout " . buf
   15              0.000040         endif
                            
   15              0.000013     endif
                            
   15              0.000077     unlet t:NERDTreeBufName

FUNCTION  <SNR>41_savetofile()
Called 18 times
Total time:   0.383355
 Self time:   0.000276

count  total (s)   self (s)
   18   0.383334   0.000255 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  339()
Called 940 times
Total time:   2.126305
 Self time:   0.278082

count  total (s)   self (s)
  940   0.042921   0.012388     if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
  940   0.013945   0.005111     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
 5640              0.010227     for type in self._enabled_types
 4700              0.047317         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
 4700   0.104860   0.044731         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
 3760              0.014045             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
  940              0.004827                 if !exists('b:syntastic_private_' . type . '_stamp')
   33              0.000195                     let b:syntastic_private_{type}_stamp = []
   33              0.000037                 endif
  940   0.045180   0.008253                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
  911   1.420941   0.005399                     call self._notifier[type].refresh(a:loclist)
  911   0.029161   0.010254                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
  911              0.001250                 endif
  940              0.000762             else
 2820   0.294188   0.016837                 call self._notifier[type].refresh(a:loclist)
 2820              0.002095             endif
 3760              0.002399         endif
 4700              0.004011     endfor

FUNCTION  <SNR>125_regisfilter()
Called 109 times
Total time:   0.006048
 Self time:   0.006048

count  total (s)   self (s)
  109              0.005854 	retu substitute(getreg(a:reg), "[\t\n]", ' ', 'g')

FUNCTION  206()
Called 542 times
Total time:   0.005888
 Self time:   0.005888

count  total (s)   self (s)
  542              0.003010     let newObj = copy(self)
  542              0.001496     let newObj._flags = {}
  542              0.000824     return newObj

FUNCTION  208()
Called 1709 times
Total time:   0.017828
 Self time:   0.017828

count  total (s)   self (s)
 1709              0.003012     let flagstring = ""
 1709              0.004375     for i in values(self._flags)
                                    let flagstring .= join(i)
                                endfor
                            
 1709              0.003097     if len(flagstring) == 0
 1709              0.001526         return ""
                                endif
                            
                                return '[' . flagstring . ']'

FUNCTION  rails#buffer_syntax()
Called 88 times
Total time:   1.423636
 Self time:   0.701625

count  total (s)   self (s)
   88              0.000463   if !exists("g:rails_no_syntax")
   88   0.003102   0.000692     let buffer = rails#buffer()
   88   0.670314   0.001465     let keywords = split(join(filter(buffer.projected('keywords'), 'type(v:val) == type("")'), ' '))
   88              0.000442     let special = filter(copy(keywords), 'v:val =~# ''^\h\k*[?!]$''')
   88              0.000334     let regular = filter(copy(keywords), 'v:val =~# ''^\h\k*$''')
   88   0.004614   0.000670     let group = buffer.type_name('helper', 'view') ? 'rubyHelper' : 'rubyMacro'
   88              0.000281     if &syntax == 'ruby'
   10   0.018656   0.000082       call rails#ruby_syntax()
   10              0.000023       if !empty(special)
                                    exe 'syn match' group "\<\%('.join(special, '\|').'\)"'
                                  endif
   10              0.000015       if !empty(regular)
                                    exe 'syn keyword' group join(regular, ' ')
                                  endif
                            
   10              0.000016     elseif (&syntax =~# '^eruby\>' || &syntax == 'haml') && &syntax !~# 'yaml'
   43              0.000100       syn case match
   43              0.000073       if &syntax == 'haml'
   43              0.002244         exe 'syn cluster hamlRailsRegions contains=hamlRubyCodeIncluded,hamlRubyCode,hamlRubyHash,@hamlEmbeddedRuby,rubyInterpolation'
   43              0.000042       else
                                    exe 'syn cluster erubyRailsRegions contains=erubyOneLiner,erubyBlock,erubyExpression,rubyInterpolation'
                                  endif
   43              0.000495       let containedin = 'contained containedin=@'.matchstr(&syntax, '^\w\+').'RailsRegions'
   43              0.000106       if !empty(special)
                                    exe 'syn match' group '"\<\%('.join(special, '\|').'\)"' containedin
                                  endif
   43              0.000065       if !empty(regular)
                                    exe 'syn keyword' group join(regular, ' ') containedin
                                  endif
   43   0.010934   0.007932       exe 'syn keyword rubyViewHelper' s:helpermethods() containedin
   43              0.000994       exe 'syn match rubyViewHelper "\<select\>\%(\s*{\|\s*do\>\|\s*(\=\s*&\)\@!"' containedin
   43              0.000749       exe 'syn match rubyViewHelper "\<\%(content_for\w\@!?\=\|current_page?\)"' containedin
   43              0.000702       exe 'syn keyword rubyHelper logger' containedin
   43              0.001455       exe 'syn keyword rubyUrlHelper url_for polymorphic_path polymorphic_url edit_polymorphic_path edit_polymorphic_url new_polymorphic_path new_polymorphic_url' containedin
   43              0.000881       exe 'syn match rubyViewHelper "\.\@<!\<\(h\|html_escape\|u\|url_encode\)\>"' containedin
   43   0.002217   0.000323       if buffer.type_name('view-partial')
   28              0.000499         exe 'syn keyword rubyViewHelper local_assigns' containedin
   28              0.000028       endif
   43              0.000026     endif
                            
   88              0.001187     if &syntax =~# '^\%(javascript\|coffee\|css\|scss\|sass\)'
   35              0.255796       syn match sprocketsPreProc "\%(\w\s*\)\@<!=" contained containedin=.*Comment skipwhite nextgroup=sprocketsInclude
   35              0.000340       syn keyword sprocketsInclude require_self
   35              0.000645       syn keyword sprocketsInclude require link link_directory link_tree depend_on depend_on_asset stub skipwhite nextgroup=sprocketsIncluded
   35              0.000593       syn keyword sprocketsInclude require_directory require_tree skipwhite nextgroup=sprocketsIncludedDir
   35              0.000369       syn match sprocketsIncluded /\f\+\|"[^"]*"/ contained
   35              0.000633       syn match sprocketsIncludedDir /\f\+\|"[^"]*"/ contained skipwhite nextgroup=sprocketsIncluded
   35              0.000042     endif
   88              0.000426     if &syntax ==# "scss" || &syntax ==# "sass"
   35              0.000533       syn match sassFunction "\<\%(\%(asset\|image\|font\|video\|audio\|javascript\|stylesheet\)-\%(url\|path\)\)\>(\@=" contained
   35              0.000332       syn match sassFunction "\<\asset-data-url\>(\@=" contained
   35              0.000028     endif
   88              0.000068   endif
   88   0.024304   0.000965   call s:HiDefaults()

FUNCTION  <SNR>125_mtype()
Called 118 times
Total time:   0.000719
 Self time:   0.000719

count  total (s)   self (s)
  118              0.000622 	retu s:itemtype > 2 ? s:getextvar('type') : 'path'

FUNCTION  <SNR>125_byfname()
Called 4100 times
Total time:   0.017702
 Self time:   0.017702

count  total (s)   self (s)
 4100              0.014130 	retu s:ispath && s:byfname

FUNCTION  emmet#getSettings()
Called 105 times
Total time:   0.000448
 Self time:   0.000448

count  total (s)   self (s)
  105              0.000324   return s:emmet_settings

FUNCTION  ctrlp#rmbasedir()
Called 11 times
Total time:   0.001602
 Self time:   0.001467

count  total (s)   self (s)
   11   0.000212   0.000077 	let cwd = s:dyncwd.s:lash()
   11              0.000085 	if a:items != [] && !stridx(a:items[0], cwd)
   11              0.000037 		let idx = strlen(cwd)
   11              0.001220 		retu map(a:items, 'strpart(v:val, idx)')
                            	en
                            	retu a:items

FUNCTION  gitgutter#utility#bufnr()
Called 44315 times
Total time:   0.168626
 Self time:   0.168626

count  total (s)   self (s)
44315              0.130329   return s:bufnr

FUNCTION  <SNR>118_addfilecmds()
Called 1096 times
Total time:   0.403538
 Self time:   0.328609

count  total (s)   self (s)
 1096   0.012802   0.005397   let l = s:sub(a:type,'^.','\l&')
 1096              0.003646   let cplt = " -complete=customlist,".s:sid.l."List"
13152              0.019442   for prefix in ['E', 'S', 'V', 'T', 'D', 'R', 'RE', 'RS', 'RV', 'RT', 'RD']
12056   0.345493   0.277970     exe "command! -buffer -bar ".(prefix =~# 'D' ? '-range=0 ' : '')."-nargs=*".cplt." ".prefix.l." :execute s:r_error('".prefix."',s:".l.'Edit("<mods> '.(prefix =~# 'D' ? '<line1>' : '').s:sub(prefix, '^R', '').'<bang>",<f-args>))'
12056              0.011908   endfor

FUNCTION  ctrlp#syntax()
Called 109 times
Total time:   0.043144
 Self time:   0.024039

count  total (s)   self (s)
  109   0.002062   0.000942 	if ctrlp#nosy() | retu | en
 2507   0.028480   0.010495 	for [ke, va] in items(s:hlgrps) | cal ctrlp#hicheck('CtrlP'.ke, va) | endfo
  109              0.003305 	if synIDattr(synIDtrans(hlID('Normal')), 'bg') !~ '^-1$\|^$'
                            		sil! exe 'hi CtrlPLinePre '.( has("gui_running") ? 'gui' : 'cterm' ).'fg=bg'
                            	en
  109              0.002734 	sy match CtrlPNoEntries '^ == NO ENTRIES ==$'
  109              0.002037 	if hlexists('CtrlPLinePre')
                            		sy match CtrlPLinePre '^>'
                            	en

FUNCTION  airline#parts#crypt()
Called 31449 times
Total time:   0.360664
 Self time:   0.360664

count  total (s)   self (s)
31449              0.325895   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  149()
Called 57 times
Total time:   0.486378
 Self time:   0.017574

count  total (s)   self (s)
                                "remove all the current child nodes
   57              0.000184     let self.children = []
                            
   57   0.086970   0.001161     let files = self._glob('*', 1) + self._glob('.*', 0)
                            
   57              0.000285     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ...")
                                endif
                            
   57              0.000135     let invalidFilesFound = 0
  532              0.000833     for i in files
  475              0.000573         try
  475   0.183387   0.002790             let path = g:NERDTreePath.New(i)
  475   0.039867   0.002311             call self.createChild(path, 0)
  475   0.030331   0.004201             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
  475              0.000795         catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                        let invalidFilesFound += 1
                                    endtry
  475              0.000399     endfor
                            
   57   0.138787   0.000229     call self.sortChildren()
                            
   57              0.000206     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ... DONE (". self.getChildCount() ." nodes cached).")
                                endif
                            
   57              0.000066     if invalidFilesFound
                                    call nerdtree#echoWarning(invalidFilesFound . " file(s) could not be loaded into the NERD tree")
                                endif
   57   0.000374   0.000218     return self.getChildCount()

FUNCTION  211()
Called 15 times
Total time:   0.795016
 Self time:   0.003024

count  total (s)   self (s)
   15   0.002668   0.000144     if !s:NERDTree.IsOpen()
                                    return
                                endif
                            
   15              0.000058     if winnr("$") != 1
   15   0.002419   0.000101         if winnr() == s:NERDTree.GetWinNum()
    8   0.124575   0.000060             call nerdtree#exec("wincmd p")
    8              0.000033             let bufnr = bufnr("")
    8   0.083223   0.000055             call nerdtree#exec("wincmd p")
    8              0.000010         else
    7              0.000026             let bufnr = bufnr("")
    7              0.000008         endif
                            
   15   0.097202   0.000230         call nerdtree#exec(s:NERDTree.GetWinNum() . " wincmd w")
   15   0.449046   0.001740         close
   15   0.035425   0.000236         call nerdtree#exec(bufwinnr(bufnr) . " wincmd w")
   15              0.000022     else
                                    close
                                endif

FUNCTION  214()
Called 28 times
Total time:   0.008243
 Self time:   0.000513

count  total (s)   self (s)
   28   0.004105   0.000153     call g:NERDTree.MustBeOpen()
   28   0.004098   0.000320     call nerdtree#exec(g:NERDTree.GetWinNum() . "wincmd w")

FUNCTION  215()
Called 164 times
Total time:   0.001234
 Self time:   0.001234

count  total (s)   self (s)
  164              0.001082     return exists("b:NERDTree")

FUNCTION  216()
Called 15 times
Total time:   0.002889
 Self time:   0.002889

count  total (s)   self (s)
   15              0.000102     if !exists("t:NERDTreeBufName")
                                    return
                                end
                            
                                "check b:NERDTree is still there and hasn't been e.g. :bdeleted
   15              0.002719     return !empty(getbufvar(bufnr(t:NERDTreeBufName), 'NERDTree'))

FUNCTION  <SNR>125_comptime()
Called 15154 times
Total time:   0.649763
 Self time:   0.649763

count  total (s)   self (s)
                            	" By last modified time
15154              0.579808 	let [time1, time2] = [getftime(a:1), getftime(a:2)]
15154              0.049747 	retu time1 == time2 ? 0 : time1 < time2 ? 1 : -1

FUNCTION  <SNR>100_wordcount_update()
Called 13156 times
Total time:   1.106039
 Self time:   1.106039

count  total (s)   self (s)
13156              0.071842   if empty(bufname(''))
                                return
                              endif
13156              0.464279   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
                              endif

FUNCTION  <SNR>59__normalise_filetype()
Called 1006 times
Total time:   0.023501
 Self time:   0.023501

count  total (s)   self (s)
 1006              0.006885     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
 1006              0.005094     let ft = get(g:syntastic_filetype_map, ft, ft)
 1006              0.007121     let ft = substitute(ft, '\m-', '_', 'g')
 1006              0.001946     return ft

FUNCTION  fugitive#is_git_dir()
Called 184 times
Total time:   0.167895
 Self time:   0.166130

count  total (s)   self (s)
  184   0.003087   0.001322   let path = s:sub(a:path, '[\/]$', '') . '/'
  184              0.164577   return getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  <SNR>106_create()
Called 113 times
Total time:   0.022840
 Self time:   0.019916

count  total (s)   self (s)
  113              0.000351   let _ = ''
  226              0.000723   for idx in range(len(a:parts))
  113   0.001490   0.000849     let part = airline#parts#get(a:parts[idx])
  113              0.000222     let val = ''
  113              0.000394     let add_sep = get(l:, 'add_sep', 0)
                            
  113              0.000371     if exists('part.function')
  113              0.000341       let func = (part.function).'()'
  113              0.000216     elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let t = ''
                                    if !add_sep
                                      let t = s:spc.g:airline_right_alt_sep.s:spc
                                    endif
                                    let val = t.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
                                endif
                            
  113              0.000398     let minwidth = get(part, 'minwidth', 0)
                            
  113              0.000238     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                else
  113              0.000772       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
  113              0.000206       let add_sep = 0
  113              0.000100     endif
                            
  113              0.000304     if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
                                endif
                            
  113   0.003022   0.000739     let val .= s:wrap_accent(part, partval)
  113              0.000325     let _ .= val
  113              0.000168   endfor
  113              0.000157   return _

FUNCTION  airline#extensions#branch#head()
Called 68 times
Total time:   2.163870
 Self time:   0.002406

count  total (s)   self (s)
   68              0.000285   if !exists('b:buffer_vcs_config')
    2   0.000063   0.000012     call s:init_buffer()
    2              0.000001   endif
                            
   68   0.030979   0.000396   call s:update_branch()
   68   2.130684   0.000390   call s:update_untracked()
                            
   68              0.000337   if exists('b:airline_head') && !empty(b:airline_head)
   66              0.000118     return b:airline_head
                              endif
                            
    2              0.000013   let b:airline_head = ''
    2              0.000018   let l:vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    2              0.000005   let l:heads = {}
    6              0.000019   for vcs in l:vcs_priority
    4              0.000022     if !empty(b:buffer_vcs_config[vcs].branch)
    2              0.000014       let l:heads[vcs] = b:buffer_vcs_config[vcs].branch
    2              0.000002     endif
    4              0.000005   endfor
                            
    4              0.000016   for vcs in keys(l:heads)
    2              0.000010     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
    2   0.000056   0.000047     let b:airline_head .= (len(l:heads) > 1 ? s:vcs_config[l:vcs].exe .':' : '') . s:format_name(l:heads[l:vcs])
    2              0.000010     let b:airline_head .= b:buffer_vcs_config[vcs].untracked
    2              0.000005   endfor
                            
    2              0.000005   if empty(l:heads)
                                if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
    2              0.000009   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  'â¦' : '.')
                                endif
                              endif
                            
    2   0.000455   0.000024   if has_key(l:heads, 'git') && !s:check_in_path()
                                let b:airline_head = ''
                              endif
    2              0.000011   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
    2   0.000122   0.000026   let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
    2              0.000008   return b:airline_head

FUNCTION  <SNR>269_GetMSL()
Called 65 times
Total time:   0.109032
 Self time:   0.008962

count  total (s)   self (s)
                              " Start on the line we're at and use its indent.
   65              0.000188   let msl = a:lnum
   65              0.000183   let msl_body = getline(msl)
   65   0.028759   0.000390   let lnum = s:PrevNonBlankNonString(a:lnum - 1)
   92              0.000160   while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
   89              0.000227     let line = getline(lnum)
                            
   89   0.001943   0.000566     if s:Match(lnum, s:splat_regex)
                                  " If the above line looks like the "*" of a splat, use the current one's
                                  " indentation.
                                  "
                                  " Example:
                                  "   Hash[*
                                  "     method_call do
                                  "       something
                                  "
                                  return msl
                                elseif s:Match(line, s:non_bracket_continuation_regex) && s:Match(msl, s:non_bracket_continuation_regex)
                                  " If the current line is a non-bracket continuation and so is the
                                  " previous one, keep its indent and continue looking for an MSL.
                                  "
                                  " Example:
                                  "   method_call one,
                                  "     two,
                                  "     three
                                  "
                                  let msl = lnum
                                elseif s:Match(lnum, s:non_bracket_continuation_regex) && (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If the current line is a bracket continuation or a block-starter, but
                                  " the previous is a non-bracket one, respect the previous' indentation,
                                  " and stop here.
                                  "
                                  " Example:
                                  "   method_call one,
                                  "     two {
                                  "     three
                                  "
   29              0.000054       return lnum
                                elseif s:Match(lnum, s:bracket_continuation_regex) && (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If both lines are bracket continuations (the current may also be a
                                  " block-starter), use the current one's and stop here
                                  "
                                  " Example:
                                  "   method_call(
                                  "     other_method_call(
                                  "       foo
   12              0.000023       return msl
                                elseif s:Match(lnum, s:block_regex) && !s:Match(msl, s:continuation_regex) && !s:Match(msl, s:block_continuation_regex)
                                  " If the previous line is a block-starter and the current one is
                                  " mostly ordinary, use the current one as the MSL.
                                  "
                                  " Example:
                                  "   method_call do
                                  "     something
                                  "     something_else
                                  return msl
                                else
   48              0.001460       let col = match(line, s:continuation_regex) + 1
   48   0.015633   0.000507       if (col > 0 && !s:IsInStringOrComment(lnum, col)) || s:IsInString(lnum, strlen(line))
   27              0.000077         let msl = lnum
   27              0.000026       else
   21              0.000022         break
                                  endif
   27              0.000014     endif
                            
   27              0.000071     let msl_body = getline(msl)
   27   0.009253   0.000211     let lnum = s:PrevNonBlankNonString(lnum - 1)
   27              0.000061   endwhile
   24              0.000031   return msl

FUNCTION  syntastic#log#debugDump()
Called 503 times
Total time:   0.006182
 Self time:   0.004129

count  total (s)   self (s)
  503   0.004699   0.002646     if !s:_isDebugEnabled(a:level)
  503              0.000636         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  <SNR>125_setupblank()
Called 109 times
Total time:   1.770203
 Self time:   1.770203

count  total (s)   self (s)
  109              0.003001 	setl noswf nonu nobl nowrap nolist nospell nocuc wfh
  109              0.002879 	setl fdc=0 fdl=99 tw=0 bt=nofile bh=unload
  109              0.000493 	if v:version > 702
  109              1.762759 		setl nornu noudf cc=0
  109              0.000681 	en

FUNCTION  <SNR>118_app_has_path()
Called 137 times
Total time:   0.007479
 Self time:   0.003526

count  total (s)   self (s)
  137   0.007340   0.003387   return getftime(self.path(a:path)) != -1

FUNCTION  ctrlp#clr()
Called 10 times
Total time:   0.000231
 Self time:   0.000231

count  total (s)   self (s)
   10              0.000207 	let [s:matches, g:ctrlp_new{ a:0 ? a:1 : 'cache' }] = [1, 1]

FUNCTION  <SNR>118_buffer_path()
Called 180 times
Total time:   0.008127
 Self time:   0.006313

count  total (s)   self (s)
  180   0.008036   0.006223   return s:gsub(fnamemodify(bufname(self.number()),':p'),'\\ @!','/')

FUNCTION  <SNR>129_PreviewCSSColorInLine()
Called 45975 times
Total time:   3.436225
 Self time:   3.436225

count  total (s)   self (s)
                              " TODO use cssColor matchdata
45975              0.083820   let n = 1
45975              0.366546   let foundcolor = matchstr( getline(a:where), '#[0-9A-Fa-f]\{3,6\}\>' )
45975              0.105803   while foundcolor != ''
                                if foundcolor =~ '#\x\{6}$'
                                  let color = foundcolor
                                elseif foundcolor =~ '#\x\{3}$'
                                  let color = substitute(foundcolor, '\(\x\)\(\x\)\(\x\)', '\1\1\2\2\3\3', '')
                                else
                                  let color = ''
                                endif
                            
                                if color != ''
                                  call s:SetMatcher(color,foundcolor)
                                endif
                            
                                let n+=1
                                let foundcolor = matchstr( getline(a:where), '#[0-9A-Fa-f]\{3,6}', 0, n )
                              endwhile
                            
                            
45975              0.064529   let n = 1
45975              0.642102   let foundcolorlist = matchlist( getline(a:where), 'rgb[a]\=(\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\).\{-})', 0, n )
45975              0.134683   while len(foundcolorlist) != 0
                                  let foundcolorlist[1] = s:RGBRelativeToAbsolute( foundcolorlist[1] )
                                  let foundcolorlist[2] = s:RGBRelativeToAbsolute( foundcolorlist[2] )
                                  let foundcolorlist[3] = s:RGBRelativeToAbsolute( foundcolorlist[3] )
                            
                                  let color = "#".join( foundcolorlist[1:3], "" )
                            
                                  call s:SetMatcher( color, foundcolorlist[0] )
                            
                                  let n+=1
                                  let foundcolorlist = matchlist( getline(a:where), 'rgb[a]\=(\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\).\{-})', 0, n )
                              endw
45975              0.049056   return 0

FUNCTION  syntastic#util#wideMsg()
Called 132 times
Total time:   3.512720
 Self time:   0.015458

count  total (s)   self (s)
  132              0.000529     let old_ruler = &ruler
  132              0.000362     let old_showcmd = &showcmd
                            
                                "This is here because it is possible for some error messages to
                                "begin with \n which will cause a "press enter" prompt.
  132              0.000915     let msg = substitute(a:msg, "\n", '', 'g')
                            
                                "convert tabs to spaces so that the tabs count towards the window
                                "width as the proper amount of characters
  132              0.000762     let chunks = split(msg, "\t", 1)
  132              0.001402     let msg = join(map(chunks[:-2], 'v:val . repeat(" ", &tabstop - s:_width(v:val) % &tabstop)'), '') . chunks[-1]
  132              0.000662     let msg = strpart(msg, 0, &columns - 1)
                            
  132              0.001320     set noruler noshowcmd
  132   3.498323   0.001061     call syntastic#util#redraw(0)
                            
  132              0.005549     echo msg
                            
  132              0.001177     let &ruler = old_ruler
  132              0.000693     let &showcmd = old_showcmd

FUNCTION  <SNR>125_match_window_opts()
Called 109 times
Total time:   0.011580
 Self time:   0.011580

count  total (s)   self (s)
  109              0.002795 	let s:mw_pos = s:mw =~ 'top\|bottom' ? matchstr(s:mw, 'top\|bottom') : exists('g:ctrlp_match_window_bottom') ? ( s:mwbottom ? 'bottom' : 'top' ) : 'bottom'
  109              0.001934 	let s:mw_order = s:mw =~ 'order:[^,]\+' ? matchstr(s:mw, 'order:\zs[^,]\+') : exists('g:ctrlp_match_window_reversed') ? ( s:mwreverse ? 'btt' : 'ttb' ) : 'btt'
  109              0.001397 	let s:mw_max = s:mw =~ 'max:[^,]\+' ? str2nr(matchstr(s:mw, 'max:\zs\d\+')) : exists('g:ctrlp_max_height') ? s:mxheight : 10
  109              0.000985 	let s:mw_min = s:mw =~ 'min:[^,]\+' ? str2nr(matchstr(s:mw, 'min:\zs\d\+')) : 1
  109              0.001097 	let [s:mw_max, s:mw_min] = [max([s:mw_max, 1]), max([s:mw_min, 1])]
  109              0.000535 	let s:mw_min = min([s:mw_min, s:mw_max])
  109              0.001428 	let s:mw_res = s:mw =~ 'results:[^,]\+' ? str2nr(matchstr(s:mw, 'results:\zs\d\+')) : min([s:mw_max, &lines])
  109              0.000506 	let s:mw_res = max([s:mw_res, 1])

FUNCTION  <SNR>118_startswith()
Called 17397 times
Total time:   0.080946
 Self time:   0.080946

count  total (s)   self (s)
17397              0.072476   return strpart(a:string, 0, strlen(a:prefix)) ==# a:prefix

FUNCTION  220()
Called 147 times
Total time:   0.020524
 Self time:   0.020524

count  total (s)   self (s)
  147              0.000712     if exists("t:NERDTreeBufName")
  147              0.019662         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                return -1

FUNCTION  221()
Called 86 times
Total time:   0.013426
 Self time:   0.000699

count  total (s)   self (s)
   86   0.013360   0.000632     return s:NERDTree.GetWinNum() != -1

FUNCTION  222()
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000007     return self._type == "tab"

FUNCTION  224()
Called 28 times
Total time:   0.003952
 Self time:   0.000280

count  total (s)   self (s)
   28   0.003825   0.000152     if !s:NERDTree.IsOpen()
                                    throw "NERDTree.TreeNotOpen"
                                endif

FUNCTION  225()
Called 15 times
Total time:   0.004409
 Self time:   0.001283

count  total (s)   self (s)
   15              0.000484     let newObj = copy(self)
   15   0.001367   0.000218     let newObj.ui = g:NERDTreeUI.New(newObj)
   15   0.002357   0.000381     let newObj.root = g:NERDTreeDirNode.New(a:path, newObj)
   15              0.000056     let newObj._type = a:type
   15              0.000030     return newObj

FUNCTION  226()
Called 4493 times
Total time:   0.029436
 Self time:   0.029436

count  total (s)   self (s)
 4493              0.012532     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
                                endif
 4493              0.005765     return s:NERDTree._PathFilters

FUNCTION  229()
Called 67 times
Total time:   0.645799
 Self time:   0.000370

count  total (s)   self (s)
   67   0.645756   0.000327     call self.ui.render()

FUNCTION  gitgutter#diff#is_modified_and_added()
Called 156 times
Total time:   0.001366
 Self time:   0.001366

count  total (s)   self (s)
  156              0.000762   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  GitGutterGetHunkSummary()
Called 66 times
Total time:   0.002284
 Self time:   0.000463

count  total (s)   self (s)
   66   0.002238   0.000417   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
Called 31449 times
Total time:   1.926340
 Self time:   0.404539

count  total (s)   self (s)
31449   1.891106   0.369304   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>79_Highlight_Matching_Pair()
Called 21090 times
Total time:   5.921578
 Self time:   5.921578

count  total (s)   self (s)
                              " Remove any previous match.
21090              0.205347   if exists('w:paren_hl_on') && w:paren_hl_on
 1414              0.008981     silent! call matchdelete(3)
 1414              0.006516     let w:paren_hl_on = 0
 1414              0.002325   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
21090              0.145005   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
21090              0.103923   let c_lnum = line('.')
21090              0.080926   let c_col = col('.')
21090              0.046855   let before = 0
                            
21090              0.091912   let text = getline(c_lnum)
21090              0.112434   let c = text[c_col - 1]
21090              0.464855   let plist = split(&matchpairs, '.\zs[:,]')
21090              0.117522   let i = index(plist, c)
21090              0.043524   if i < 0
                                " not found, in Insert mode try character before the cursor
19444              0.104489     if c_col > 1 && (mode() == 'i' || mode() == 'R')
10799              0.023859       let before = 1
10799              0.043835       let c = text[c_col - 2]
10799              0.050626       let i = index(plist, c)
10799              0.011821     endif
19444              0.029724     if i < 0
                                  " not found, nothing to do
19420              0.029582       return
                                endif
   24              0.000024   endif
                            
                              " Figure out the arguments for searchpairpos().
 1670              0.003096   if i % 2 == 0
  383              0.001169     let s_flags = 'nW'
  383              0.002058     let c2 = plist[i + 1]
  383              0.000569   else
 1287              0.003310     let s_flags = 'nbW'
 1287              0.003061     let c2 = c
 1287              0.005838     let c = plist[i - 1]
 1287              0.001537   endif
 1670              0.004518   if c == '['
  229              0.000403     let c = '\['
  229              0.000377     let c2 = '\]'
  229              0.000200   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
 1670              0.003078   if before > 0
   24              0.000192     let has_getcurpos = exists("*getcurpos")
   24              0.000058     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
   24              0.000158       let save_cursor = getcurpos()
   24              0.000038     else
                                  let save_cursor = winsaveview()
                                endif
   24              0.000187     call cursor(c_lnum, c_col - before)
   24              0.000037   endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
 1670              0.011423   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
 1670              1.643171   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
 1670              0.009081   let stoplinebottom = line('w$')
 1670              0.008221   let stoplinetop = line('w0')
 1670              0.003657   if i % 2 == 0
  383              0.001154     let stopline = stoplinebottom
  383              0.000445   else
 1287              0.003297     let stopline = stoplinetop
 1287              0.001315   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
 1670              0.006908   if mode() == 'i' || mode() == 'R'
  809              0.005891     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
  809              0.000835   else
  861              0.006100     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
  861              0.000969   endif
 1670              0.002596   try
 1670              1.639029     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
 1670              0.005324   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
 1670              0.003076   if before > 0
   24              0.000034     if has_getcurpos
   24              0.000105       call setpos('.', save_cursor)
   24              0.000023     else
                                  call winrestview(save_cursor)
                                endif
   24              0.000019   endif
                            
                              " If a match is found setup match highlighting.
 1670              0.006228   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
 1418              0.005318     if exists('*matchaddpos')
 1418              0.055865       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
 1418              0.002413     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
 1418              0.004362     let w:paren_hl_on = 1
 1418              0.001422   endif

FUNCTION  airline#extensions#quickfix#apply()
Called 708 times
Total time:   0.008563
 Self time:   0.008563

count  total (s)   self (s)
  708              0.002909   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  emmet#lang#haml#parseIntoTree()
Called 26 times
Total time:   0.215521
 Self time:   0.001263

count  total (s)   self (s)
   26   0.215498   0.001239   return emmet#lang#html#parseIntoTree(a:abbr, a:type)

FUNCTION  <SNR>65_repo_tree()
Called 105 times
Total time:   0.005160
 Self time:   0.003947

count  total (s)   self (s)
  105   0.001620   0.001003   if self.dir() =~# '/\.git$'
  105   0.001335   0.000738     let dir = self.dir()[0:-6]
  105              0.000364     if dir !~# '/'
                                  let dir .= '/'
                                endif
  105              0.000072   else
                                let dir = s:configured_tree(self.git_dir)
                              endif
  105              0.000149   if dir ==# ''
                                call s:throw('no work tree')
                              else
  105              0.000410     return join([dir]+a:000,'/')
                              endif

FUNCTION  gitgutter#hunk#increment_lines_removed()
Called 1 time
Total time:   0.000060
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000014   0.000011   let bufnr = gitgutter#utility#bufnr()
    1   0.000025   0.000005   let summary = gitgutter#hunk#summary(bufnr)
    1              0.000003   let summary[2] += a:count
    1   0.000017   0.000005   call gitgutter#utility#setbufvar(bufnr, 'summary', summary)

FUNCTION  <SNR>111_get_seperator()
Called 22467 times
Total time:  15.074731
 Self time:   0.310168

count  total (s)   self (s)
22467   5.340251   0.135332   if s:should_change_group(a:prev_group, a:group)
16256   9.671705   0.112060     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
 6211              0.018459     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  gitgutter#utility#strip_trailing_new_line()
Called 2 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    2              0.000087   return substitute(a:line, '\n$', '', '')

FUNCTION  xolox#misc#msg#debug()
Called 19572 times
Total time:   0.503917
 Self time:   0.503917

count  total (s)   self (s)
                              " Show a formatted debugging message to the user, *if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [] option to one
                              " (1) or higher*.
                              "
                              " This function has the same argument handling as the
                              " `xolox#misc#msg#info()` function.
                              "
                              " In the case of `xolox#misc#msg#debug()`, automatic string coercion
                              " provides lazy evaluation in the sense that complex data structures are
                              " only converted to strings when the user has enabled increased verbosity.
                              "
                              " ['verbose']: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
19572              0.099011   if &vbs >= 1
                                call s:show_message('Question', a:000)
                              endif

FUNCTION  gitgutter#utility#stringify()
Called 1444 times
Total time:   0.014568
 Self time:   0.014568

count  total (s)   self (s)
 1444              0.010077   return join(a:list, "\n")."\n"

FUNCTION  <SNR>32_activateDirNode()
Called 50 times
Total time:   0.893712
 Self time:   0.000274

count  total (s)   self (s)
   50   0.893681   0.000243     call a:node.activate()

FUNCTION  230()
Called 3 times
Total time:   0.000588
 Self time:   0.000125

count  total (s)   self (s)
    3              0.000013     if g:NERDTreeAutoCenter
    3              0.000028         let current_line = winline()
    3              0.000011         let lines_to_top = current_line
    3   0.000498   0.000035         let lines_to_bottom = winheight(g:NERDTree.GetWinNum()) - current_line
    3              0.000017         if lines_to_top < g:NERDTreeAutoCenterThreshold || lines_to_bottom < g:NERDTreeAutoCenterThreshold
                                        normal! zz
                                    endif
    3              0.000002     endif

FUNCTION  231()
Called 67 times
Total time:   0.013281
 Self time:   0.012874

count  total (s)   self (s)
   67   0.000504   0.000321     if self.getShowHelp()
    1   0.000011   0.000009         let help  = "\" NERD tree (" . nerdtree#version() . ") quickhelp~\n"
    1              0.000003         let help .= "\" ============================\n"
    1              0.000002         let help .= "\" File node mappings~\n"
    1              0.000004         let help .= "\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
    1              0.000002         let help .= "\" <CR>,\n"
    1   0.000014   0.000009         if self.nerdtree.isTabTree()
    1              0.000006             let help .= "\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
    1              0.000002         else
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
    1   0.000009   0.000006         if self.nerdtree.isTabTree()
    1              0.000004             let help .= "\" ". g:NERDTreeMapPreview .": preview\n"
    1              0.000001         endif
    1              0.000004         let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
    1              0.000005         let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
    1              0.000002         let help .= "\" middle-click,\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapOpenSplit .": open split\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
    1              0.000002         let help .= "\"\n\" ----------------------------\n"
    1              0.000002         let help .= "\" Directory node mappings~\n"
    1              0.000003         let help .= "\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapActivateNode .": open & close node\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
    1              0.000003         let help .= "\"    current node recursively\n"
    1              0.000002         let help .= "\" middle-click,\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
    1              0.000004         let help .= "\"\n\" ----------------------------\n"
    1              0.000003         let help .= "\" Bookmark table mappings~\n"
    1              0.000002         let help .= "\" double-click,\n"
    1              0.000002         let help .= "\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
    1              0.000002         let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
    1              0.000002         let help .= "\"\n\" ----------------------------\n"
    1              0.000002         let help .= "\" Tree navigation mappings~\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapJumpRoot .": go to root\n"
    1              0.000002         let help .= "\" ". g:NERDTreeMapJumpParent .": go to parent\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
    1              0.000002         let help .= "\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
    1              0.000002         let help .= "\"\n\" ----------------------------\n"
    1              0.000002         let help .= "\" Filesystem mappings~\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
    1              0.000002         let help .= "\"    selected dir\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
    1              0.000002         let help .= "\"    but leave old root open\n"
    1              0.000002         let help .= "\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
    1              0.000002         let help .= "\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
    1              0.000002         let help .= "\" ". g:NERDTreeMapMenu .": Show menu\n"
    1              0.000002         let help .= "\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
    1              0.000002         let help .= "\"    selected dir\n"
    1              0.000002         let help .= "\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
    1              0.000002         let help .= "\"\n\" ----------------------------\n"
    1              0.000003         let help .= "\" Tree filtering mappings~\n"
    1   0.000009   0.000007         let help .= "\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (self.getShowHidden() ? "on" : "off") . ")\n"
    1   0.000008   0.000006         let help .= "\" ". g:NERDTreeMapToggleFilters .": file filters (" . (self.isIgnoreFilterEnabled() ? "on" : "off") . ")\n"
    1   0.000008   0.000006         let help .= "\" ". g:NERDTreeMapToggleFiles .": files (" . (self.getShowFiles() ? "on" : "off") . ")\n"
    1   0.000007   0.000006         let help .= "\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (self.getShowBookmarks() ? "on" : "off") . ")\n"
                            
                                    "add quickhelp entries for each custom key map
    1              0.000002         let help .= "\"\n\" ----------------------------\n"
    1              0.000002         let help .= "\" Custom mappings~\n"
   51   0.000041   0.000036         for i in g:NERDTreeKeyMap.All()
   50              0.000066             if !empty(i.quickhelpText)
                                            let help .= "\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
   50              0.000025         endfor
                            
    1              0.000002         let help .= "\"\n\" ----------------------------\n"
    1              0.000002         let help .= "\" Other mappings~\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
    1              0.000003         let help .= "\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
    1              0.000003         let help .= "\"    the NERDTree window\n"
    1              0.000002         let help .= "\" ". g:NERDTreeMapHelp .": toggle help\n"
    1              0.000002         let help .= "\"\n\" ----------------------------\n"
    1              0.000002         let help .= "\" Bookmark commands~\n"
    1              0.000002         let help .= "\" :Bookmark [<name>]\n"
    1              0.000002         let help .= "\" :BookmarkToRoot <name>\n"
    1              0.000002         let help .= "\" :RevealBookmark <name>\n"
    1              0.000002         let help .= "\" :OpenBookmark <name>\n"
    1              0.000002         let help .= "\" :ClearBookmarks [<names>]\n"
    1              0.000002         let help .= "\" :ClearAllBookmarks\n"
    1              0.000045         silent! put =help
    1              0.000003     elseif !self.isMinimal()
   66              0.000291         let help ="\" Press ". g:NERDTreeMapHelp ." for help\n"
   66              0.001486         silent! put =help
   66              0.000245     endif

FUNCTION  232()
Called 15 times
Total time:   0.001149
 Self time:   0.001149

count  total (s)   self (s)
   15              0.000603     let newObj = copy(self)
   15              0.000091     let newObj.nerdtree = a:nerdtree
   15              0.000064     let newObj._showHelp = 0
   15              0.000052     let newObj._ignoreEnabled = 1
   15              0.000088     let newObj._showFiles = g:NERDTreeShowFiles
   15              0.000068     let newObj._showHidden = g:NERDTreeShowHidden
   15              0.000070     let newObj._showBookmarks = g:NERDTreeShowBookmarks
                            
   15              0.000049     return newObj

FUNCTION  233()
Called 56 times
Total time:   0.153159
 Self time:   0.032413

count  total (s)   self (s)
   56              0.000517     let line = getline(a:ln)
                            
   56   0.008184   0.000580     let rootLine = self.getRootLineNum()
                            
                                "check to see if we have the root node
   56              0.000184     if a:ln == rootLine
    1              0.000002         return self.nerdtree.root.path
                                endif
                            
   55   0.000792   0.000574     if line ==# s:UI.UpDirLine()
                                    return self.nerdtree.root.path.getParent()
                                endif
                            
   55   0.004902   0.000518     let indent = self._indentLevelFor(line)
                            
                                "remove the tree parts and the leading space
   55   0.008914   0.000559     let curFile = self._stripMarkup(line, 0)
                            
   55              0.000141     let wasdir = 0
   55              0.000317     if curFile =~# '/$'
   50              0.000138         let wasdir = 1
   50              0.000541         let curFile = substitute(curFile, '/\?$', '/', "")
   50              0.000077     endif
                            
   55              0.000133     let dir = ""
   55              0.000173     let lnum = a:ln
  455              0.000914     while lnum > 0
  452              0.001520         let lnum = lnum - 1
  452              0.001867         let curLine = getline(lnum)
  452   0.055059   0.003748         let curLineStripped = self._stripMarkup(curLine, 1)
                            
                                    "have we reached the top of the tree?
  452              0.001091         if lnum == rootLine
   52   0.007404   0.000904             let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
   52              0.000088             break
                                    endif
  400              0.002029         if curLineStripped =~# '/$'
  329   0.018161   0.003247             let lpindent = self._indentLevelFor(curLine)
  329              0.000932             if lpindent < indent
   58              0.000202                 let indent = indent - 1
                            
   58              0.000507                 let dir = substitute (curLineStripped,'^\\', "", "") . dir
   58              0.000136                 continue
                                        endif
  271              0.000241         endif
  342              0.000462     endwhile
   55              0.000311     let curFile = self.nerdtree.root.path.drive . dir . curFile
   55   0.201687   0.174228     let toReturn = g:NERDTreePath.New(curFile)
   52              0.000108     return toReturn

FUNCTION  234()
Called 66 times
Total time:   0.084636
 Self time:   0.019921

count  total (s)   self (s)
                                "if the node is the root then return the root line no.
   66   0.017096   0.000348     if a:file_node.isRoot()
   15   0.001044   0.000081         return self.getRootLineNum()
                                endif
                            
   51              0.000141     let totalLines = line("$")
                            
                                "the path components we have matched so far
   51   0.004546   0.001040     let pathcomponents = [substitute(self.nerdtree.root.path.str({'format': 'UI'}), '/ *$', '', '')]
                                "the index of the component we are searching for
   51              0.000110     let curPathComponent = 1
                            
   51   0.003653   0.000377     let fullpath = a:file_node.path.str({'format': 'UI'})
                            
   51   0.002219   0.000211     let lnum = self.getRootLineNum()
  371              0.000492     while lnum > 0
  371              0.000810         let lnum = lnum + 1
                                    "have we reached the bottom of the tree?
  371              0.000698         if lnum ==# totalLines+1
                                        return -1
                                    endif
                            
  371              0.000901         let curLine = getline(lnum)
                            
  371   0.012604   0.001779         let indent = self._indentLevelFor(curLine)
  371              0.000717         if indent ==# curPathComponent
  371   0.029126   0.001737             let curLine = self._stripMarkup(curLine, 1)
                            
  371              0.001758             let curPath =  join(pathcomponents, '/') . '/' . curLine
  371              0.001149             if stridx(fullpath, curPath, 0) ==# 0
  109              0.000470                 if fullpath ==# curPath || strpart(fullpath, len(curPath)-1,1) ==# '/'
  109              0.000643                     let curLine = substitute(curLine, '/ *$', '', '')
  109              0.000359                     call add(pathcomponents, curLine)
  109              0.000301                     let curPathComponent = curPathComponent + 1
                            
  109              0.000185                     if fullpath ==# curPath
   51              0.000059                         return lnum
                                                endif
   58              0.000034                 endif
   58              0.000031             endif
  320              0.000167         endif
  320              0.000218     endwhile
                                return -1

FUNCTION  235()
Called 122 times
Total time:   0.010575
 Self time:   0.010575

count  total (s)   self (s)
  122              0.000374     let rootLine = 1
  731              0.005890     while getline(rootLine) !~# '^\(/\|<\)'
  609              0.002262         let rootLine = rootLine + 1
  609              0.000943     endwhile
  122              0.000221     return rootLine

FUNCTION  236()
Called 68 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
   68              0.000149     return self._showBookmarks

FUNCTION  237()
Called 4494 times
Total time:   0.008297
 Self time:   0.008297

count  total (s)   self (s)
 4494              0.006580     return self._showFiles

FUNCTION  238()
Called 67 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
   67              0.000147     return self._showHelp

FUNCTION  239()
Called 4494 times
Total time:   0.008257
 Self time:   0.008257

count  total (s)   self (s)
 4494              0.006567     return self._showHidden

FUNCTION  gitgutter#async#execute()
Called 2111 times
Total time:  21.063931
 Self time:  20.800521

count  total (s)   self (s)
 2111   0.030521   0.023117   let bufnr = gitgutter#utility#bufnr()
                            
 2111              0.012826   if has('nvim')
 2111              0.005315     if has('unix')
 2111              0.014681       let command = ["sh", "-c", a:cmd]
 2111              0.006139     elseif has('win32')
                                  let command = ["cmd.exe", "/c", a:cmd]
                                else
                                  throw 'unknown os'
                                endif
                                " Make the job use a shell while avoiding (un)quoting problems.
 2111             20.430512     let job_id = jobstart(command, { 'buffer':    bufnr, 'on_stdout': function('gitgutter#async#handle_diff_job_nvim'), 'on_stderr': function('gitgutter#async#handle_diff_job_nvim'), 'on_exit':   function('gitgutter#async#handle_diff_job_nvim') })
 2111   0.331033   0.132364     call gitgutter#debug#log('[nvim job: '.job_id.', buffer: '.bufnr.'] '.a:cmd)
 2111              0.007202     if job_id < 1
                                  throw 'diff failed'
                                endif
                            
                                " Note that when `cmd` doesn't produce any output, i.e. the diff is empty,
                                " the `stdout` event is not fired on the job handler.  Therefore we keep
                                " track of the jobs ourselves so we can spot empty diffs.
 2111   0.078237   0.020900     call s:job_started(job_id)
                            
 2111              0.002536   else
                                " Make the job use a shell.
                                "
                                " Pass a handler for stdout but not for stderr so that errors are
                                " ignored (and thus signs are not updated; this assumes that an error
                                " only occurs when a file is not tracked by git).
                            
                                if has('unix')
                                  let command = ["sh", "-c", a:cmd]
                                elseif has('win32')
                                  let command = "cmd.exe /c ".a:cmd
                                else
                                  throw 'unknown os'
                                endif
                            
                                let job = job_start(command, { 'out_cb':   'gitgutter#async#handle_diff_job_vim', 'close_cb': 'gitgutter#async#handle_diff_job_vim_close' })
                                call gitgutter#debug#log('[vim job: '.string(job_info(job)).', buffer: '.bufnr.'] '.a:cmd)
                            
                                call s:job_started(s:channel_id(job_getchannel(job)), bufnr)
                              endif

FUNCTION  <SNR>118_gsub()
Called 16294 times
Total time:   0.109802
 Self time:   0.109802

count  total (s)   self (s)
16294              0.101606   return substitute(a:str,'\v\C'.a:pat,a:rep,'g')

FUNCTION  gitgutter#utility#file_relative_to_repo_root()
Called 1192 times
Total time:   0.157308
 Self time:   0.070812

count  total (s)   self (s)
 1192   0.043790   0.017104   let file_path_relative_to_repo_root = gitgutter#utility#getbufvar(s:bufnr, 'repo_relative_path')
 1192              0.007397   if empty(file_path_relative_to_repo_root)
    2   0.059672   0.000100     let dir_path_relative_to_repo_root = gitgutter#utility#system(gitgutter#utility#command_in_directory_of_file(g:gitgutter_git_executable.' rev-parse --show-prefix'))
    2   0.000170   0.000075     let dir_path_relative_to_repo_root = gitgutter#utility#strip_trailing_new_line(dir_path_relative_to_repo_root)
    2   0.000062   0.000032     let file_path_relative_to_repo_root = dir_path_relative_to_repo_root . gitgutter#utility#filename()
    2   0.000146   0.000033     call gitgutter#utility#setbufvar(s:bufnr, 'repo_relative_path', file_path_relative_to_repo_root)
    2              0.000004   endif
 1192              0.004345   return file_path_relative_to_repo_root

FUNCTION  <SNR>118_readable_calculate_file_type()
Called 137 times
Total time:   0.101667
 Self time:   0.064638

count  total (s)   self (s)
  137   0.031864   0.000637   let f = self.name()
  137              0.001391   let e = matchstr(f, '\.\zs[^.\/]\+$')
  137              0.000257   let ae = e
  137              0.000213   if ae ==# 'erb'
                                let ae = matchstr(f, '\.\zs[^.\/]\+\ze\.erb$')
                              endif
  137              0.000181   let r = "-"
  137   0.006534   0.000733   let full_path = self.path()
  137              0.026924   let nr = bufnr('^'.full_path.'$')
  137              0.000453   if nr < 0 && exists('+shellslash') && ! &shellslash
                                let nr = bufnr('^'.s:gsub(full_path,'/','\\').'$')
                              endif
  137              0.000201   if f == ""
                                let r = f
                              elseif nr > 0 && getbufvar(nr,'rails_file_type') != ''
                                return getbufvar(nr,'rails_file_type')
                              elseif f =~# '\<app/controllers/concerns/.*\.rb$'
                                let r = "controller-concern"
                              elseif f =~ '_controller\.rb$' || f =~ '\<app/controllers/.*\.rb$'
   11              0.000022     let r = "controller"
   11              0.000012   elseif f =~ '\<test/test_helper\.rb$'
                                let r = "test"
                              elseif f =~ '\<spec/\%(spec\|rails\)_helper\.rb$'
                                let r = "spec"
                              elseif f =~ '_helper\.rb$'
                                let r = "helper"
                              elseif f =~ '\<app/mailers/.*\.rb'
                                let r = "mailer"
                              elseif f =~ '\<app/jobs/.*\.rb'
                                let r = "job"
                              elseif f =~# '\<app/models/concerns/.*\.rb$'
                                let r = "model-concern"
                              elseif f =~ '\<app/models/'
                                let top = "\n".join(s:readfile(full_path,50),"\n")
                                let class = matchstr(top,"\n".'class\s\+\S\+\s*<\s*\<\zs\S\+\>')
                                let type = tolower(matchstr(class, '^Application\zs[A-Z]\w*$\|^Acti\w\w\zs[A-Z]\w*\ze::Base'))
                                if type ==# 'mailer' || f =~ '_mailer\.rb$'
                                  let r = 'mailer'
                                elseif class ==# 'ActiveRecord::Observer'
                                  let r = 'model-observer'
                                elseif !empty(type)
                                  let r = 'model-'.type
                                elseif top =~ '\<\%(self\.\%(table_name\|primary_key\)\|has_one\|has_many\|belongs_to\)\>'
                                  let r = 'model-record'
                                else
                                  let r = 'model'
                                endif
                              elseif f =~ '\<app/views/.*/_\w\+\%(\.[[:alnum:]_+]\+\)\=\.\w\+$'
   37              0.000103     let r = "view-partial-" . e
   37              0.000042   elseif f =~ '\<app/views/layouts\>.*\.'
    2              0.000008     let r = "view-layout-" . e
    2              0.000003   elseif f =~ '\<app/views\>.*\.'
   15              0.000041     let r = "view-" . e
   15              0.000018   elseif f =~ '\<test/unit/.*_helper\.rb$'
                                let r = "test-helper"
                              elseif f =~ '\<test/unit/.*\.rb$'
                                let r = "test-model"
                              elseif f =~ '\<test/functional/.*_controller_test\.rb$'
                                let r = "test-controller"
                              elseif f =~ '\<test/integration/.*_test\.rb$'
                                let r = "test-integration"
                              elseif f =~ '\<test/lib/.*_test\.rb$'
                                let r = "test-lib"
                              elseif f =~ '\<test/\w*s/.*_test\.rb$'
                                let r = s:sub(f,'.*<test/(\w*)s/.*','test-\1')
                              elseif f =~ '\<test/.*_test\.rb'
                                let r = "test"
                              elseif f =~ '\<spec/lib/.*_spec\.rb$'
                                let r = 'spec-lib'
                              elseif f =~ '\<lib/.*\.rb$'
                                let r = 'lib'
                              elseif f =~ '\<spec/\w*s/.*_spec\.rb$'
                                let r = s:sub(f,'.*<spec/(\w*)s/.*','spec-\1')
                              elseif f =~ '\<features/.*\.feature$'
                                let r = 'cucumber-feature'
                              elseif f =~ '\<features/step_definitions/.*_steps\.rb$'
                                let r = 'cucumber-steps'
                              elseif f =~ '\<features/.*\.rb$'
                                let r = 'cucumber'
                              elseif f =~ '\<spec/.*\.feature$'
                                let r = 'spec-feature'
                              elseif f =~ '\<\%(test\|spec\)/fixtures\>'
                                if e == "yml"
                                  let r = "fixtures-yaml"
                                else
                                  let r = "fixtures" . (e == "" ? "" : "-" . e)
                                endif
                              elseif f =~ '\<\%(test\|spec\)/\%(factories\|fabricators\)\>'
                                let r = "fixtures-replacement"
                              elseif f =~ '\<spec/.*_spec\.rb'
                                let r = "spec"
                              elseif f =~ '\<spec/support/.*\.rb'
                                let r = "spec"
                              elseif f =~ '\<db/migrate\>'
                                let r = "db-migration"
                              elseif f=~ '\<db/schema\.rb$'
                                let r = "db-schema"
                              elseif f =~ '\.rake$' || f =~ '\<\%(Rake\|Cap\)file$' || f =~ '\<config/deploy\.rb$' || f =~ '\<config/deploy/.*\.rb$'
                                let r = "task"
                              elseif f =~ '\<log/.*\.log$'
                                let r = "log"
                              elseif ae ==# "css" || ae =~# "^s[ac]ss$" || ae == "^less$"
   40              0.000104     let r = "stylesheet-".ae
   40              0.000048   elseif ae ==# "js" || ae ==# "es6"
                                let r = "javascript"
                              elseif ae == "coffee"
                                let r = "javascript-coffee"
                              elseif e == "html"
                                let r = e
                              elseif f =~ '\<config/routes\>.*\.rb$'
                                let r = "config-routes"
                              elseif f =~ '\<config/'
                                let r = "config"
                              endif
  137              0.000172   return r

FUNCTION  <SNR>65_sub()
Called 414 times
Total time:   0.005431
 Self time:   0.005431

count  total (s)   self (s)
  414              0.005151   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  <SNR>118_app_engines()
Called 97 times
Total time:   0.010443
 Self time:   0.003586

count  total (s)   self (s)
   97   0.005603   0.000426   let gems = self.gems()
   97   0.001041   0.000405   if self.cache.needs('engines', gems)
   97              0.000518     let gempath = escape(join(values(gems),','), ' ')
   97              0.000196     if empty(gempath)
   97   0.001123   0.000525       call self.cache.set('engines', [], gems)
   97              0.000088     else
                                  call self.cache.set('engines', sort(map(finddir('app', gempath, -1), 'fnamemodify(v:val, ":h")')), gems)
                                endif
   97              0.000064   endif
   97   0.000829   0.000384   return self.cache.get('engines')

FUNCTION  syntastic#util#fname2buf()
Called 1209 times
Total time:   0.414080
 Self time:   0.414080

count  total (s)   self (s)
 1209              0.006907     if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
                                endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
 1311              0.007869     for md in [':~:.', ':~', ':p']
 1281              0.345661         let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
 1281              0.004489         if buf != -1
 1179              0.002513             break
                                    endif
  102              0.000273     endfor
 1209              0.002236     if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
   30              0.007360         let buf = bufnr(fnamemodify(a:fname, ':p'))
   30              0.000057     endif
                            
 1209              0.004148     if exists('+shellslash')
                                    let &shellslash = old_shellslash
                                endif
                            
 1209              0.002193     return buf

FUNCTION  <SNR>107_Get()
Called 2077915 times
Total time:  14.055237
 Self time:  14.055237

count  total (s)   self (s)
2077915              6.815199   if get(a:dict, a:key, a:default) isnot# a:default
1491298              4.007322     return a:prefix. get(a:dict, a:key)
                              else
586617              0.492342     return ''
                              endif

FUNCTION  <SNR>125_glbpath()
Called 1 time
Total time:   0.080654
 Self time:   0.000027

count  total (s)   self (s)
    1   0.080653   0.000026 	retu call('ctrlp#utils#globpath', a:000)

FUNCTION  emmet#util#unique()
Called 25 times
Total time:   0.000948
 Self time:   0.000948

count  total (s)   self (s)
   25              0.000078   let m = {}
   25              0.000042   let r = []
   77              0.000102   for i in a:arr
   52              0.000110     if !has_key(m, i)
   51              0.000101       let m[i] = 1
   51              0.000116       call add(r, i)
   51              0.000035     endif
   52              0.000033   endfor
   25              0.000028   return r

FUNCTION  gitgutter#diff#is_removed()
Called 157 times
Total time:   0.000723
 Self time:   0.000723

count  total (s)   self (s)
  157              0.000636   return a:from_count > 0 && a:to_count == 0

FUNCTION  <SNR>125_dosigns()
Called 2104 times
Total time:   0.013053
 Self time:   0.013053

count  total (s)   self (s)
 2104              0.011601 	retu exists('s:marked') && s:bufnr > 0 && s:opmul != '0' && has('signs')

FUNCTION  240()
Called 755 times
Total time:   0.030124
 Self time:   0.028212

count  total (s)   self (s)
                                "have to do this work around because match() returns bytes, not chars
  755              0.009420     let numLeadBytes = match(a:line, '\M\[^ '.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.']')
                                " The next line is a backward-compatible workaround for strchars(a:line(0:numLeadBytes-1]). strchars() is in 7.3+
  755              0.010958     let leadChars = len(split(a:line[0:numLeadBytes-1], '\zs'))
                            
  755   0.007609   0.005697     return leadChars / s:UI.IndentWid()

FUNCTION  241()
Called 755 times
Total time:   0.001912
 Self time:   0.001912

count  total (s)   self (s)
  755              0.001390     return 2

FUNCTION  242()
Called 4494 times
Total time:   0.009035
 Self time:   0.009035

count  total (s)   self (s)
 4494              0.007370     return self._ignoreEnabled == 1

FUNCTION  243()
Called 200 times
Total time:   0.000605
 Self time:   0.000605

count  total (s)   self (s)
  200              0.000473     return g:NERDTreeMinimalUI

FUNCTION  244()
Called 878 times
Total time:   0.007073
 Self time:   0.007073

count  total (s)   self (s)
  878              0.006496     return '^\(['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+\)'

FUNCTION  247()
Called 28 times
Total time:   0.009770
 Self time:   0.001031

count  total (s)   self (s)
   28              0.000113     let win = winnr()
   28   0.008387   0.000144     call g:NERDTree.CursorToTreeWin()
   28              0.000144     let self._screenState = {}
   28              0.000158     let self._screenState['oldPos'] = getpos(".")
   28              0.000130     let self._screenState['oldTopLine'] = line("w0")
   28              0.000096     let self._screenState['oldWindowSize']= winwidth("")
   28   0.000658   0.000162     call nerdtree#exec(win . "wincmd w")

FUNCTION  249()
Called 878 times
Total time:   0.087055
 Self time:   0.079982

count  total (s)   self (s)
  878              0.002551     let line = a:line
                                "remove the tree parts and the leading space
  878   0.021211   0.014137     let line = substitute (line, g:NERDTreeUI.MarkupReg(),"","")
                            
                                "strip off any read only flag
  878              0.006875     let line = substitute (line, ' \['.g:NERDTreeGlyphReadOnly.'\]', "","")
                            
                                "strip off any bookmark flags
  878              0.005705     let line = substitute (line, ' {[^}]*}', "","")
                            
                                "strip off any executable flags
  878              0.005474     let line = substitute (line, '*\ze\($\| \)', "","")
                            
                                "strip off any generic flags
  878              0.005112     let line = substitute (line, '\[[^]]*\]', "","")
                            
  878              0.001909     let wasdir = 0
  878              0.003770     if line =~# '/$'
  798              0.001712         let wasdir = 1
  798              0.000809     endif
  878              0.005251     let line = substitute (line,' -> .*',"","") " remove link to
  878              0.001643     if wasdir ==# 1
  798              0.006761         let line = substitute (line, '/\?$', '/', "")
  798              0.000950     endif
                            
  878              0.001693     if a:removeLeadingSpaces
  823              0.005228         let line = substitute (line, '^ *', '', '')
  823              0.000928     endif
                            
  878              0.001347     return line

FUNCTION  airline#extensions#wordcount#apply()
Called 601 times
Total time:   0.017844
 Self time:   0.017844

count  total (s)   self (s)
  601              0.014964   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  gitgutter#utility#has_unsaved_changes()
Called 936 times
Total time:   0.006768
 Self time:   0.006768

count  total (s)   self (s)
  936              0.006005   return getbufvar(s:bufnr, "&mod")

FUNCTION  <SNR>118_readable_projected_with_raw()
Called 499 times
Total time:   3.678755
 Self time:   0.528124

count  total (s)   self (s)
  499   0.131219   0.002834   let f = self.name()
  499   2.747517   0.004744   let all = self.app().projections()
  499              0.000827   let mine = []
  499              0.001460   if has_key(all, f)
                                let mine += map(s:getlist(all[f], a:key), '[s:expand_placeholders(v:val, a:0 ? a:1 : {}), v:val]')
                              endif
13972   0.408945   0.206104   for pattern in reverse(sort(filter(keys(all), 'v:val =~# "^[^*{}]*\\*[^*{}]*$"'), s:function('rails#lencmp')))
13473              0.071555     let [prefix, suffix; _] = split(pattern, '\*', 1)
13473   0.150347   0.079467     if s:startswith(f, prefix) && s:endswith(f, suffix)
   43              0.000223       let root = f[strlen(prefix) : -strlen(suffix)-1]
   43   0.006133   0.000744       let ph = extend({ 'match': root, 'file': self.path(), 'project': self.app().path(), '%': '%'}, a:0 ? a:1 : {})
   43   0.000774   0.000410       let mine += map(s:getlist(all[pattern], a:key), '[s:expand_placeholders(v:val, ph), v:val]')
   43              0.000039     endif
13473              0.010609   endfor
  499              0.001554   return filter(mine, '!empty(v:val[0])')

FUNCTION  <SNR>287_itemno()
Called 25 times
Total time:   0.000469
 Self time:   0.000469

count  total (s)   self (s)
   25              0.000210   let current = a:current
   25              0.000052   if current.basedirect > 0
   25              0.000036     if current.basevalue ==# 0
   25              0.000036       return a:itemno
                                else
                                  return current.basevalue - 1 + a:itemno
                                endif
                              else
                                if current.basevalue ==# 0
                                  return current.multiplier - 1 - a:itemno
                                else
                                  return current.multiplier + current.basevalue - 2 - a:itemno
                                endif
                              endif

FUNCTION  <SNR>269_IsInStringOrComment()
Called 395 times
Total time:   0.143088
 Self time:   0.143088

count  total (s)   self (s)
  395              0.142807   return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_strcom

FUNCTION  <SNR>107_hl_group_exists()
Called 720056 times
Total time:  13.176964
 Self time:  13.176964

count  total (s)   self (s)
720056              4.802744   if !hlexists(a:group)
    8              0.000014     return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
24678              0.025689     return 0
                              endif
695370              0.567505   return 1

FUNCTION  <SNR>118_BufMappings()
Called 137 times
Total time:   0.024554
 Self time:   0.024554

count  total (s)   self (s)
  137              0.001534   if empty(maparg('<Plug><cfile>', 'c'))
                                return
                              endif
  137              0.002825   nmap <buffer><silent> <Plug>RailsFind       <SID>:find <Plug><cfile><CR>
  137              0.001634   nmap <buffer><silent> <Plug>RailsSplitFind  <SID>:sfind <Plug><cfile><CR>
  137              0.001539   nmap <buffer><silent> <Plug>RailsTabFind    <SID>:tabfind <Plug><cfile><CR>
  137              0.000359   let pattern = '^$\|_gf(v:count\|[Rr]uby\|[Rr]ails'
  137              0.002639   if mapcheck('gf', 'n') =~# pattern
  137              0.001138     nmap <buffer> gf         <Plug>RailsFind
  137              0.000123   endif
  137              0.002043   if mapcheck('<C-W>f', 'n') =~# pattern
  137              0.001172     nmap <buffer> <C-W>f     <Plug>RailsSplitFind
  137              0.000117   endif
  137              0.001927   if mapcheck('<C-W><C-F>', 'n') =~# pattern
  137              0.001124     nmap <buffer> <C-W><C-F> <Plug>RailsSplitFind
  137              0.000108   endif
  137              0.001760   if mapcheck('<C-W>gf', 'n') =~# pattern
  137              0.001066     nmap <buffer> <C-W>gf    <Plug>RailsTabFind
  137              0.000106   endif
  137              0.001746   if mapcheck('<C-R><C-F>', 'c') =~# pattern
   34              0.000303     cmap <buffer> <C-R><C-F> <Plug><cfile>
   34              0.000026   endif

FUNCTION  SyntasticMake()
Called 503 times
Total time: 2042.547706
 Self time:   0.329243

count  total (s)   self (s)
  503   0.011806   0.005424     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
  503              0.002885     let old_local_errorformat = &l:errorformat
  503              0.001758     let old_errorformat = &errorformat
  503              0.013649     let old_cwd = getcwd()
                                " }}}3
                            
  503              0.002337     if has_key(a:options, 'errorformat')
  503              0.008230         let &errorformat = a:options['errorformat']
  503              0.002844         set errorformat<
  503              0.000636     endif
                            
  503              0.001765     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
  503              0.001351     let env_save = {}
  503              0.002011     if has_key(a:options, 'env') && len(a:options['env'])
   48              0.000192         for key in keys(a:options['env'])
   24              0.000334             if key =~? '\m^[a-z_][a-z0-9_]*$'
   24              0.000373                 execute 'let env_save[' . string(key) . '] = $' . key
   24              0.000340                 execute 'let $' . key . ' = ' . string(a:options['env'][key])
   24              0.000029             endif
   24              0.000198         endfor
   24              0.000030     endif
                                " }}}3
                            
  503 2042.185953   0.015759     let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
  503              0.002473     if len(env_save)
   48              0.000269         for key in keys(env_save)
   24              0.000314             execute 'let $' . key . ' = ' . string(env_save[key])
   24              0.000032         endfor
   24              0.000018     endif
                                " }}}3
                            
  503   0.010070   0.004671     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
  503   0.017152   0.006635     let bailout = syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
                            
  503              0.000785     if !bailout
  503              0.001258         if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
                                    elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
                                    endif
  503              0.116990         noautocmd lgetexpr err_lines
                            
  503              0.006381         let errors = deepcopy(getloclist(0))
                            
  503              0.001521         if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
                                    endif
                            
  503              0.000638         try
  503              0.013339             silent lolder
  503              0.001695         catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
                                        call setloclist(0, [], 'r')
                                        try
                                            " Vim 7.4.2200 or later
                                            call setloclist(0, [], 'r', { 'title': '' })
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            " do nothing
                                        endtry
                                    catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
                                    endtry
  503              0.000433     else
                                    let errors = []
                                endif
                            
                                " restore options {{{3
  503              0.005992     let &errorformat = old_errorformat
  503              0.003689     let &l:errorformat = old_local_errorformat
                                " }}}3
                            
  503   0.016965   0.011629     if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
  503              0.000814     if bailout
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                                    throw 'Syntastic: checker error'
                                endif
                            
  503   0.010170   0.004082     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
  503              0.001538     if has_key(a:options, 'defaults')
                                    call s:_add_to_errors(errors, a:options['defaults'])
                                endif
                            
                                " Add subtype info if present.
  503              0.001297     if has_key(a:options, 'subtype')
                                    call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
                                endif
                            
  503              0.001921     if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
  592              0.001642         for rule in a:options['postprocess']
  296   0.014270   0.004041             let errors = call('syntastic#postprocess#' . rule, [errors])
  296              0.000421         endfor
  296   0.006879   0.002563         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
  296              0.000331     endif
                            
  503              0.002241     return errors

FUNCTION  250()
Called 67 times
Total time:   0.645429
 Self time:   0.019817

count  total (s)   self (s)
   67              0.000486     setlocal modifiable
                            
                                "remember the top line of the buffer and the current line so we can
                                "restore the view exactly how it was
   67              0.000208     let curLine = line(".")
   67              0.000170     let curCol = col(".")
   67              0.000205     let topLine = line("w0")
                            
                                "delete all lines in the buffer (being careful not to clobber a register)
   67              0.002862     silent 1,$delete _
                            
   67   0.013817   0.000536     call self._dumpHelp()
                            
                                "delete the blank line before the help and add one after it
   67   0.000616   0.000382     if !self.isMinimal()
   67              0.000644         call setline(line(".")+1, "")
   67              0.000419         call cursor(line(".")+1, col("."))
   67              0.000084     endif
                            
   67   0.000518   0.000318     if self.getShowBookmarks()
                                    call self._renderBookmarks()
                                endif
                            
                                "add the 'up a dir' line
   67   0.000503   0.000332     if !self.isMinimal()
   67   0.000932   0.000752         call setline(line(".")+1, s:UI.UpDirLine())
   67              0.000452         call cursor(line(".")+1, col("."))
   67              0.000097     endif
                            
                                "draw the header line
   67   0.006535   0.000781     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
   67              0.000462     call setline(line(".")+1, header)
   67              0.000288     call cursor(line(".")+1, col("."))
                            
                                "draw the tree
   67   0.609380   0.003587     silent put =self.nerdtree.root.renderToString()
                            
                                "delete the blank line at the top of the buffer
   67              0.001087     silent 1,1delete _
                            
                                "restore the view
   67              0.000408     let old_scrolloff=&scrolloff
   67              0.000656     let &scrolloff=0
   67              0.000378     call cursor(topLine, 1)
   67              0.001599     normal! zt
   67              0.000425     call cursor(curLine, curCol)
   67              0.000578     let &scrolloff = old_scrolloff
                            
   67              0.000447     setlocal nomodifiable

FUNCTION  252()
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000006     let self._showHelp = !self._showHelp

FUNCTION  airline#statusline()
Called 46949 times
Total time:   1.073373
 Self time:   1.073373

count  total (s)   self (s)
46949              0.445690   if has_key(s:contexts, a:winnr)
46949              0.524642     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  259()
Called 475 times
Total time:   0.007575
 Self time:   0.007575

count  total (s)   self (s)
  475              0.001779     let newObj = copy(self)
  475              0.001255     let newObj.nerdtree = a:nerdtree
  475              0.001133     let newObj.subject = a:subject
  475              0.001077     let newObj.action = a:action
  475              0.001091     let newObj.params = a:params
  475              0.000643     return newObj

FUNCTION  <SNR>95_get_hunks_gitgutter()
Called 68 times
Total time:   0.003944
 Self time:   0.001045

count  total (s)   self (s)
   68   0.001159   0.000544   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
    2              0.000002     return ''
                              endif
   66   0.002581   0.000297   return GitGutterGetHunkSummary()

FUNCTION  gitgutter#hunk#reset()
Called 7703 times
Total time:   0.849929
 Self time:   0.203914

count  total (s)   self (s)
 7703   0.409014   0.122195   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'hunks', [])
 7703   0.429236   0.070040   call s:reset_summary()

FUNCTION  gitgutter#sign#remove_dummy_sign()
Called 4 times
Total time:   0.000190
 Self time:   0.000098

count  total (s)   self (s)
    4   0.000025   0.000017   let bufnr = gitgutter#utility#bufnr()
    4   0.000062   0.000023   if gitgutter#utility#getbufvar(bufnr, 'dummy_sign') && (a:force || !g:gitgutter_sign_column_always)
    4              0.000032     execute "sign unplace" s:dummy_sign_id "buffer=" . bufnr
    4   0.000062   0.000018     call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', 0)
    4              0.000003   endif

FUNCTION  <SNR>125_narrowable()
Called 1015 times
Total time:   0.019270
 Self time:   0.019270

count  total (s)   self (s)
 1015              0.018102 	retu exists('s:act_add') && exists('s:matched') && s:matched != [] && exists('s:mdata') && s:mdata[:2] == [s:dyncwd, s:itemtype, s:regexp] && s:matcher == {} && !exists('s:did_exp')

FUNCTION  fugitive#reload_status()
Called 17 times
Total time:   0.009182
 Self time:   0.009182

count  total (s)   self (s)
   17              0.000573   if exists('s:reloading_status')
                                return
                              endif
   17              0.000033   try
   17              0.000124     let s:reloading_status = 1
   17              0.000120     let mytab = tabpagenr()
   51              0.000523     for tab in [mytab] + range(1,tabpagenr('$'))
  152              0.000522       for winnr in range(1,tabpagewinnr(tab,'$'))
  118              0.001755         if getbufvar(tabpagebuflist(tab)[winnr-1],'fugitive_type') ==# 'index'
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        if !&modified
                                          call s:BufReadIndex()
                                        endif
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                    endif
  118              0.000149       endfor
   34              0.000156     endfor
   17              0.000022   finally
   17              0.000049     unlet! s:reloading_status
   17              0.000022   endtry

FUNCTION  <SNR>65_repo_head()
Called 68 times
Total time:   0.012165
 Self time:   0.003139

count  total (s)   self (s)
   68   0.008029   0.000676     let head = s:repo().head_ref()
                            
   68              0.000799     if head =~# '^ref: '
   68   0.002344   0.000671       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
   68              0.000139     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
   68              0.000103     return branch

FUNCTION  <SNR>118_app_has_rails5()
Called 234 times
Total time:   0.039641
 Self time:   0.006050

count  total (s)   self (s)
  234   0.022398   0.001882   let gemdir = get(self.gems(), 'rails')
  234   0.016999   0.003924   return self.has('rails5') || gemdir =~# '-\%([5-9]\|\d\d\+\)\.[^\/]*$'

FUNCTION  gitgutter#utility#is_file_buffer()
Called 12235 times
Total time:   0.168510
 Self time:   0.168510

count  total (s)   self (s)
12235              0.149256   return empty(getbufvar(s:bufnr, '&buftype'))

FUNCTION  <SNR>118_cache_set()
Called 137 times
Total time:   0.000829
 Self time:   0.000829

count  total (s)   self (s)
  137              0.000755   let self.dict[a:key] = [a:value] + a:000

FUNCTION  <SNR>36_invoke_funcrefs()
Called 2507 times
Total time:  10.089653
 Self time:   0.113687

count  total (s)   self (s)
 2507   0.085979   0.015182   let builder = airline#builder#new(a:context)
 2507   1.643021   0.026065   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
 2507              0.003573   if err == 1
 2400   8.304841   0.016628     let a:context.line = builder.build()
 2400              0.018659     let s:contexts[a:context.winnr] = a:context
 2400              0.025293     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
 2400              0.002330   endif

FUNCTION  <SNR>125_OpenMulti()
Called 41 times
Total time:   0.001754
 Self time:   0.001754

count  total (s)   self (s)
   41              0.000412 	let has_marked = exists('s:marked')
   41              0.000474 	if ( !has_marked && a:0 ) || s:opmul == '0' || !s:ispath || ( s:itemtype > 2 && s:getextvar('opmul') != 1 )
   41              0.000155 		retu -1
                            	en
                            	" Get the options
                            	let [nr, md] = [matchstr(s:opmul, '\d\+'), matchstr(s:opmul, '[thvi]')]
                            	let [ur, jf] = [s:opmul =~ 'r', s:opmul =~ 'j']
                            	let md = a:0 ? a:1 : ( md == '' ? 'v' : md )
                            	let nopt = exists('g:ctrlp_open_multiple_files')
                            	if !has_marked
                            		let line = ctrlp#getcline()
                            		if line == '' | retu | en
                            		let marked = { 1 : fnamemodify(line, ':p') }
                            		let [nr, ur, jf, nopt] = ['1', 0, 0, 1]
                            	en
                            	if ( s:argmap || !has_marked ) && !a:0
                            		let md = s:argmaps(md, !has_marked ? 2 : 0)
                            		if md == 'c'
                            			cal s:unmarksigns()
                            			unl! s:marked
                            			cal s:BuildPrompt(0)
                            		elsei !has_marked && md =~ '[axd]'
                            			retu s:OpenNoMarks(md, line)
                            		en
                            		if md =~ '\v^c(ancel)?$' | retu | en
                            		let nr = nr == '0' ? ( nopt ? '' : '1' ) : nr
                            		let ur = !has_marked && md == 'r' ? 1 : ur
                            	en
                            	let mkd = values(has_marked ? s:marked : marked)
                            	cal s:sanstail(join(s:prompt, ''))
                            	cal s:PrtExit()
                            	if nr == '0' || md == 'i'
                            		retu map(mkd, "s:openfile('bad', v:val, '', 0)")
                            	en
                            	let tail = s:tail()
                            	let [emptytail, bufnr] = [empty(tail), bufnr('^'.mkd[0].'$')]
                            	let useb = bufnr > 0 && buflisted(bufnr) && emptytail
                            	" Move to a replaceable window
                            	let ncmd = ( useb ? ['b', 'bo vert sb'] : ['e', 'bo vne'] ) + ( ur ? [] : ['ignruw'] )
                            	let fst = call('ctrlp#normcmd', ncmd)
                            	" Check if the current window has a replaceable buffer
                            	let repabl = !( md == 't' && !ur ) && empty(bufname('%')) && empty(&l:ft)
                            	" Commands for the rest of the files
                            	let [ic, cmds] = [1, { 'v': ['vert sb', 'vne'], 'h': ['sb', 'new'], 't': ['tab sb', 'tabe'] }]
                            	let [swb, &swb] = [&swb, '']
                            	if md == 't' && ctrlp#tabcount() < tabpagenr()
                            		let s:tabct = ctrlp#tabcount()
                            	en
                            	" Open the files
                            	for va in mkd
                            		let bufnr = bufnr('^'.va.'$')
                            		if bufnr < 0 && getftype(va) == '' | con | en
                            		let useb = bufnr > 0 && buflisted(bufnr) && emptytail
                            		let snd = md != '' && has_key(cmds, md) ? ( useb ? cmds[md][0] : cmds[md][1] ) : ( useb ? 'vert sb' : 'vne' )
                            		let cmd = ic == 1 && ( !( !ur && fst =~ '^[eb]$' ) || repabl ) ? fst : snd
                            		let conds = [( nr != '' && nr > 1 && nr < ic ) || ( nr == '' && ic > 1 ), nr != '' && nr < ic]
                            		if conds[nopt]
                            			if !buflisted(bufnr) | cal s:openfile('bad', va, '', 0) | en
                            		el
                            			cal s:openfile(cmd, useb ? bufnr : va, tail, ic == 1)
                            			if jf | if ic == 1
                            				let crpos = [tabpagenr(), winnr()]
                            			el
                            				let crpos[0] += tabpagenr() <= crpos[0]
                            				let crpos[1] += winnr() <= crpos[1]
                            			en | en
                            			let ic += 1
                            		en
                            	endfo
                            	if jf && exists('crpos') && ic > 2
                            		exe ( md == 't' ? 'tabn '.crpos[0] : crpos[1].'winc w' )
                            	en
                            	let &swb = swb
                            	unl! s:tabct

FUNCTION  gitgutter#utility#directory_of_file()
Called 2113 times
Total time:   0.015926
 Self time:   0.015926

count  total (s)   self (s)
 2113              0.013633   return fnamemodify(s:file, ':h')

FUNCTION  <SNR>125_formatline()
Called 6538 times
Total time:   0.201114
 Self time:   0.164153

count  total (s)   self (s)
 6538              0.013555 	let str = a:str
 6538              0.008919 	if s:itemtype == 1
                            		let filpath = fnamemodify(str, ':p')
                            		let bufnr = s:nonamecond(str, filpath) ? str2nr(matchstr(str, '[\/]\?\[\zs\d\+\ze\*No Name\]$')) : bufnr('^'.filpath.'$')
                            		let idc = ( bufnr == bufnr('#') ? '#' : '' ) . ( getbufvar(bufnr, '&ma') ? '' : '-' ) . ( getbufvar(bufnr, '&ro') ? '=' : '' ) . ( getbufvar(bufnr, '&mod') ? '+' : '' )
                            		let str .= idc != '' ? ' '.idc : ''
                            	en
 6538   0.071019   0.034058 	let cond = s:ispath && ( s:winw - 4 ) < s:strwidth(str)
 6538              0.021577 	retu '> '.( cond ? s:pathshorten(str) : str )

FUNCTION  gitgutter#utility#is_active()
Called 12235 times
Total time:   3.362139
 Self time:   0.377873

count  total (s)   self (s)
12235   3.335761   0.351495   return g:gitgutter_enabled && !pumvisible() && gitgutter#utility#is_file_buffer() && gitgutter#utility#exists_file() && gitgutter#utility#not_git_dir()

FUNCTION  261()
Called 475 times
Total time:   0.025013
 Self time:   0.008599

count  total (s)   self (s)
  475   0.011006   0.003431     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
  475   0.011664   0.002825     for listener in s:Notifier.GetListenersForEvent(a:event)
                                    call {listener}(event)
                                endfor

FUNCTION  262()
Called 475 times
Total time:   0.004199
 Self time:   0.004199

count  total (s)   self (s)
  475              0.001860     if !exists("s:refreshListenersMap")
                                    let s:refreshListenersMap = {}
                                endif
  475              0.000776     return s:refreshListenersMap

FUNCTION  263()
Called 475 times
Total time:   0.008839
 Self time:   0.004640

count  total (s)   self (s)
  475   0.006856   0.002657     let listenersMap = s:Notifier.GetListenersMap()
  475              0.001632     return get(listenersMap, a:name, [])

FUNCTION  265()
Called 940 times
Total time:   0.090232
 Self time:   0.010126

count  total (s)   self (s)
  940   0.014267   0.005223     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
  940   0.075203   0.004141     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  266()
Called 940 times
Total time:   0.071062
 Self time:   0.049522

count  total (s)   self (s)
  940   0.012002   0.004493     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
  940   0.016232   0.004893     let auto_loc_list = syntastic#util#var('auto_loc_list')
  940   0.006179   0.003487     if !a:loclist.isEmpty()
   60              0.000142         if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
   60              0.000039     else
  880              0.005269         if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
                                        try
                                            " Vim 7.4.2200 or later
                                            let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
                                        endtry
                            
                                        if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
                                            call SyntasticLoclistHide()
                            
                                            try
                                                " Vim 7.4.2200 or later
                                                call setloclist(0, [], 'r', { 'title': '' })
                                            catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
                                            endtry
                                            let w:syntastic_loclist_set = []
                                        endif
                                    endif
  880              0.000621     endif

FUNCTION  268()
Called 940 times
Total time:   0.005992
 Self time:   0.005992

count  total (s)   self (s)
  940              0.004894     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  <SNR>41_mergelists()
Called 18 times
Total time:   0.758118
 Self time:   0.016235

count  total (s)   self (s)
   18   0.741943   0.000537 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
   18              0.013464 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
   18              0.001849 	let mrufs = s:mrufs + diskmrufs
   18   0.000804   0.000328 	retu s:chop(mrufs)

FUNCTION  gitgutter#utility#save_last_seen_change()
Called 1444 times
Total time:   0.034039
 Self time:   0.014555

count  total (s)   self (s)
 1444   0.030963   0.011479   call gitgutter#utility#setbufvar(s:bufnr, 'last_tick', getbufvar(s:bufnr, 'changedtick'))

FUNCTION  SyntaxCheckers_haml_haml_GetLocList()
Called 183 times
Total time: 936.129274
 Self time:   0.008524

count  total (s)   self (s)
  183   0.122938   0.002336     let makeprg = self.makeprgBuild({ 'args_after': '-c' })
                            
  183              0.000971     let errorformat = 'Haml error on line %l: %m,' . 'Syntax error on line %l: %m,' . '%-G%.%#'
                            
  183 936.004371   0.004223     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat })

FUNCTION  <SNR>301_try_cmd()
Called 2 times
Total time:   0.877212
 Self time:   0.877212

count  total (s)   self (s)
    2              0.000060   let argv = split(a:cmd, " ")
    2              0.877072   let out = a:0 ? systemlist(argv, a:1, 1) : systemlist(argv, [''], 1)
    2              0.000021   if v:shell_error
                                echohl WarningMsg
                                echo "clipboard: error: ".(len(out) ? out[0] : '')
                                echohl None
                                return 0
                              endif
    2              0.000004   return out

FUNCTION  <SNR>61_BufReadPostHook()
Called 75 times
Total time:   0.032154
 Self time:   0.003149

count  total (s)   self (s)
   75   0.030591   0.001586     let buf = syntastic#util#fname2buf(a:fname)
   75              0.000278     if g:syntastic_check_on_open && buf > 0
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufReadPost, buffer ' . buf . ' = ' . string(a:fname))
                                    if index(s:_check_stack, buf) == -1
                                        call add(s:_check_stack, buf)
                                    endif
                                endif

FUNCTION  <SNR>61_BufWinEnterHook()
Called 120 times
Total time:   0.055569
 Self time:   0.007396

count  total (s)   self (s)
  120   0.047389   0.001527     let buf = syntastic#util#fname2buf(a:fname)
  120   0.004743   0.002431     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWinEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
  120              0.000619     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
  105              0.000944         let idx = index(reverse(copy(s:_check_stack)), buf)
  105              0.000285         if idx >= 0 && !has('vim_starting')
                                        call remove(s:_check_stack, -idx - 1)
                                        call s:UpdateErrors(buf, 1, [])
                                    endif
  105              0.000079     endif

FUNCTION  <SNR>74_TmuxWinCmd()
Called 262 times
Total time:   7.439440
 Self time:   0.011638

count  total (s)   self (s)
  262   0.007778   0.004220   if s:InTmuxSession()
  262   7.427425   0.003182     call s:TmuxAwareNavigate(a:direction)
  262              0.000517   else
                                call s:VimNavigate(a:direction)
                              endif

FUNCTION  <SNR>95_is_branch_empty()
Called 68 times
Total time:   0.000615
 Self time:   0.000615

count  total (s)   self (s)
   68              0.000562   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>97_format_name()
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000007     return a:name

FUNCTION  <SNR>65_buffer()
Called 398 times
Total time:   0.016890
 Self time:   0.014190

count  total (s)   self (s)
  398              0.003515   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
  398              0.005797   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
  398   0.006024   0.003324   if buffer.getvar('git_dir') !=# ''
  398              0.000803     return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  syntastic#util#setLastTick()
Called 503 times
Total time:   0.004025
 Self time:   0.004025

count  total (s)   self (s)
  503              0.003636     call setbufvar(a:buf, 'syntastic_lasttick', getbufvar(a:buf, 'changedtick'))

FUNCTION  airline#highlighter#get_highlight()
Called 1511031 times
Total time: 174.591408
 Self time:  47.623832

count  total (s)   self (s)
1511031  65.018756   7.247559   let fg = s:get_syn(a:group, 'fg')
1511031  66.567804   7.751003   let bg = s:get_syn(a:group, 'bg')
1511031             21.044801   let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
1511031  20.658276  10.278699   return reverse ? s:get_array(bg, fg, a:000) : s:get_array(fg, bg, a:000)

FUNCTION  <SNR>97_reset_untracked_cache()
Called 510 times
Total time:   0.102316
 Self time:   0.087573

count  total (s)   self (s)
                              " shellcmdpost - whether function was called as a result of ShellCmdPost hook
  510              0.005942   if !s:has_async && !has('nvim')
                                if a:shellcmdpost
                                  " Clear cache only if there was no error or the script uses an
                                  " asynchronous interface. Otherwise, cache clearing would overwrite
                                  " v:shell_error with a system() call inside get_*_untracked.
                                  if v:shell_error
                                    return
                                  endif
                                endif
                              endif
                            
  510              0.031042   let l:file = expand("%:p")
 1530              0.009953   for vcs in keys(s:vcs_config)
                                " Dump the value of the cache for the current file. Partially mitigates the
                                " issue of cache invalidation happening before a call to
                                " s:update_untracked()
 1020   0.026664   0.011921     call s:update_untracked_in_buffer_config(l:file, l:vcs)
 1020              0.009092     let s:vcs_config[vcs].untracked = {}
 1020              0.001900   endfor

FUNCTION  provider#clipboard#Call()
Called 2 times
Total time:   0.877507
 Self time:   0.000104

count  total (s)   self (s)
    2   0.877500   0.000097   return call(s:clipboard[a:method],a:args,s:clipboard)

FUNCTION  emmet#lang#type()
Called 79 times
Total time:   0.004766
 Self time:   0.003292

count  total (s)   self (s)
   79              0.000325   let type = a:type
   79              0.000208   let base = type
   79   0.000993   0.000652   let settings = emmet#getSettings()
   79              0.000285   while base != ''
   79              0.000709     for b in split(base, '\.')
   79   0.001640   0.000508       if emmet#lang#exists(b)
   79              0.000150         return b
                                  endif
                                  if has_key(settings, b) && has_key(settings[b], 'extends')
                                    let base = settings[b].extends
                                    break
                                  else
                                    let base = ''
                                  endif
                                endfor
                              endwhile
                              return 'html'

FUNCTION  AutoPairsInsert()
Called 128 times
Total time:   0.045130
 Self time:   0.045130

count  total (s)   self (s)
  128              0.002296   if !b:autopairs_enabled
                                return a:key
                              end
                            
  128              0.001659   let line = getline('.')
  128              0.001364   let pos = col('.') - 1
  128              0.001073   let before = strpart(line, 0, pos)
  128              0.000702   let after = strpart(line, pos)
  128              0.002545   let next_chars = split(after, '\zs')
  128              0.000866   let current_char = get(next_chars, 0, '')
  128              0.000614   let next_char = get(next_chars, 1, '')
  128              0.003813   let prev_chars = split(before, '\zs')
  128              0.000717   let prev_char = get(prev_chars, -1, '')
                            
  128              0.000340   let eol = 0
  128              0.000867   if col('$') -  col('.') <= 1
  114              0.000317     let eol = 1
  114              0.000159   end
                            
                              " Ignore auto close if prev character is \
  128              0.000538   if prev_char == '\'
                                return a:key
                              end
                            
                              " The key is difference open-pair, then it means only for ) ] } by default
  128              0.000862   if !has_key(b:AutoPairs, a:key)
    1              0.000008     let b:autopairs_saved_pair = [a:key, getpos('.')]
                            
                                " Skip the character if current character is the same as input
    1              0.000002     if current_char == a:key
                                  return s:Right
                                end
                            
    1              0.000001     if !g:AutoPairsFlyMode
                                  " Skip the character if next character is space
    1              0.000002       if current_char == ' ' && next_char == a:key
                                    return s:Right.s:Right
                                  end
                            
                                  " Skip the character if closed pair is next character
    1              0.000001       if current_char == ''
    1              0.000001         if g:AutoPairsMultilineClose
    1              0.000003           let next_lineno = line('.')+1
    1              0.000004           let next_line = getline(nextnonblank(next_lineno))
    1              0.000013           let next_char = matchstr(next_line, '\s*\zs.')
    1              0.000002         else
                                      let next_char = matchstr(line, '\s*\zs.')
                                    end
    1              0.000003         if next_char == a:key
                                      return "\<ESC>e^a"
                                    endif
    1              0.000001       endif
    1              0.000001     endif
                            
                                " Fly Mode, and the key is closed-pairs, search closed-pair and jump
    1              0.000003     if g:AutoPairsFlyMode && has_key(b:AutoPairsClosedPairs, a:key)
                                  let n = stridx(after, a:key)
                                  if n != -1
                                    return repeat(s:Right, n+1)
                                  end
                                  if search(a:key, 'W')
                                    " force break the '.' when jump to different line
                                    return "\<Right>"
                                  endif
                                endif
                            
                                " Insert directly if the key is not an open key
    1              0.000002     return a:key
                              end
                            
  127              0.000409   let open = a:key
  127              0.000664   let close = b:AutoPairs[open]
                            
  127              0.000533   if current_char == close && open == close
    2              0.000015     return s:Right
                              end
                            
                              " Ignore auto close ' if follows a word
                              " MUST after closed check. 'hello|'
  125              0.000480   if a:key == "'" && prev_char =~ '\v\w'
                                return a:key
                              end
                            
                              " support for ''' ``` and """
  125              0.000334   if open == close
                                " The key must be ' " `
   19              0.000148     let pprev_char = line[col('.')-3]
   19              0.000077     if pprev_char == open && prev_char == open
                                  " Double pair found
                                  return repeat(a:key, 4) . repeat(s:Left, 3)
                                end
   19              0.000019   end
                            
  125              0.000332   let quotes_num = 0
                              " Ignore comment line for vim file
  125              0.000630   if &filetype == 'vim' && a:key == '"'
                                if before =~ '^\s*$'
                                  return a:key
                                end
                                if before =~ '^\s*"'
                                  let quotes_num = -1
                                end
                              end
                            
                              " Keep quote number is odd.
                              " Because quotes should be matched in the same line in most of situation
  125              0.000474   if g:AutoPairsSmartQuotes && open == close
                                " Remove \\ \" \'
   19              0.000293     let cleaned_line = substitute(line, '\v(\\.)', '', 'g')
   19              0.000074     let n = quotes_num
   19              0.000045     let pos = 0
   21              0.000070     while 1
   21              0.000170       let pos = stridx(cleaned_line, open, pos)
   21              0.000062       if pos == -1
   19              0.000054         break
                                  end
    2              0.000009       let n = n + 1
    2              0.000009       let pos = pos + 1
    2              0.000009     endwhile
   19              0.000046     if n % 2 == 1
                                  return a:key
                                endif
   19              0.000020   endif
                            
  125              0.000614   return open.close.s:Left

FUNCTION  airline#util#shorten()
Called 31519 times
Total time:   1.525026
 Self time:   1.525026

count  total (s)   self (s)
31519              0.735324   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
31449              0.118900     if get(a:000, 0, 0)
                                  " shorten from tail
                                  return 'â¦'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
31449              0.403574       return matchstr(a:text, '^.\{'.a:minwidth.'}').'â¦'
                                endif
                              else
   70              0.000164     return a:text
                              endif

FUNCTION  ctrlp#utils#glob()
Called 11 times
Total time:   0.001710
 Self time:   0.000846

count  total (s)   self (s)
   11   0.000972   0.000108 	let path = ctrlp#utils#fnesc(a:1, 'g')
   11              0.000715 	retu s:wig_cond ? glob(path, a:2) : glob(path)

FUNCTION  270()
Called 503 times
Total time:   0.011323
 Self time:   0.011323

count  total (s)   self (s)
  503              0.003213     let b:syntastic_private_balloons = {}
  503              0.003035     if has('balloon_eval')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
                                    unlet! b:syntastic_private_balloons
                                    set noballooneval
                                endif

FUNCTION  272()
Called 799 times
Total time:   0.002515
 Self time:   0.002515

count  total (s)   self (s)
  799              0.002040     return self._filetype

FUNCTION  274()
Called 1299 times
Total time:   0.007035
 Self time:   0.007035

count  total (s)   self (s)
 1299              0.005242     return self._filetype . '/' . self._name

FUNCTION  275()
Called 796 times
Total time:   0.667303
 Self time:   0.641125

count  total (s)   self (s)
  796              0.001866     if a:0
                                    let self._exec = a:1
                                else
  796              0.002571         let suffix = self._name . '_exec'
  796   0.656889   0.630711         let self._exec = expand( syntastic#util#var(self._filetype . '_' . suffix, syntastic#util#var(suffix, self._exec_default)), 1 )
  796              0.001609     endif

FUNCTION  277()
Called 503 times
Total time:   0.013695
 Self time:   0.004115

count  total (s)   self (s)
  503   0.013344   0.003764     return syntastic#util#shescape(self._exec)

FUNCTION  278()
Called 503 times
Total time: 2043.079760
 Self time:   0.087745

count  total (s)   self (s)
  503              0.004430     let checker_start = reltime()
  503   0.005601   0.003244     let name = self.getCName()
                            
  503              0.001643     if has_key(self, '_enable')
                                    let status = syntastic#util#var(self._enable, -1)
                                    if type(status) != type(0)
                                        call syntastic#log#error('checker ' . name . ': invalid value ' . strtrans(string(status)) . ' for g:syntastic_' . self._enable . '; try 0 or 1 instead')
                                        return []
                                    endif
                                    if status < 0
                                        call syntastic#log#error('checker ' . name . ': checks disabled for security reasons; ' . 'set g:syntastic_' . self._enable . ' to 1 to override')
                                    endif
                                    if status <= 0
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' enabled but not forced')
                                        return []
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' forced')
                                    endif
                                endif
                            
  503              0.000790     try
  503 2042.914498   0.012048         let list = self._locListFunc()
  503              0.002302         if self._exec !=# ''
  503   0.014229   0.006884             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
  503              0.000556         endif
  503              0.000914     catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
                                endtry
  503   0.021567   0.003602     call self._populateHighlightRegexes(list)
  503   0.010759   0.005264     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
  503   0.054140   0.002849     call self._quietMessages(list)
  503   0.018231   0.013119     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' run in ' . split(reltimestr(reltime(checker_start)))[0] . 's')
  503              0.001583     return list

FUNCTION  279()
Called 503 times
Total time: 2043.129600
 Self time:   0.012200

count  total (s)   self (s)
  503 2043.128689   0.011290     return g:SyntasticLoclist.New(self.getLocListRaw())

FUNCTION  <SNR>118_app_smart_projections()
Called 992 times
Total time:   0.093920
 Self time:   0.057533

count  total (s)   self (s)
  992   0.040306   0.016040   let ts = getftime(self.path('app/'))
  992   0.013634   0.006403   if self.cache.needs('smart_projections', ts)
                                let dict = {}
                                for dir in self.relglob('app/', '*s', '/')
                                  let singular = rails#singularize(dir)
                                  let glob = 'app/' . dir . '/*_' . singular . '.rb'
                                  if dir !~# '\v^%(assets|models|views)$' && !has_key(s:default_projections, glob) && !empty(self.relglob('', glob))
                                    let dict[glob] = {'type': s:gsub(tolower(singular), '\A+', ' ')}
                                  endif
                                endfor
                                if has_key(dict, 'app/mailers/*_mailer.rb') || self.has_rails5()
                                  let dict['app/mailers/*_mailer.rb'] = { "affinity": "controller", "template": ["class {camelcase|capitalize|colons}Mailer < ActionMailer::Base", "end"], "type": "mailer"}
                                else
                                  let dict['app/mailers/*.rb'] = { "affinity": "controller", "template": ["class {camelcase|capitalize|colons} < ActionMailer::Base", "end"], "type": "mailer"}
                                endif
                                call self.cache.set('smart_projections', dict, ts)
                              endif
  992   0.009282   0.004392   return self.cache.get('smart_projections')

FUNCTION  <SNR>125_sanstail()
Called 1019 times
Total time:   0.095478
 Self time:   0.095478

count  total (s)   self (s)
 1019              0.045350 	let str = s:spi ? substitute(a:str, '^\(@.*$\|\\\\\ze@\|\.\.\zs[.\/]\+$\)', '', 'g') : a:str
 1019              0.013691 	let [str, pat] = [substitute(str, '\\\\', '\', 'g'), '\([^:]\|\\:\)*$']
 1019              0.002665 	unl! s:optail
 1019              0.014854 	if str =~ '\\\@<!:'.pat
                            		let s:optail = matchstr(str, '\\\@<!:\zs'.pat)
                            		let str = substitute(str, '\\\@<!:'.pat, '', '')
                            	en
 1019              0.007357 	retu substitute(str, '\\\ze:', '', 'g')

FUNCTION  xolox#session#locking_enabled()
Called 1 time
Total time:   0.593253
 Self time:   0.501000

count  total (s)   self (s)
                              " Check whether session locking is enabled. Returns true (1) when locking is
                              " enabled, false (0) otherwise.
                              "
                              " By default session locking is enabled but users can opt-out by setting
                              " `g:session_lock_enabled` to false (0).
    1   0.593229   0.500975   return xolox#misc#option#get('session_lock_enabled', 1)

FUNCTION  xolox#misc#option#get()
Called 1 time
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
    1              0.000019   if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
                              elseif exists('g:' . a:name)
                                " Global variable.
                                return eval('g:' . a:name)
                              elseif exists('a:1')
                                " Default value.
    1              0.000004     return a:1
                              endif

FUNCTION  <SNR>118_AddColonExpand()
Called 1096 times
Total time:   0.074644
 Self time:   0.006198

count  total (s)   self (s)
 1096   0.074176   0.005729   call s:AddSelectiveExpand(a:abbr,'[:.]',a:expn)

FUNCTION  airline#extensions#apply_left_override()
Called 113 times
Total time:   0.025985
 Self time:   0.002323

count  total (s)   self (s)
  113              0.000462   let w:airline_section_a = a:section1
  113              0.000318   let w:airline_section_b = a:section2
  113   0.024462   0.000801   let w:airline_section_c = airline#section#create(['readonly'])
  113              0.000291   let w:airline_render_left = 1
  113              0.000260   let w:airline_render_right = 0

FUNCTION  <SNR>65_repo_head_ref()
Called 68 times
Total time:   0.005408
 Self time:   0.004291

count  total (s)   self (s)
   68   0.001984   0.001305   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
   68   0.003158   0.002721   return readfile(self.dir('HEAD'))[0]

FUNCTION  airline#extensions#branch#get_head()
Called 68 times
Total time:   2.165641
 Self time:   0.001771

count  total (s)   self (s)
   68   2.164271   0.000401   let head = airline#extensions#branch#head()
   68              0.000338   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
   68              0.000352   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   68              0.000578   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  gitgutter#utility#using_xolox_shell()
Called 2113 times
Total time:   0.073277
 Self time:   0.073277

count  total (s)   self (s)
 2113              0.012670   if s:using_xolox_shell == -1
                                if !g:gitgutter_avoid_cmd_prompt_on_windows
                                  let s:using_xolox_shell = 0
                                " Although xolox/vim-shell works on both windows and unix we only want to use
                                " it on windows.
                                elseif has('win32') || has('win64') || has('win32unix')
                                  let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
                                else
                                  let s:using_xolox_shell = 0
                                endif
                              endif
 2113              0.005948   return s:using_xolox_shell

FUNCTION  283()
Called 503 times
Total time:   0.312441
 Self time:   0.038167

count  total (s)   self (s)
  503              0.003025     let basename = self._filetype . '_' . self._name . '_'
                            
  503              0.001259     let parts = []
  503   0.076252   0.008909     call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
  503   0.051877   0.004496     call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
  503   0.070102   0.008209     call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
  503   0.053770   0.004123     call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
  503   0.051914   0.003903     call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
                            
  503              0.002458     return join(parts)

FUNCTION  284()
Called 796 times
Total time:   0.687639
 Self time:   0.020336

count  total (s)   self (s)
  796   0.671276   0.003973     call self.syncExec()
                            
  796              0.003277     if !has_key(self, '_available')
                                    let self._available = {}
                                endif
  796              0.003333     if !has_key(self._available, self._exec)
                                    let self._available[self._exec] = self._isAvailableFunc()
                                endif
                            
  796              0.002210     return self._available[self._exec]

FUNCTION  286()
Called 30 times
Total time:   0.000691
 Self time:   0.000251

count  total (s)   self (s)
   30   0.000639   0.000198     return syntastic#util#var(self._filetype . '_' . self._name . '_sort', 0)

FUNCTION  syntastic#util#bufRawVar()
Called 296 times
Total time:   0.002773
 Self time:   0.002773

count  total (s)   self (s)
  296              0.002532     return s:_getbufvar(a:buf, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  289()
Called 503 times
Total time:   0.017966
 Self time:   0.015529

count  total (s)   self (s)
  503              0.003411     if has_key(self, '_highlightRegexFunc')
  220              0.000357         for e in a:errors
  196              0.000360             if e['valid']
  196   0.003532   0.001095                 let term = self._highlightRegexFunc(e)
  196              0.000322                 if term !=# ''
                                                let e['hl'] = term
                                            endif
  196              0.000145             endif
  196              0.000156         endfor
   24              0.000017     endif

FUNCTION  airline#extensions#tabline#tabs#invalidate()
Called 30 times
Total time:   0.000289
 Self time:   0.000289

count  total (s)   self (s)
   30              0.000213   let s:current_bufnr = -1

FUNCTION  <SNR>54__find_index()
Called 132 times
Total time:   0.002088
 Self time:   0.002088

count  total (s)   self (s)
  132              0.000725     let max = len(a:messages) - 1
  132              0.000231     if max == 0
   94              0.000108         return 0
                                endif
   38              0.000068     let min = 0
                            
                                " modified binary search: assign index 0 to columns to the left of the first error
   38              0.000100     while min < max - 1
                                    let mid = (min + max) / 2
                                    if a:column < a:messages[mid].scol
                                        let max = mid
                                    else
                                        let min = mid
                                    endif
                                endwhile
                            
   38              0.000194     return a:column < a:messages[max].scol ? min : max

FUNCTION  airline#extensions#ctrlp#apply()
Called 708 times
Total time:   0.006616
 Self time:   0.006616

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
  708              0.005640   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  airline#extensions#ctrlp#ctrlp_airline_status()
Called 44 times
Total time:   0.002455
 Self time:   0.002455

count  total (s)   self (s)
   44              0.000273   let len = '%#CtrlPdark# '.a:1
   44              0.001901   let dir = '%=%<%#CtrlParrow3#'.g:airline_right_sep.'%#CtrlPlight# '.getcwd().' %*'
   44              0.000174   return len.dir

FUNCTION  syntastic#util#rawVar()
Called 14263 times
Total time:   0.092304
 Self time:   0.092304

count  total (s)   self (s)
14263              0.084466     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  <SNR>70_wrapreg()
Called 1 time
Total time:   0.000612
 Self time:   0.000076

count  total (s)   self (s)
    1              0.000017   let orig = getreg(a:reg)
    1              0.000014   let type = substitute(getregtype(a:reg),'\d\+$','','')
    1   0.000570   0.000033   let new = s:wrap(orig,a:char,type,a:removed,a:special)
    1              0.000010   call setreg(a:reg,new,type)

FUNCTION  xolox#session#auto_save_periodic()
Called 253 times
Total time:   0.022825
 Self time:   0.022825

count  total (s)   self (s)
                              " Automatically saves the current editing session every few minutes.
                              " Normally called by the [CursorHold] [] and [CursorHoldI] [] automatic
                              " command events.
                              "
                              " [CursorHold]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold
                              " [CursorHoldI]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHoldI
  253              0.002381   if g:session_autosave_periodic > 0
                                let interval = g:session_autosave_periodic * 60
                                let next_save = s:session_last_flushed + interval
                                if localtime() > next_save
                                  let name = xolox#session#find_current_session()
                                  if !empty(name)
                                    if xolox#session#is_tab_scoped()
                                      let function = 'xolox#session#save_tab_cmd'
                                      let arguments = [name, '', 'SaveTabSession']
                                    else
                                      let function = 'xolox#session#save_cmd'
                                      let arguments = [name, '', 'SaveSession']
                                    endif
                                    if xolox#misc#option#get('session_autosave_silent', 0)
                                      " Silence informational messages perceived as noisy.
                                      " https://github.com/xolox/vim-session/issues/120
                                      silent call call(function, arguments)
                                    else
                                      call call(function, arguments)
                                    endif
                                  endif
                                endif
                              endif

FUNCTION  airline#themes#generate_color_map()
Called 45 times
Total time:   0.003436
 Self time:   0.003436

count  total (s)   self (s)
   45              0.001278   let palette = { 'airline_a': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , get(a:sect1 , 4 , '') ] , 'airline_b': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , get(a:sect2 , 4 , '') ] , 'airline_c': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , get(a:sect3 , 4 , '') ] , }
                            
   45              0.000105   if a:0 > 0
                                call extend(palette, { 'airline_x': [ a:1[0] , a:1[1] , a:1[2] , a:1[3] , get(a:1 , 4 , '' ) ] , 'airline_y': [ a:2[0] , a:2[1] , a:2[2] , a:2[3] , get(a:2 , 4 , '' ) ] , 'airline_z': [ a:3[0] , a:3[1] , a:3[2] , a:3[3] , get(a:3 , 4 , '' ) ] , })
                              else
   45              0.001051     call extend(palette, { 'airline_x': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , '' ] , 'airline_y': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , '' ] , 'airline_z': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , '' ] , })
   45              0.000064   endif
                            
   45              0.000100   return palette

FUNCTION  syntastic#util#shexpand()
Called 503 times
Total time:   0.013651
 Self time:   0.004941

count  total (s)   self (s)
  503   0.013378   0.004668     return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))

FUNCTION  airline#extensions#ctrlp#generate_color_map()
Called 9 times
Total time:   0.000178
 Self time:   0.000178

count  total (s)   self (s)
    9              0.000139   return { 'CtrlPdark'   : a:dark, 'CtrlPlight'  : a:light, 'CtrlPwhite'  : a:white, 'CtrlParrow1' : [ a:light[1] , a:white[1] , a:light[3] , a:white[3] , ''     ] , 'CtrlParrow2' : [ a:white[1] , a:light[1] , a:white[3] , a:light[3] , ''     ] , 'CtrlParrow3' : [ a:light[1] , a:dark[1]  , a:light[3] , a:dark[3]  , ''     ] , }

FUNCTION  290()
Called 2515 times
Total time:   0.246929
 Self time:   0.097389

count  total (s)   self (s)
 2515              0.007398     let ret = []
 2515   0.062390   0.023929     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_before', '')) )
 2515   0.110418   0.035803     call extend( ret, syntastic#util#argsescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
 2515   0.058588   0.022123     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_after', '')) )
                            
 2515              0.003715     return ret

FUNCTION  292()
Called 1880 times
Total time:   0.029938
 Self time:   0.008025

count  total (s)   self (s)
 1880   0.029067   0.007153     return syntastic#util#var('echo_current_error')

FUNCTION  293()
Called 940 times
Total time:   0.072982
 Self time:   0.021218

count  total (s)   self (s)
  940   0.022866   0.006050     if self.enabled() && !a:loclist.isEmpty()
   60   0.000911   0.000339         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
   60   0.035054   0.000940         let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
   60              0.000190         let b:syntastic_private_line = -1
   60   0.000653   0.000391         let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
   60              0.000423         autocmd! syntastic CursorMoved
   60              0.000321         autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
   60              0.000055     endif

FUNCTION  294()
Called 503 times
Total time:   0.017328
 Self time:   0.011148

count  total (s)   self (s)
  503   0.009808   0.003628     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
  503              0.002930     autocmd! syntastic CursorMoved
  503              0.001554     unlet! b:syntastic_private_messages
  503              0.002230     let b:syntastic_private_line = -1

FUNCTION  296()
Called 1880 times
Total time:   0.033640
 Self time:   0.009993

count  total (s)   self (s)
 1880   0.032755   0.009108     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  297()
Called 940 times
Total time:   0.114138
 Self time:   0.075218

count  total (s)   self (s)
  940   0.018365   0.003164     if self.enabled()
  940   0.014834   0.006027         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
  940   0.014618   0.003106         call self._reset()
  940              0.002596         let buf = bufnr('')
  940   0.010262   0.006863         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
 1388              0.002394         for item in issues
  448              0.002387             let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
  448              0.000949             if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
  227              0.000420                 if get(item, 'vcol', 0)
  227              0.001041                     let lastcol = virtcol([item['lnum'], '$'])
  227              0.000433                     let coltype = 'v'
  227              0.000176                 else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
  227              0.000851                 let lcol = min([lastcol, item['col']])
                            
  227              0.004975                 call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
  227              0.000285             endif
  448              0.000363         endfor
  940              0.000736     endif

FUNCTION  298()
Called 503 times
Total time:   0.026599
 Self time:   0.009317

count  total (s)   self (s)
  503              0.001574     if s:has_highlighting
  503   0.010800   0.003684         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
  503   0.012684   0.002516         call self._reset()
  503              0.000546     endif

FUNCTION  gitgutter#utility#getbufvar()
Called 26854 times
Total time:   0.648146
 Self time:   0.648146

count  total (s)   self (s)
26854              0.268775   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
26854              0.136248   if has_key(dict, a:varname)
14262              0.047104     return dict[a:varname]
                              else
12592              0.028241     if a:0
 6637              0.017560       return a:1
                                endif
 5955              0.008464   endif

FUNCTION  emmet#getDollarValueByKey()
Called 26 times
Total time:   0.002896
 Self time:   0.001613

count  total (s)   self (s)
   26              0.000058   let ret = 0
   26              0.000046   let key = a:key
   26   0.001433   0.000149   let ftsetting = get(s:emmet_settings, emmet#getFileType())
   26              0.000086   if type(ftsetting) ==# 4 && has_key(ftsetting, key)
                                let V = get(ftsetting, key)
                                if type(V) ==# 1 | return V | endif
                              endif
   26              0.000086   if type(ret) !=# 1 && has_key(s:emmet_settings.variables, key)
                                let V = get(s:emmet_settings.variables, key)
                                if type(V) ==# 1 | return V | endif
                              endif
   26              0.000103   if has_key(s:emmet_settings, 'custom_expands') && type(s:emmet_settings['custom_expands']) ==# 4
   52              0.000115     for k in keys(s:emmet_settings['custom_expands'])
   26              0.000149       if key =~# k
                                    let V = get(s:emmet_settings['custom_expands'], k)
                                    if type(V) ==# 1 | return V | endif
                                    if type(V) ==# 2 | return V(key) | endif
                                  endif
   26              0.000024     endfor
   26              0.000015   endif
   26              0.000025   return ret

FUNCTION  gitgutter#diff#is_modified()
Called 156 times
Total time:   0.001191
 Self time:   0.001191

count  total (s)   self (s)
  156              0.000592   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  AutoPairsTryInit()
Called 458 times
Total time:   0.056501
 Self time:   0.013140

count  total (s)   self (s)
  458              0.003199   if exists('b:autopairs_loaded')
  410              0.000583     return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
   48              0.000105   if g:AutoPairsMapCR
   48              0.000210     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
   48              0.001410       let info = maparg('<CR>', 'i', 0, 1)
   48              0.000144       if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
   48              0.000169         let old_cr = info['rhs']
   48   0.002388   0.000525         let old_cr = s:ExpandMap(old_cr)
   48              0.000501         let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
   48              0.000161         let is_expr = info['expr']
   48              0.000144         let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
   48              0.000051       endif
   48              0.000043     else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
   48              0.000295     if old_cr !~ 'AutoPairsReturn'
   48              0.000081       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
   48              0.001064       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
   48              0.000051     end
   48              0.000037   endif
   48   0.041911   0.000413   call AutoPairsInit()

FUNCTION  syntastic#util#argsescape()
Called 7545 times
Total time:   0.105834
 Self time:   0.105834

count  total (s)   self (s)
 7545              0.033249     if type(a:opt) == type('') && a:opt !=# ''
 1533              0.003698         return [a:opt]
                                elseif type(a:opt) == type([])
                                    return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
                                endif
                            
 6012              0.007847     return []

FUNCTION  <SNR>125_PrtAdd()
Called 868 times
Total time:  21.994692
 Self time:   0.037293

count  total (s)   self (s)
  868              0.005770 	unl! s:hstgot
  868              0.007353 	let s:act_add = 1
  868              0.007857 	let s:prompt[0] .= a:char
  868  21.968267   0.010868 	cal s:BuildPrompt(1)
  868              0.002584 	unl s:act_add

FUNCTION  SyntasticStatuslineFlag()
Called 136 times
Total time:   0.023218
 Self time:   0.001726

count  total (s)   self (s)
  136   0.023132   0.001640     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  <SNR>107_get_array()
Called 1511031 times
Total time:  10.379577
 Self time:  10.379577

count  total (s)   self (s)
1511031              9.576402   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', join(a:opts, ',') ] : [ '', '', a:fg, a:bg, join(a:opts, ',') ]

FUNCTION  <SNR>118_AddParenExpand()
Called 772 times
Total time:   0.059659
 Self time:   0.009165

count  total (s)   self (s)
  772              0.001092   if a:0
                                call s:AddSelectiveExpand(a:abbr,'(',a:expn,a:1)
                              else
  772   0.054686   0.004192     call s:AddSelectiveExpand(a:abbr,'(',a:expn,'')
  772              0.000507   endif

FUNCTION  airline#extensions#syntastic#get_warning()
Called 68 times
Total time:   0.015045
 Self time:   0.000530

count  total (s)   self (s)
   68   0.014991   0.000477   return airline#extensions#syntastic#get('warning')

FUNCTION  <SNR>70_inputreplacement()
Called 1 time
Total time:   0.000197
 Self time:   0.000080

count  total (s)   self (s)
    1   0.000139   0.000022   let c = s:getchar()
    1              0.000006   if c == " "
                                let c .= s:getchar()
                              endif
    1              0.000019   if c =~ "\<Esc>" || c =~ "\<C-C>"
                                return ""
                              else
    1              0.000003     return c
                              endif

FUNCTION  <SNR>74_VimNavigate()
Called 262 times
Total time:   5.489592
 Self time:   0.018174

count  total (s)   self (s)
  262              0.000765   try
  262   5.484340   0.012922     execute 'wincmd ' . a:direction
  262              0.000536   catch
                                echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
                              endtry

FUNCTION  <SNR>125_writecache()
Called 11 times
Total time:   0.164709
 Self time:   0.000353

count  total (s)   self (s)
   11   0.000338   0.000100 	if ( g:ctrlp_newcache || !filereadable(a:cafile) ) && !s:nocache()
   11   0.164208   0.000090 		cal ctrlp#utils#writecache(g:ctrlp_allfiles)
   11              0.000106 		let g:ctrlp_newcache = 0
   11              0.000018 	en

FUNCTION  <SNR>125_leavepre()
Called 1 time
Total time:   0.138252
 Self time:   0.000106

count  total (s)   self (s)
    1              0.000019 	if exists('s:bufnr') && s:bufnr == bufnr('%') | bw! | en
    1              0.000022 	if !( exists(s:ccex) && !{s:ccex} ) && !( has('clientserver') && len(split(serverlist(), "\n")) > 1 )
    1   0.138187   0.000042 		cal ctrlp#clra()
    1              0.000003 	en

FUNCTION  <SNR>61_ClearCache()
Called 503 times
Total time:   0.272838
 Self time:   0.012935

count  total (s)   self (s)
  503   0.030703   0.005981     let loclist = g:SyntasticLoclist.current(a:buf)
  503   0.191742   0.003430     call s:notifiers.reset(loclist)
  503   0.049798   0.002929     call loclist.destroy()

FUNCTION  <SNR>118_combine_projections()
Called 5952 times
Total time:   4.563807
 Self time:   1.409967

count  total (s)   self (s)
 5952              0.015675   let extra = a:0 ? a:1 : {}
 5952              0.015789   if type(a:src) == type({})
42656              0.089546     for [pattern, value] in items(a:src)
75392              0.164521       for original in type(value) == type([]) ? value : [value]
37696              0.152641         let projection = extend(copy(original), extra)
37696              0.126801         if !has_key(projection, 'prefix') && !has_key(projection, 'format')
37696   3.451000   0.297159           let a:dest[pattern] = s:extend_projection(get(a:dest, pattern, {}), projection)
37696              0.030676         endif
37696              0.023139       endfor
37696              0.026018     endfor
 4960              0.003459   endif
 5952              0.007185   return a:dest

FUNCTION  ctrlp#files()
Called 118 times
Total time:   1.776369
 Self time:   0.260156

count  total (s)   self (s)
  118   0.012863   0.000937 	let cafile = ctrlp#utils#cachefile()
  118   0.237322   0.233947 	if g:ctrlp_newcache || !filereadable(cafile) || s:nocache(cafile)
   11   0.000849   0.000367 		let [lscmd, s:initcwd, g:ctrlp_allfiles] = [s:lsCmd(), s:dyncwd, []]
                            		" Get the list of files
   11              0.000043 		if empty(lscmd)
   11   0.003076   0.000095 			if !ctrlp#igncwd(s:dyncwd)
   11   1.296352   0.000273 				cal s:GlobPath(s:fnesc(s:dyncwd, 'g', ','), 0)
   11              0.000008 			en
   11              0.000008 		el
                            			sil! cal ctrlp#progress('Indexing...')
                            			try | cal s:UserCmd(lscmd)
                            			cat | retu [] | endt
                            		en
                            		" Remove base directory
   11   0.001677   0.000075 		cal ctrlp#rmbasedir(g:ctrlp_allfiles)
   11              0.000042 		if len(g:ctrlp_allfiles) <= s:compare_lim
   11   0.047281   0.012223 			cal sort(g:ctrlp_allfiles, 'ctrlp#complen')
   11              0.000014 		en
   11   0.164798   0.000089 		cal s:writecache(cafile)
   11              0.000280 		let catime = getftime(cafile)
   11              0.000022 	el
  107              0.001182 		let catime = getftime(cafile)
  107              0.001612 		if !( exists('s:initcwd') && s:initcwd == s:dyncwd ) || get(s:ficounts, s:dyncwd, [0, catime])[1] != catime
                            			let s:initcwd = s:dyncwd
                            			let g:ctrlp_allfiles = ctrlp#utils#readfile(cafile)
                            		en
  107              0.000097 	en
  118              0.001362 	cal extend(s:ficounts, { s:dyncwd : [len(g:ctrlp_allfiles), catime] })
  118              0.000301 	retu g:ctrlp_allfiles

FUNCTION  <SNR>125_GlobPath()
Called 55 times
Total time:   3.531867
 Self time:   0.597719

count  total (s)   self (s)
   55              0.973810 	let entries = split(globpath(a:dirs, s:glob), "\n")
   55   0.139810   0.001487 	let [dnf, depth] = [ctrlp#dirnfile(entries), a:depth + 1]
   55              0.000478 	cal extend(g:ctrlp_allfiles, dnf[1])
   55   0.000734   0.000543 	if !empty(dnf[0]) && !s:maxf(len(g:ctrlp_allfiles)) && depth <= s:maxdepth
   44   0.148045   0.000432 		sil! cal ctrlp#progress(len(g:ctrlp_allfiles), 1)
   44   0.031533   0.003555 		cal s:GlobPath(join(map(dnf[0], 's:fnesc(v:val, "g", ",")'), ','), depth)
   44              0.000034 	en

FUNCTION  gitgutter#handle_diff()
Called 1444 times
Total time:  22.136836
 Self time:   0.122428

count  total (s)   self (s)
 1444   0.078373   0.012203   call gitgutter#debug#log(a:diff)
                            
 1444   0.072197   0.020683   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'tracked', 1)
                            
 1444   0.486831   0.019031   call gitgutter#hunk#set_hunks(gitgutter#diff#parse_diff(a:diff))
 1444   1.862843   0.015609   let modified_lines = gitgutter#diff#process_hunks(gitgutter#hunk#hunks())
                            
 1444              0.004461   if len(modified_lines) > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once('exceeded maximum number of signs (configured by g:gitgutter_max_signs).', 'max_signs')
                                call gitgutter#sign#clear_signs()
                                return
                              endif
                            
 1444              0.002821   if g:gitgutter_signs || g:gitgutter_highlight_lines
 1444  19.569218   0.021567     call gitgutter#sign#update_signs(modified_lines)
 1444              0.001044   endif
                            
 1444   0.040854   0.006815   call gitgutter#utility#save_last_seen_change()

FUNCTION  <SNR>107_get_syn()
Called 3022062 times
Total time: 116.587999
 Self time: 116.587999

count  total (s)   self (s)
3022062              8.543299   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
3022062              4.182563   let color = ''
3022062             23.611541   if hlexists(a:group)
2842820             27.667641     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
2842820              2.324782   endif
3022062              6.496764   if empty(color) || color == -1
                                " should always exists
512836              7.455181     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
512836              1.023106     if empty(color) || color == -1
512836              0.734431       let color = 'NONE'
512836              0.352357     endif
512836              0.276852   endif
3022062              3.247552   return color

FUNCTION  <SNR>269_IsInString()
Called 21 times
Total time:   0.002728
 Self time:   0.002728

count  total (s)   self (s)
   21              0.002700   return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_string

FUNCTION  136()
Called 432 times
Total time:   0.495762
 Self time:   0.140717

count  total (s)   self (s)
  432   0.107314   0.002084     if a:path.equals(self.path)
   51              0.000077         return self
                                endif
  381   0.091671   0.003737     if stridx(a:path.str(), self.path.str(), 0) ==# -1
  271              0.000358         return {}
                                endif
                            
  110              0.000202     if self.path.isDirectory
  389              0.000816         for i in self.children
  389   0.003731   0.001889             let retVal = i.findNode(a:path)
  389              0.000674             if retVal != {}
  110              0.000139                 return retVal
                                        endif
  279              0.000269         endfor
                                endif
                                return {}

FUNCTION  ctrlp#nosy()
Called 1124 times
Total time:   0.007930
 Self time:   0.007930

count  total (s)   self (s)
 1124              0.007131 	retu !( has('syntax') && exists('g:syntax_on') )

FUNCTION  gitgutter#hunk#set_hunks()
Called 1444 times
Total time:   0.113824
 Self time:   0.023997

count  total (s)   self (s)
 1444   0.054801   0.014984   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'hunks', a:hunks)
 1444   0.057755   0.007745   call s:reset_summary()

FUNCTION  <SNR>125_nosplit()
Called 34 times
Total time:   0.001353
 Self time:   0.001353

count  total (s)   self (s)
   34              0.001299 	retu !empty(s:nosplit) && match([bufname('%'), &l:ft, &l:bt], s:nosplit) >= 0

FUNCTION  <SNR>125_Close()
Called 109 times
Total time:   1.685015
 Self time:   0.068446

count  total (s)   self (s)
  109   0.003427   0.001064 	cal s:buffunc(0)
  109              0.000525 	if winnr('$') == 1
                            		bw!
                            	el
  109              0.010913 		try | bun!
  109              0.000830 		cat | clo! | endt
  109   0.003644   0.001109 		cal s:unmarksigns()
  109              0.000142 	en
 3706              0.013290 	for key in keys(s:glbs) | if exists('+'.key)
 1635              0.020076 		sil! exe 'let &'.key.' = s:glb_'.key
 3379              0.004132 	en | endfo
  109              0.000735 	if exists('s:glb_acd') | let &acd = s:glb_acd | en
  109              0.000395 	let g:ctrlp_lines = []
  109              0.000893 	if s:winres[1] >= &lines && s:winres[2] == winnr('$')
  109              0.003248 		exe s:winres[0].s:winres[0]
  109              0.000132 	en
  109              0.001253 	unl! s:focus s:hisidx s:hstgot s:marked s:statypes s:cline s:init s:savestr s:mrbs s:did_exp
  109   1.607549   0.000859 	cal ctrlp#recordhist()
  109   0.003734   0.001921 	cal s:execextvar('exit')
  109   0.004034   0.000866 	cal s:log(0)
  109              0.000586 	let v:errmsg = s:ermsg
  109              0.001783 	ec

FUNCTION  <SNR>118_readable_find_affinity()
Called 162 times
Total time:   1.050894
 Self time:   0.112630

count  total (s)   self (s)
  162   0.032409   0.001021   let f = self.name()
  162   0.835687   0.001319   let all = self.app().projections()
 3964   0.129422   0.064575   for pattern in reverse(sort(filter(keys(all), 'v:val =~# "^[^*{}]*\\*[^*{}]*$"'), s:function('rails#lencmp')))
 3824              0.010056     if !has_key(all[pattern], 'affinity')
 2240              0.002350       continue
                                endif
 1584              0.008812     let [prefix, suffix; _] = split(pattern, '\*', 1)
 1584   0.017022   0.009361     if s:startswith(f, prefix) && s:endswith(f, suffix)
   22              0.000117       let root = f[strlen(prefix) : -strlen(suffix)-1]
   22              0.000065       return [all[pattern].affinity, root]
                                endif
 1562              0.001317   endfor
  140              0.000203   return ['', '']

FUNCTION  <SNR>125_lastvisual()
Called 109 times
Total time:   0.020782
 Self time:   0.014734

count  total (s)   self (s)
  109              0.000920 	let cview = winsaveview()
  109              0.001161 	let [ovreg, ovtype] = [getreg('v'), getregtype('v')]
  109              0.000903 	let [oureg, outype] = [getreg('"'), getregtype('"')]
  109              0.005536 	sil! norm! gv"vy
  109   0.007783   0.001734 	let selected = s:regisfilter('v')
  109              0.001106 	cal setreg('v', ovreg, ovtype)
  109              0.000770 	cal setreg('"', oureg, outype)
  109              0.001909 	cal winrestview(cview)
  109              0.000324 	retu selected

FUNCTION  <SNR>125_SetDefTxt()
Called 109 times
Total time:   0.000799
 Self time:   0.000799

count  total (s)   self (s)
  109              0.000633 	if s:deftxt == '0' || ( s:deftxt == 1 && !s:ispath ) | retu | en
                            	let txt = s:deftxt
                            	if !type(txt)
                            		let path = s:crfpath.s:lash(s:crfpath)
                            		let txt = txt && !stridx(path, s:dyncwd) ? ctrlp#rmbasedir([path])[0] : ''
                            	en
                            	let s:prompt[0] = txt

FUNCTION  <SNR>125_SplitPattern()
Called 1015 times
Total time:   0.233905
 Self time:   0.170507

count  total (s)   self (s)
 1015              0.003803 	let str = a:str
 1015              0.004900 	if s:migemo && s:regexp && len(str) > 0 && executable('cmigemo')
                            		let str = s:migemo(str)
                            	en
 1015              0.002976 	let s:savestr = str
 1015              0.001762 	if s:regexp
                            		let pat = s:regexfilter(str)
                            	el
 1015              0.014753 		let lst = split(str, '\zs')
 1015              0.005466 		if exists('+ssl') && !&ssl
                            			cal map(lst, 'escape(v:val, ''\'')')
                            		en
 4060              0.010703 		for each in ['^', '$', '.']
 3045              0.045083 			cal map(lst, 'escape(v:val, each)')
 3045              0.005219 		endfo
 1015              0.001015 	en
 1015              0.003085 	if exists('lst')
 1015              0.002484 		let pat = ''
 1015              0.003138 		if !empty(lst)
  898   0.011592   0.007854 			if s:byfname() && index(lst, ';') > 0
                            				let fbar = index(lst, ';')
                            				let lst_1 = s:sublist(lst, 0, fbar - 1)
                            				let lst_2 = len(lst) - 1 > fbar ? s:sublist(lst, fbar + 1, -1) : ['']
                            				let pat = s:buildpat(lst_1).';'.s:buildpat(lst_2)
                            			el
  898   0.066359   0.006701 				let pat = s:buildpat(lst)
  898              0.001120 			en
  898              0.000819 		en
 1015              0.000886 	en
 1015              0.004821 	retu escape(pat, '~')

FUNCTION  <SNR>4_SynSet()
Called 106 times
Total time: 467.093802
 Self time:   5.195299

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
  106              0.001455   syn clear
  106              0.000420   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
  106              0.000444   let s = expand("<amatch>")
  106              0.000241   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
  106              0.000125   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
  212              0.001046     for name in split(s, '\.')
  106 467.086583   5.188079       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
  106              0.000475     endfor
  106              0.000155   endif

FUNCTION  airline#builder#new()
Called 5282 times
Total time:   0.178169
 Self time:   0.178169

count  total (s)   self (s)
 5282              0.045070   let builder = copy(s:prototype)
 5282              0.017967   let builder._context = a:context
 5282              0.013557   let builder._sections = []
                            
 5282              0.074289   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
 5282              0.009827   return builder

FUNCTION  <SNR>129_FGforBG()
Called 147 times
Total time:   0.004717
 Self time:   0.004717

count  total (s)   self (s)
                              " takes a 6hex color code and returns a matching color that is visible
  147              0.001457   let pure = substitute(a:bg,'^#','','')
  147              0.000856   let r = eval('0x'.pure[0].pure[1])
  147              0.000626   let g = eval('0x'.pure[2].pure[3])
  147              0.000605   let b = eval('0x'.pure[4].pure[5])
  147              0.000430   if r*30 + g*59 + b*11 > 12000
  105              0.000165     return '#000000'
                              else
   42              0.000050     return '#ffffff'
                              end

FUNCTION  <SNR>70_reindent()
Called 1 time
Total time:   0.001921
 Self time:   0.000085

count  total (s)   self (s)
    1              0.000012   if exists("b:surround_indent") ? b:surround_indent : (!exists("g:surround_indent") || g:surround_indent)
    1   0.001902   0.000066     silent norm! '[=']
    1              0.000003   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  503 2047.076988   0.028100  <SNR>61_BufWritePostHook()
  503 2046.896463   0.090408  <SNR>61_UpdateErrors()
  503 2044.826324   0.203272  <SNR>61_CacheErrors()
  503 2043.129600   0.012200  279()
  503 2043.079760   0.087745  278()
  504 2042.945441 2042.921831  syntastic#util#system()
  503 2042.547706   0.329243  SyntasticMake()
  296 1099.762701   0.025120  SyntaxCheckers_sass_sass_GetLocList()
  183 936.129274   0.008524  SyntaxCheckers_haml_haml_GetLocList()
  106 467.093802   5.195299  <SNR>4_SynSet()
   77 427.250969   0.017802  <SNR>125_AcceptSelection()
   77 427.218193   0.108100  ctrlp#acceptfile()
   75 425.672705   4.080191  <SNR>125_openfile()
46949 326.246973   7.247238  airline#check_mode()
 3159 318.466307  33.585320  airline#highlighter#highlight()
992215 223.112866  64.281928  airline#highlighter#exec()
1511031 174.591408  47.623832  airline#highlighter#get_highlight()
241980 126.359111   9.456522  <SNR>107_exec_separator()
3022062 116.587999             <SNR>107_get_syn()
483960  64.774468   3.064854  airline#themes#get_highlight()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  504 2042.945441 2042.921831  syntastic#util#system()
3022062            116.587999  <SNR>107_get_syn()
992215 223.112866  64.281928  airline#highlighter#exec()
1511031 174.591408  47.623832  airline#highlighter#get_highlight()
 3159 318.466307  33.585320  airline#highlighter#highlight()
992215             23.508989  <SNR>107_CheckDefined()
 2111  21.063931  20.800521  gitgutter#async#execute()
 8076  38.324496  16.440441  gitgutter#diff#run_diff()
2077915             14.055237  <SNR>107_Get()
720056             13.176964  <SNR>107_hl_group_exists()
 1054  28.056125  12.419345  <SNR>125_BuildPrompt()
 1444  11.708666  11.558001  gitgutter#sign#find_current_signs()
1511031             10.379577  <SNR>107_get_array()
241980 126.359111   9.456522  <SNR>107_exec_separator()
  106  14.868497   9.018612  <SNR>7_LoadIndent()
  137  22.202410   7.336332  rails#buffer_setup()
46949 326.246973   7.247238  airline#check_mode()
21090              5.921578  <SNR>79_Highlight_Matching_Pair()
  106  11.678347   5.232420  <SNR>13_LoadFTPlugin()
  106 467.093802   5.195299  <SNR>4_SynSet()

